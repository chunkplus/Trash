/**
 * 
 * About
 * 
 * 在cuda外围打转很长时间，关于架构的知识不打算再纠结下去，从今天开始切入代码学习。
 * 主要方法是通过重写cuda samples 的同时google代码解析，同时学习架构。
 * 
 * chunk 2014
 * 
**/


//0902

今天第一个例程是asyncAPI，网上没有找到解析。
不过程序readme中给出：This sample uses CUDA streams and events to overlap execution on CPU and GPU.

这个程序很小，只有一个.cu文件。作为第一个例程，makefile和程序的结构是重点。
	$^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的,那个这个变量会去除重复的依赖目标,只保留一份。
	$@   表示规则中的目标文件集。在模式规则中,如果有多个目标,那么,"$@"就是匹配于目标中模式定义的集合。

	= 是最基本的赋值
	:= 是覆盖之前的值
	?= 是如果没有被赋值过就赋予等号后面的值
	+= 是添加等号后面的值

1.INCLUDES  := -I../../common/inc
2.cuda编程模型
《cuda编程模型》
	记住三个图：
	1.三级线程组织
	2.内存分配模型
	3.硬件(SM和内存)结构
	
	其中，内存分配模型是pull request，当block分配至SM之后，由硬件对request进行检查、分配。
3.cuda编译
浅析CUDA编译流程与配置方法 (我们现在需要的是cuda程序的编译结构(例如.cu和cpp文件的综合处理))
	http://blog.csdn.net/shi06/article/details/5110017

	Nvcc是一种编译器驱动，通过命令行选项可以在不同阶段启动不同的工具完成编译工作，其目的在于隐藏了复杂的CUDA编译细节，并且它不是一个特殊的CUDA编译驱动而是在模仿一般的通用编译驱动如gcc，它接受一定的传统编译选项如宏定义，库函数路径以及编译过程控制等。CUDA程序编译的路径会因在编译选项时设置的不同CUDA运行模式而不同，如模拟环境的设置等。







