/*
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
*/

/*
 * new sem from 2013 May
 * 
 * 
 * copyright © chunk 2011 - 2015
 * 
 */
 
/////////////////////////////////////////////////////////////wk1
2013-02 ~ 2013-04，文献调研：阅读10篇左右的相关领域经典学术报告，撰写调研报告，并和指导教师讨论学习心得； 2013-05 ~ 2013-06，编程训练：每人重现1-3种经典人脸识别算法，深入分析各种因素对算法性能的影响，提交代码和试验结果分析； 2013-07 ~ 2013-08，创新提高：针对前期试验结果，对算法进行改进提高，完成创新性试验报告。
高性能
Exercises 1.1, 1.2, 1.3, 1.5, 1.6.
Note: Please ignore 1.4 part in 1.5. 
/////////////////////////////////////////////////////////////


本学期习题课安排在第4、7、9、12、15周的星期五，即3月22日、4月12日、4月26日、5月17日、6月7日。

上课地点：五教5104

分组和上课时间：
【王晓峰55】星期五第5大节（17:05-18:40）
【王晓峰56】星期五第6大节（19:20-20:55）

习题课讨论内容：见网络学堂-课程文件-习题课讨论题目中的文件，助教有可能会做些调整。

习题课与成绩的关系：在讲台上演算讲解题目会得到奖励（须学生本人签字登记），测验成绩计入课程总评成绩。

////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////wk2
*******************形式语言：

必做题:
? *! Ex.5.1.1(b)
? Ex.5.1.2(c) （最左推导和最右推导各一个）
? !Ex.5.1.6 (b)
? !! Ex.5.1.8
? !Ex.5.2.2
? Ex.5.4.7 (a)
附加1 构造如下语言的上下文无关文法：
（1） {a

（2） {a
n
（3） {a

（4） { uawb ? u,w ?{a, b}* ? | u | = | w | } 
附加2 给出语言 { a
附加3
思考题:
? !Ex.5.1.1 (c)
? !Ex.5.1.7 (a)
? Ex.5.4.7 ! (b)
? 附加
*******************概率论
作业需要独立完成，但交作业前可以就作业问题找教师或助教答疑

————————————————————————————
第1次（2月28日）
交作业日期：3月7日
截止日期：3月21日（未按期交作业者无考试资格，课程成绩为零分）
作业内容：
习题1.1：3（2、4）、6；
习题1.2：1（2、3、5，只须给出概率意义的解释性说明即可）、8、12、24；
习题1.3：2（对正确说法给以证明，对不正确说法举出实例）、11、13、23（不等式右端改为 sqrt(P(A)(1-P(A))P(B)(1-P(B)))，这里sqrt表示算术平方根）
选做题（成绩另加）：毛泽东同志说：“世界是你们的，也是我们的，但是归根结底是你们的。” 如果记A_n表示事件“第n天，世界是我们的”，B_n表示事件“第n天，世界是你们的”，请用事件序列A_n和B_n表示毛泽东同志的这句话。
*******************
任课教师定于5月17日至6月7日出差，第13-15周停课三次，所缺课程在第7、8、11周星期日（4月14、21日、,5月12日，暂定晚上）补课三次。

另外，第4、7、9、12、15周周五晚上将安排习题课，习题课有随堂测验，作为课程考核的一部分，测验成绩计入课程总评成绩，所有选课学生必须参加。
*******************

/////////////////////////////////////////////////////////////wk3
概率论
第2次（3月7日）
交作业日期：3月14日
截止日期：3月21日（未按期交作业者无考试资格，课程成绩为零分）

习题1.4：2、4、11、15、19、22、26、31；
习题1.5：2、3
选做题（成绩另加）：著名数学家Von Neumann说，即使用一枚不均匀的硬币也可以得到公平的机会。他的做法是：把这枚硬币掷两次，如果两次掷得的结果相同（都是正面或者都是反面），那么就接着再掷两次，直到出现两次结果不同，这时用倒数第二次掷得的面做为最终结果。这样最终得到正面和最终得到反面的机会一定都是0.5。请你证明Von Neumann的这个说法是对的。



第3次（3月14日）
交作业日期：3月21日
截止日期：3月28日（未按期交作业者无考试资格，课程成绩为零分）

习题1.5：12、17、19、20、21、22
习题2.1：3、7、9；
习题2.4：4、7、9、10
选做题（成绩另加）：不断重复抛掷一枚硬币直到出现连续两个正面时停止，X为抛硬币的次数，求X的概率分布列，已知掷一次得正面的概率为p。

22	2011011324	曾建强	计11	9-422	


1 5 15 40
15 40 20 1
1 5 18 1
18 1 20 1


/////////////////////////////////////////////////////////////wk4


各位同学：
第一次习题课旨在练习光栅图形学的算法让大家熟悉编程环境，能够尽快上手编写自己的程序。
本次习题课的作业为第二章光栅图形学的算法实现。

要求实现：
1.直线段和圆弧的扫描转换算法， 
2.多边形的扫描线及区域填充算法，
3.直线段和多边形的裁剪算法。
上述算法中可以固定好线段、多边形的坐标、像素点的颜色等；可以用三个cpp文件分别实现上述算法，并可以用一个test.cpp 顺序调用各算法进行显示。 
第二章其余算法选作。 

要求提交：实验报告，源代码(.h,.cpp)，可执行文件。 
以上内容打包为学号_姓名.rar格式，提交到ftp://cg.cs.tsinghua.edu.cn/2013本科生/course1/路径下，用户名cgcourse，密码cgcourse，

*作业不必在网络学堂提交，以ftp接收的作业为准。

截止日期为3月31日。

 谢谢！ 							
/////////////////////////////////////////////////////////////wk4
第三章：3.9, 3.10, 3.11, 3.14, 3.15, 3.16。第四章：4.3, 4.6, 4.18, 4.20
/////////////////////////////////////////////////////////////wk6
作业：设计一个32位快速进位加法器。



/////////////////////////////////////////////////////////////wk6

/////////////////////////////////////////////////////////////wk8
根据课程安排，期中测试将在第九周随堂（4月22日）进行，时间60分钟。测试范围包括第1~5讲。
开卷，但不允许使用手机、电脑等可无线通信的设备。草稿纸自备。


4月22日8:00，首先上课（第六讲）20分钟左右，紧接着开始考试。分两个教室：5202 和 5203。
留在5202教室的同学：2011011205~2011011292。 学号不在此范围的同学，请到5203。

另外，应部分同学要求，在“课程文件”栏上传了一份几年前的期中测试样题，仅供参考。注意：样题的满分为20，而本次测试中满分为100（总评时乘以20%）。

/////////////////////////////////////////////////////////////wk9


本课程的从第9周开始project设计，地点在东主楼9区422。
请大家务必在本周将本组的题目初定下来，周末前按照助教的要求提交，我将听取每组同学的可行性分析。
project设计的步骤是：
1. 根据自己的兴趣选题（8周前）；
2. 对题目进行可行性分析（第9周）；
3. 确定设计路线、方法和分工（第9周）；
4. 总体设计和概要设计（第10周）；
5. 详细设计（11～13）；
6. 测试验证（14～15）；
7. 验收展示（第16周）。




//今天，2013-05-02，在Modelsim仿真过程中，出现vmap错误，最后发现是路径中的空格出了问题
//在Quartus12和Modelsim整合过程中，出现了器件不支持错误，主要原因是激活失败。因为当时装了32位和64位，而破解sys_ctl.dll时只破解了x64并且选择破解文件时出现了差错


//任务：1.仿真工具熟悉，2.键盘程序熟悉，3.显示程序熟悉，4.数字实验，5.大作业，6.复习数电
//	7.修改实验报告



郭聪 07111103

C B G F I J H E A D   2.690670

F E A G O H Q N K R P M D L S J B T C I  33.076813
M H B L P Q S G C R T J A I K F O N E D  31.608561
D H O C L Q F J A R G I B N E T M K P S  31.608561
Q B N E G F O M H J P A L I R D S C K T  31.608561


R P E M T F Q I B L C A N K D H J O S G  24.522234
R P E M T F Q I B L C A N K D H J O S G  24.522234
R P E M T F Q I B L C A N K D H J O S G  24.522234
oyhe!


I B L C D A N K H J O S G R P E M T F Q  24.752552
T F Q I B L C D A N K H J O S G R P E M  24.752552
G R P E M T F Q I B L C D A N K H J O S  24.752552
R P E M T F Q I B L C D A N K H J O S G  24.752552
J H K N A D C L B I Q F T M E P R G S O  24.752552
O S G R P E M T F Q I B L C D A N K H J  24.752552
C D A N K H J O S G R P E M T F Q I B L  24.752552
Q I B L C D A N K H J O S G R P E M T F  24.752552
T F Q I B L C D A N K H J O S G R P E M  24.752552
S G R P E M T F Q I B L C D A N K H J O  24.752552
F Q I B L C D A N K H J O S G R P E M T  24.752552

P R G S O J H D K N A C L B I Q F T M E  3017 24.52223435
R G S O J H D K N A C L B I Q F T M E P  3175 24.52223435
N K D H J O S G R P E M T F Q I B L C A  3175 24.52223435
Q I B L C A N K D H J O S G R P E M T F  3058 24.52223435
O S G R P E M T F Q I B L C A N K D H J  3155 24.52223435
K N A C L B I Q F T M E P R G S O J H D  3109 24.52223435
J O S G R P E M T F Q I B L C A N K D H  3078 24.52223435
M T F Q I B L C A N K D H J O S G R P E  3096 24.52223435
D K N A C L B I Q F T M E P R G S O J H  3152 24.52223435
R G S O J H D K N A C L B I Q F T M E P  3168 24.52223435

Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800
Z T F Q W I B L C D A N K H J O U G S Y X R V P E M  0 27.05790800



V P E M Z T F Q W I B L C A N K D H J O U G S Y X R  2293 26.82758588
G U O J H D K N A C L B I W Q F T Z M E P V R X Y S  2356 26.82758588
Z T F Q W I B L C A N K D H J O U G S Y X R V P E M  2255 26.82758588
G U O J H D K N A C L B I W Q F T Z M E P V R X Y S  2285 26.82758588
O J H D K N A C L B I W Q F T Z M E P V R X Y S G U  2264 26.82758588
M Z T F Q W I B L C A N K D H J O U G S Y X R V P E  2366 26.82758588
G S Y X R V P E M Z T F Q W I B L C A N K D H J O U  2241 26.82758588
F T Z M E P V R X Y S G U O J H D K N A C L B I W Q  2311 26.82758588
A N K D H J O U G S Y X R V P E M Z T F Q W I B L C  2362 26.82758588
Q F T Z M E P V R X Y S G U O J H D K N A C L B I W  2292 26.82758588
W I B L C A N K D H J O U G S Y X R V P E M Z T F Q  2337 26.82758588


compete 10.dll 50.dll out1 5 >out2




/* 

今晚任务：1.完成vga显示键盘按键
		  2.srt之opencv代码阅读——harr，ada，lbp
		  
今晚任务：1.移动模型
			
			说明：输入——键盘控制信号（方向键（左、右、加、减），暂停键），车道包括六位：
				  输出——两位x坐标，两位y坐标，两位速度v；
				  			
		  2.vga定点
		  
			说明：输入——键盘控制信号（方向键（左、右、加、减），暂停键）
				  输出——小球在屏幕的位置变化

*/

/*
	关于car的补记：由keyboard项目的输出结果知，键盘码的断码也会被接收，如四个方向键的make码实际上两个八位，因此在控制区control.vhd中要建立一个状态机
*/

/*
数字逻辑实验考核
遇到的问题
1.s90的十进制进位判断问题：
	1.1 以‘0’代替‘10’进行判断
	1.2 0001->0010,0011->0100的竞争与冒险问题：个位	x->取反->与非取反->取反->取反->与非取反,四级延迟
2.s90输出时钟的不稳定问题：
	接地
3.停止控制
*/



/*
5.21
sram应用：
	例如有的这么用：
	把图的背景写进sram，然后只读不写，给他地址，数据出来

数据手册：
	读时序：
		建议片选信号一直有效，只用oe控制
	写时序(刷新内容)：
		同样，不建议用片选，只用写信号控制
		注意，数据总线输出信号要控制在高阻，因为总线是公用的，在写数据时要有控制权问题（详见word文档）
		
建议先写好mifSRAM，再下载fpga，防止数据总线占用

有限状态机：
	作用：时序总体控制，逻辑，死机调试（如signalTap）
	//最多三十几个个状态，其中很多状态是等时钟周期用的
	type stats is （S0，S1，S2，S3）
	signal curstat：S0；
	signal nextstat：S1；
	经典实例：AD采样，计算器状态机
	
	moore状态机设计:
		modelsim仿真，一劳永逸
	mealy：
		用的可能更多。既跟输入有关，又跟其他控制有关
	如：锁存器消毛刺
*/

基于特征向量统计而非基于模板匹配的学习：

1.HOG+SVM
2.LBP+Adaboost
3.Harr+Adaboost
*
1.MIT face database
2.INRIA
3.Daimler



#-------------------------------------------------
#
# Project created by QtCreator 2012-08-03T10:30:09
#
#-------------------------------------------------

QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = hog_test
TEMPLATE = app


SOURCES += main.cpp\
        dialog.cpp

HEADERS  += dialog.h

FORMS    += dialog.ui

INCLUDEPATH +=  E:\Programs\OpenCV2.3.1\opencv\build\include \
                E:\Programs\OpenCV2.3.1\opencv\build\include\opencv \
                E:\Programs\OpenCV2.3.1\opencv\build\include\opencv2

LIBS +=  -L E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib  \
             -lopencv_core231d \
             -lopencv_features2d231d \
             -lopencv_gpu231d \
             -lopencv_highgui231d \
             -lopencv_imgproc231d \
             -lopencv_ml231d \
             -lopencv_video231d \
             -lopencv_calib3d231d \
             -lopencv_contrib231d \
             -lopencv_flann231d \
             -lopencv_legacy231d \
             -lopencv_objdetect231d


INCLUDEPATH +=  E:\Programs\OpenCV2.3.1\opencv\build\include \
                E:\Programs\OpenCV2.3.1\opencv\build\include\opencv \
                E:\Programs\OpenCV2.3.1\opencv\build\include\opencv2

LIBS +=  E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_core231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_features2d231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_gpu231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_highgui231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_imgproc231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_ml231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_video231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_calib3d231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_contrib231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_flann231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_legacy231d.lib \
         E:\Programs\OpenCV2.3.1\opencv\build\x86\vc10\lib\opencv_objdetect231d.lib




//modelsim使用总结：关键问题是不停地全编译。。。
1、首先要生成testbench文件，并在指定仿真工具时指定仿真实例
2、指定库编译输出路径，顺便回到settings设置编译路径（貌似不管用）
3、启动仿真，这时生成了仿真编译库和针对当前工程的防震工作路径
4.修改.do文件，或者将simulate.do,compile.do,restart.do放到工作路径并修改
5、启动"do compile.do"，并保存波形为wave.do,再启动"do simulate.do"
6.关于testbench：注意先确定时钟，考虑wait 语句的特殊性


2013-05-23晚SRT第四次组会，谢老师关于人脸检测提的几点建议：
1.hog和lbp可以结合使用
2.挖洞法
3.背景排除法
4.面向高度的分层
5.人脸和人身：先检测人脸，再由人脸推测人身，并验证
6.复杂性关键是侧脸、坐姿等影响，一定要结合纹理特征
7.视域





//digital：现在的问题：方向键和其他键产生的信号效果不同，说明状态机有问题。不管了，下一步先做vga

/*
13周周末任务：
1.VGA				（周日上）
2.opencv--面向图形学	（周六下，晚）
3.人智之评估函数v1.0	（周日下）
4.人智之遗传算法
5.复习概率论和形式语言
6.大物实验报告


1.买东西（周六晚）
2.公交车调研（周六晚），（绳子）

*/

//intel 64 and ia-32 architechtures software developer's manual

//2013-05-26 零食（88）+西瓜（53）+玩具（22）=163

/*
*光线跟踪大作业

– 简单的光线跟踪 
 包含简单的元素：立方体、多面体、球体
 效果：phong模型, 纹理, 镜像, 透明, 阴影
 可选: 加速技术，其它的BRDF模型，高维纹理，软阴影 …
 不允许使用OpenGL
见Lect_4课件
*作业提交时间：
提交截止日期为第17周周日（6月23日），然后到FIT楼3区524找助教现场演示，检查时间为第18周，具体时间待通知。
*作业提交方式：
通过FTP上传，
ftp：ftp://cg.cs.tsinghua.edu.cn/ 
用户名：cgcourse
密码：cgcourse
光线跟踪大作业，请放在路径：“./2013undergraduate/RayTrace/”下
格式等要求详见附件
汪淼

*/
/*
暑期任务：
1.界面编程能力
2.网站管理
3.娱乐：服务器设置和facebook
4.实现最重要的一个设计：？
5.SRT
6.matlab

《GOLD》——这部由“日剧女王”天海佑希
7.Linux内核源代码情景分析 yu UNIX
*/
/*
在给定的语料上训练一个简单的文本分类器，用推荐的工具来实现即可，请见作业文件。
*/




/*
调了两天，文件流操作占了三成时间，数据类型转换（char，wchar，lpstr）占了三成时间，读程序占了一成时间
现在的进度是，基本上能构建训练库，但第6个文件在dropwords时出错。另外，分类过程尚未调试。
*/


/*
方法：
小车图层：
1.传入小车的世界坐标（carX，carY）；扫描信号（posX，posY）
2.将（carX，carY）映射到屏幕坐标（通过取模和偏置）；
3.
背景图层：
1.传入小车的世界坐标（carX，carY）；扫描信号（posX，posY）

*/

/*
7*7：（x*y）
4*20

6*8
1.7*20

4*10：
0.7*40

10*4：
50+*20+
*/
//
/*
erase操作极易出错，且耗费极大
*/


/*
0,64 192,256 384,448
*/

/*
构建每个文档的特征向量：
	已得到词汇表V（<单词，文档次数>）和每个类别的分词汇表C（<单词，次数>）
	构建向量模板(ww0,ww1,ww2,...)
	对于每篇文档j，得到mapj,扫描每个单词wxj,得到w(wxj) =mapj(x)*1/V(x)
*/

/*
1.障碍物
2.里程
3.终点及胜利
4.立体感
5.弯道

762-138
*/

/*
一、程序框架 5’
1.程序总体
2.小车逻辑
3.vga和rom
二、演示效果 2‘
*/


0605 20:48
/*
*光线跟踪大作业

– 简单的光线跟踪 
 包含简单的元素：立方体、多面体、球体
 效果：phong模型, 纹理, 镜像, 透明, 阴影
 可选: 加速技术，其它的BRDF模型，高维纹理，软阴影 …
 不允许使用OpenGL
见Lect_4课件
*作业提交时间：
提交截止日期为第17周周日（6月23日），然后到FIT楼3区524找助教现场演示，检查时间为第18周，具体时间待通知。
*作业提交方式：
通过FTP上传，
ftp：ftp://cg.cs.tsinghua.edu.cn/ 
用户名：cgcourse
密码：cgcourse
光线跟踪大作业，请放在路径：“./2013undergraduate/RayTrace/”下
格式等要求详见附件
汪淼

*/
/*
0527
关于obj文件和raytrace算法
		顶点数据(Vertex data)： 
		　　 v 几何体顶点 (Geometric vertices) 
		　　vt 贴图坐标点 (Texture vertices) 
		　　vn 顶点法线 (Vertex normals) 
		　　vp 参数空格顶点 (Parameter space vertices) 
		自由形态曲线(Free-form curve)/表面属性(surface attributes): 
		　　deg 度 (Degree) 
		　　bmat 基础矩阵 (Basis matrix) 
		　　step 步尺寸 (Step size) 
		　　cstype 曲线或表面类型 (Curve or surface type) 
		元素(Elements): 
		　　p 点 (Point) 
		　　l 线 (Line) 
		　　f 面 (Face) 
		　　curv 曲线 (Curve) 
		　　curv2 2D曲线 (2D curve) 
		　　surf 表面 (Surface) 
		自由形态曲线(Free-form curve)/表面主体陈述(surface body statements):
		　　parm 参数值 (Parameter values ) 
		　　trim 外部修剪循环 (Outer trimming loop) 
		　　hole 内部整修循环 (Inner trimming loop) 
		　　scrv 特殊曲线 (Special curve) 
		　　sp 特殊的点 (Special point) 
		　　end 结束陈述 (End statement) 
		自由形态表面之间的连接(Connectivity between free-form surfaces):
		　　con 连接 (Connect) 
		-成组(Grouping): 
		　　 g 组名称 (Group name) 
		　　s 光滑组 (Smoothing group) 
		　　mg 合并组 (Merging group) 
		　　o 对象名称 (Object name) 
		-显示(Display)/渲染属性(render attributes):
		　　bevel 导角插值 (Bevel interpolation) 
		　　c_interp 颜色插值 (Color interpolation) 
		　　d_interp 溶解插值 (Dissolve interpolation) 
		　　lod 细节层次 (Level of detail) 
		　　usemtl 材质名称 (Material name) 
		　　mtllib 材质库 (Material library) 
		　　shadow_obj 投射阴影 (Shadow casting) 
		　　trace_obj 光线跟踪 (Ray tracing) 
		　　ctech 曲线近似技术 (Curve approximation technique) 
		　　stech 表面近似技术 (Surface approximation technique)

0605 
1.关于消隐算法的比较
	http://cs.fjzs.edu.cn/ketang/VCLASS/NCOURSE/txx/Chapter2/CG_Txt_2_001.htm
	http://wenku.baidu.com/view/a6c5c5629b6648d7c1c7461e.html
	http://blog.csdn.net/weiqubo/article/details/7031533
2.几何造型技术
	在几何造型系统中，描述物体的三维模型有三种，即线框模型、表面模型和实体模型。
0606
1.样条和bezier面片和NURBS
2.简单光照明模型
	在上一节介绍的Phong光照明模型中，由于光源和视点都被假定为无穷远，最后的光强计算公式就变为物体表面法向量的函数，这样对于当今流行的显示系统中用多边形表示的物体来说，它们中的每一个多边形由于法向一致，因而多边形内部的象素的颜色都是相同的，而且在不同法向的多边形邻接处，不仅有光强突变，而且还会产生马赫带效应，即人类视觉系统夸大具有不同常量光强的两个相邻区域之间的光强不连续性。
	为了保证多边形之间的光滑过渡，使连续的多边形呈现匀称的光强，我们将介绍增量式光照明模型。模型的基本思想是在每一个多边形的顶点处计算合适的光照明强度或参数，然后在各个多边形内部进行均匀插值，得到多边形的光滑颜色分布。它包含两个主要的算法:双线性光强插值和双线性法向插值，又被分别称为Gouraud明暗处理和Phong明暗处理。

3.局部光照明模型 
	我们把仅处理光源直接照射物体表面的光照明模型称为局部光照明模型，而与此相对应的，可以处理在物体之间，光照的相互作用的模型称为整体光照明模型
	简单光照明模型，可以计算经点光源照明的物体表面的光强，实际上就是一种局部关照明模型，但是，它是一种经验模型，认为镜面反射项与物体表面的材质无关，这与实际的情况是不一致的，在本节中，我们将从光电学领域知识和物体的微平面假设出发，介绍一个更复杂更普遍的局部光照明模型，这个光照明模型在后面的整体光照明模型中，计算局部光强时被经常使用。

	Cook和Torrance于1981年提出了这个局部光照明模型[COOK81].

4.光透射模型

	反射光可以用简单光照明模型或局部光照明模型计算，而对透射光的计算，1980年Whitted提出了一个光透射模型[WHIT80] ：Whitted模型，并第一次给出光线跟踪算法的范例，实现了Whitted 模型。1983年，Hall在此进一步给出Hall光透射模型[HALL83]，考虑了漫透射和规则透射光。

5.纹理及纹理映射

*/
/*
http://blog.jobbole.com/29281/
对于Python新手应该从哪本开始，如果各位朋友有不同看法，欢迎在评论中留言。
Think Stats
Dive Into Python
A Byte Of Python
Think Complexity
Dive Into Python 3
DJANGO TUTORIAL
Building Skills In OOP
Pyramid For Humans
Flask Microframework
Building Skills In Python
Kivy Programming Guide
Snake Wrangling For Kids
An Introduction To Python
Programmez Avec Python 2
Programmez Avec Python 3
Python Module Of The Week
Learn Python The Hard Way
The Standard Python Library
Building Skills In Programming
Python Scientific Lecture Notes
Making Games With Python & Pygame
Python 101 (an introduction to python)
How To Think Like A Computer Scientist
Natural Language Processing With Python
Programming Computer Vision With Python
*/
//
//英语论文：十亿消费者


//compete 10.dll 50.dll out1 5 >out2

/*

0607:
1.connect4_2011:
	1.1 评价函数getf：横向、纵向、斜向分别检查 ，连成4个赋最大，连成三个1000，连成两个100，连成一个10(累加制)
	1.2 ab算法：就是极大极小，没有剪枝
	1.3 调用函数：对每一个可下点，假设己方走这一步，若己方赢或平，赋value大值；ab剪枝更新value。最终取value最大者

2.connect4_2010:






1.common.h
	定义：图形常量，数学函数，基本图形元素
	改进：vector3、matrix、plane可以用opencv
2.memory.h
3.raytracer.h
	Ray
	Engine:渲染，追踪（核心）
4.scene.h
	Texture，Material，Vertex，Light，KdTreeNode，KdTree
	Primitive：（核心，包括Intersect(),IntersectBox(),IntersectTriBox(),IntersectSphereBox(),）
	ObjectList:链表
	Scene
5.surface.h
	Surface：视野（画布）

*/

/*

//
strategy_m2:
 1.还比较幼稚，自己会创造条件，但不考虑这些条件将来可能立即被堵死
 2.自己下时，会优先考虑xx_x,这说明三联的权重小了
 3.防御性不够
 4.先手的策略看起来还是那么回事
 
 5.depth=6竟然是极限了，怎么办？
 6.第一步竟然放在了no列上！

 7.跟他的前辈差距还很大。参数没有优化。搜索空间也没有优化

//
图形学最后一节：
2013-05-17 大数据与智慧城市给图形学带来的机遇和挑战

刘永进：从点云到圆柱的识别
*/
/*
90战记：
	90的策略性强，估计搜索层数较深。下一步的任务是优化速度，使其在depth=6甚至是7时能运行流畅；另外是改参数。现在基本解决了极点的处理，除非是死棋。
	现在布棋离散化严重。
*/
/*
键盘部分：
	用一个高频的时钟来过滤掉无用的信号（防抖），用状态机来实现键盘的输入，每次读到一个F0时由st0进入st1，只在st1状态时判断信号是否为有效的游戏操作，然后再转入st0。

游戏逻辑部分：
	
	在输入有效游戏操作后下直接对x v 进行更改，表示左右移和加减速。逻辑中有一个时钟，表示游戏的运行速度，每次上升沿的时候，将y = y + v，表示小车向前走了一段距离，同时游戏时间（time）减少。每次对小车位置进行更改之后，都会扫描一遍障碍物，如果发现小车与障碍物有重合部分，则使速度降为初始速度。同时判断一次小车是否已经到达终点，若到达判断为胜利。pause和set为暂停和复位，当pause = 0 时小车位置更改和游戏时间更改才会生效；当set = 1是将游戏复位，同时将set置为0 ，直到接受到复位信号（回车）才将set置为1。

遇到的问题：
	
	1.键盘的输入问题，一开始没有采用状态机，按一个键将产生很多个操作，利用enable信号和状态机很好的解决了这个问题。
 

	2.小车遇到障碍物后出现BUG，判断出现了问题，修改判断语句的顺序和执行顺序后解决了这个问题。

总结与体会：
	硬件编程不同于软件编程，一条语句相当于接一条线，需要好好思考之后才能写出自己想要的逻辑判断。

*/



/*
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
每天都要读论文！！！！！！！！！！！！！！
*/


/*
0611


1.opencv基础

	1.cvscalar：四位double标量。一般用于颜色表示。#define CV_RGB(r,g,b) cvScalar((b),(g),(r),0)
	2.iplimage：基础图像结构.图像头.Intel Image Processing Library (IPL)。IplImage* cvLoadImage( const char* filename, int iscolor);
				int cvNamedWindow( const char* name, unsigned long flags );
				void cvShowImage( const char* name, const CvArr* image );//其中，name是窗口名称，image是图像类型指针，一般是IplImage指针。
				int cvSaveImage( const char* filename, const CvArr* image );
				void cvReleaseImage( IplImage** image );
	3.cvmat：重要的矩阵变换函数。OpenCV将向量作为1维矩阵处理。矩阵按行存储，每行有4字节的校整.
				CvMat* cvCreateMat(int rows, int cols, int type);//type: 矩阵元素类型. 格式为CV_<bit_depth>(S|U|F)C<number_of_channels>.  例如: CV_8UC1 表示8位无符号单通道矩阵, CV_32SC2表示32位有符号双通道矩阵.
				cvReleaseMat(&M);
				M2=cvCloneMat(M1);
				double a[] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
				CvMat Ma=cvMat(3, 4, CV_64FC1, a);
				cvInitMatHeader(&Ma, 3, 4, CV_64FC1, a);
				
				cvmSet(M,i,j,2.0); // Set M(i,j)
				t = cvmGet(M,i,j); // Get M(i,j)
				
				cvAdd(Ma, Mb, Mc);        // Ma+Mb     -> Mc
				cvMatMul(Ma, Mb, Mc);     // Ma*Mb     -> Mc
				cvMul(Ma, Mb, Mc);        // Ma.*Mb    -> Mc
				double res=cvDotProduct(&Va,&Vb); // 点乘:     Va . Vb -> res
				cvCrossProduct(&Va, &Vb, &Vc);      // 向量积: Va x Vb -> Vc
	4.CvArr:不确定数组.CvArr* 仅仅是被用于作函数的参数，用于指示函数接收的数组类型可以不止一个，如 IplImage*, CvMat* 甚至 CvSeq*. 			最终的数组类型是在运行时通过分析数组头的前4 个字节判断。 

2.程序解读2--RT8
	//跟着希望跟着光 我是不落的太阳
	
	光线跟踪是 光线求交、光线投射、阴影 和 反射折射光线跟踪 的结合体。
	扩展功能一：纹理
	扩展功能二：加速（Bounding Box，Hierarchical Structure，Oct-Tree，Slab 的快速长方体求交算法）
	
	
	1。基础结构
	
		1.1
		vector3D:点或向量。三个float。各种运算。
		Common：定义RGB结构。
		Material：材质。各种反射率、透射率、折射率、高光指数。
		Light：光照类。位置、强度。
		
		1.2
		SceneFace：物体表面。材质、纹理、CBP。求交Intersection。
			Plane：平面。顶点数组、法向量。求交、求CloseBox。
			Ball：球面。球心、球径。求交、求CloseBox。
			Box：包围盒。大、小。求交、求CloseBox。
		LineRotateFace：旋转型曲面。直线、平移点。求交、求CloseBox。
		EightBranchTree：八叉树。结点、包围盒。立方体求交各种函数。	
		
		1.3		
		MyScene：主类。视点、光源数组、景物面列表、
		RayTracing：
		
		Glm：openGL图像操纵函数
	
	2.实现
		2.1
		Ball的直线求交用的课件中的代数方法，即解一个一元二次方程。可以考虑采用老师的几何方法。
		CloseBox：采用平行坐标轴的包围盒。//Kay和Kajiya取若干统一的方向为平面法向，并取n小于5
		EightBranchTree：工作量大。主要是对模型的预处理、求包围盒、构建包围树、求交搜索。
		mydib定义了文件读取操作。
		MyScene：光线跟踪函数。核心。

3.程序解读3--RT7
*/

/*
开放式project报告的书写要求
正文	
project需提交实验报告及工程文件，单独一个文件夹（打包提交）
工程文件夹中请删除多余文件，只需包含：
Quartus工程文件 .qpf
Quartus设置文件 .qsf，该文件包含引脚绑定等信息
VHDL源文件 .vhd，程序应进行必要的注释
.mif文件（如果用到则提交）
如果有原理图文件 .bdf，则提交
波形仿真文件 .vwf（若用其它仿真工具则提交仿真相关文件，并在报告中说明）
其它编译过程中必须的文件
编程下载文件.sof或.rbf

project报告请提交doc、docx或pdf格式。以project名称_姓名_学号
作为报告文件的名字，内容包括：

总体设计思路。如果有多个模块或文件，要写清顶层设计、各模块划分与功能。
关键技术分析。包括分析设计中的主要技术要点和难点。
有进行仿真的，可附带波形仿真结果及简单说明。
下载验证及演示说明。即写清输入输出所用开关、数码管、键盘、显示器等信息。
实验中遇到的问题及解决方法。
可写对教学的建议、实验总结与体会，不强制要求。

我们将根据报告说明，编译、下载验证。报告、验证结果连同展示和同学给出的成绩共同构成最后成绩。
*/




目标一：实现基础结构：材质，光照，物体
目标二：实现表面类和场景类


/*
网格简化大作业
基本要求

1.实现边坍塌（edge-collapse）的网格简化方法。
参考文献：Surface Simpli？cation Using Quadric Error Metrics.

2.程序能指定输入输出的obj文件，以及面数的简化比（输出面数占输入面数的百分比），例如命令行程序可以支持如下参数
mesh_simp.exe  输入.obj  输出.obj  简化比（例如0.3）

3.我们提供c++的obj文件parser (ftp下载 ./2013undergraduate/Mesh_helper/)

4.在我们提供的测试模型上进行测试 (ftp下载 ./2013undergraduate/Mesh_helper/)

选做部分：

 1.自己编写程序进行网格的显示（这里就可以允许使用OpenGL了）。
 2.实现其它的简化方法，比如顶点去除方法。
 3.其他你能想到的一些扩展，最好是对现有方法的改进。

详见 课程文件 网格简化习题课ppt。

提交方式：
    ftp提交  ftp://cg.cs.tsinghua.edu.cn
   用户名 cgcourse 密码 cgcourse
   提交到./2013undergraduate/Mesh/路径下

截止日期 2013.6.23日。

*/
/*
0614
概率论：
考前答疑：6月28日，上午8:30-11:00，下午14:00-16:00；地点：六教6A111
考试时间：6月29日（星期六）上午8:00-10:00.
概率论部分
一、	随机现象的数学描述和概率论的基本思想
1.	理解描述随机现象的各种概念（随机试验、样本、样本空间、事件及随机变量）以及这些概念之间的相互关系
2.	掌握事件关系和事件的基本运算。
3.	掌握概率的基本性质，了解概率的连续性。
4.	理解条件概率的直观含义和数学定义，掌握条件概率在概率计算中的应用（乘法公式、全概率公式、Bayes公式）。
5.	理解事件的独立性的定义和有关性质。
6.	理解古典概型、几何概型的基本原理。
【以下内容不作考试要求：
1、	事件域；
2、	事件列的极限与概率的连续性；
3、	确定概率的主观方法
4、	试验的独立性
5、复杂的计数技巧
】
二、	随机变量的概率分布
1.	理解随机变量及其概率分布函数的定义，理解随机变量概率分布函数的性质，掌握概率分布函数的计算。
2.	理解离散型随机变量、连续型随机变量的定义，掌握概率分布列、概率密度函数及概率分布函数的关系，掌握有关的计算。
3.	理解多维随机变量的定义，理解联合概率分布（分布函数、分布列、概率密度）与边缘分布（分布函数、分布列、概率密度），掌握有关计算。
4.	理解随机变量的独立性的定义和性质，知道判断独立和不独立的方法。
5.	掌握计算随机变量的函数的概率分布的方法：
a)	利用概率分布函数；
b)	利用函数关系，直接计算概率密度的方法（Jacobi）：一对一（可逆变换）情形；多对一（分段可逆变换）情形。
c)	独立和的概率分布。
d)	最大值与最小值的概率分布。
6.	理解条件概率分布（分布函数、分布列、概率密度）的定义和相关计算。
【以下内容不作考试要求：
1、	随机和（指形如 的随机变量，其中 是随机变量）
2、	分布函数的性质的证明
】

三、	随机变量的数字特征
1.	单个随机变量的数字特征
a)	数学期望和方差：
i.	理解数学期望的定义，理解数学期望的存在性，掌握数学期望的性质和计算。
ii.	方差：理解方差的定义和直观含义，掌握方差的性质和计算。
iii.	理解如何把随机变量进行标准化改造（期望=0，方差=1）。
iv.	理解数学期望和方差的最小二乘含义。
b)	原点矩和中心矩。
c)	分位数和中位数：理解分布的（下侧）分位数的定义，以及它们在概率分布函数和概率密度函数图像上的直观含义。
2.	涉及多个随机变量的数字特征
a)	协方差：理解协方差的定义和性质（对称、双线性、与独立性的关系），掌握协方差的计算
b)	相关系数：理解相关系数的定义和性质，掌握有关计算。正确理解不相关和独立的联系与区别。知道线性相关系数为1或-1时的含义。
c)	条件数学期望：理解定义和有关计算，掌握全期望公式。
【以下内容不作考试要求：
1、变异系数、偏度系数、峰度系数
2、最小二乘法
】
四、	常见的概率分布
1.	离散型分布
a)	Bernoulli分布、二项分布：分布列，两个分布之间的关系，期望、方差。
b)	几何分布：分布列，期望、方差，无记忆性。
c)	Poisson分布：分布列，期望、方差，Poisson定理（特殊二项分布的Poisson近似）
d)	了解负二项分布：结合Bernoulli试验理解它和几何分布之间的关系，并利用这个关系计算期望和方差。
e)	了解超几何分布的背景和基本性质。
2.	连续型分布
a)	均匀分布：一维均匀分布的分布函数、概率密度、期望和方差；多维均匀分布与几何概型的关系。
b)	指数分布：分布函数、概率密度、期望、方差，无记忆性。
c)	正态分布：一维正态分布的概率密度、期望、方差、标准化；二维正态分布的概率密度及参数的统计含义。掌握可逆仿射变换下正态性的不变性，正态分布的独立可加性，正态分布随机变量独立性判断等有关结论。
d)	 分布、t分布、F分布：模式化定义（例如，n个独立的一维标准正态随机变量的平方和服从自由度为n的 分布）和性质
【以下内容不作考试要求：
1、负二项分布、一般形式的伽马分布和贝塔分布
2、Poisson过程
3、 分布、t分布、F分布的概率密度函数
】
五、	极限定理
1.	（Bernoulli、Chebyshev、Markov、辛钦的）（弱）大数定律，Chebyshev不等式及其应用，依概率收敛的定义和验证。
2.	中心极限定理（独立同分布情形De Moivre-Laplace，Lindeberg-Levy）及其应用。
【以下内容不作考试要求：
1、按分布收敛、弱收敛
2、特征函数
3、独立不同分布情形的中心极限定理
】

数理统计初步部分
六、	数理统计的基本概念
1.	总体、抽样、样本、经验分布函数、统计量及其抽样分布、
2.	重要的统计量：次序统计量、样本均值、样本方差、样本标准差、样本矩
3.	正态总体的重要统计量及其性质，与正态总体有关的重要抽样分布： 分布，t-分布，F-分布。
【以下内容不作考试要求：
1、样本数据的整理与显示、五数概括与箱线图
2、充分统计量
】

七、	参数的点估计
1.	点估计的常用方法：矩估计、极大似然估计（似然函数、对数似然函数）
2.	点估计优良性评判：无偏性，有偏估计的无偏化，无偏估计的有效性（比较方差大小）、相合性（又称一致性）、均方误差
 【以下内容不作考试要求：
1、EM算法
2、最大似然估计的渐近正态性
3、最小方差无偏估计、充分性原则、Cramer-Rao不等式
4、贝叶斯估计
】

八、	参数的区间估计和假设检验
1.	区间估计的概念、枢轴量法
2.	单个正态总体均值和方差的区间估计
3.	大样本置信区间
4.	假设检验中的基本概念：原假设与备择假设，检验统计量和拒绝域，两类错误，检验的显著性水平
5.	单个正态总体均值的检验
【其他不作考试要求，检验的p值】

*/



可以初始化const对象或引用类型的对象，但不能对他们赋值。在开始执行构造函数的函数体之前，必须完成初始化。初始化const或引用类型数据成员的唯一机会是在构造函数初始化列表中.static成员 要在类的定义外面初始化。只有静态常量在能在类中初始化.




//
myRT_DOC
文档：
1.common.h：定义基础的点、向量、矩阵、颜色等结构
2.object.h：定义light、ray、material、textur、primitive
3.

/*
http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_2_Phong_Mirrors_and_Shadows.shtml
One of the cool things about raytracing is that if you plug in something new, all the other things still work. For example, adding shadows and Phong highlights also adds reflected shadows and highlights. This is probably related to the parallel nature of raytracing: Individual rays are quite independent, which makes recursive raytracing very suitable for rendering on multiple processors, and also for combining various algorithms.
*/


1.以伟哥为基础
2.最终达到rt7的水平(通过学习http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_2_Phong_Mirrors_and_Shadows.shtml
)

3.封装性



光线跟踪
下一步：1.解决透明问题(三角计算) 2.增加box 3.柔和阴影 4.抗锯齿
		5.网格简化

80:a8:9a:4d:24:37:0f:8e:43:33:d4:f2:06:de:d1:48

ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6Yx1vtNst3f7e3m4Ju4+u2SXWR8OFyg5e7YGZvFWP9WHS/7W7h6QnbfadFVXQp+f+AFpdxGqoe1oQgwThBcC8Auvg9XPstypDDsZWYgmq28+60dOwcI7hZfqSRmOgpYRr/jh/uQD8+uq3bkK3UB61iqka4rb1SIdp5X/WAfTcOw8C97RWB29xPocZEUYvMBzNCe+v26CWRACRBwVVFBKpzq14tMDjtW5H0iL/3xB6re4ZP9MHDSLa8+96HtGT1u86Q+PF/eMJI4N+LksscN7fV4pxWYmNa1FCnhexy9TE7o3Dj/RvDSdlTdeEaiS7UZzAu0GiUsxSf6MmxIzN5K5Iw== Administrator@ZJQ-PC


/*
 * new sem from 2013 May
 * 
 * 
 * copyright © chunk 2011 - 2015
 * 
 */
  
//
/*
http://blog.jobbole.com/29281/
对于Python新手应该从哪本开始，如果各位朋友有不同看法，欢迎在评论中留言。
Think Stats
Dive Into Python
A Byte Of Python
Think Complexity
Dive Into Python 3
DJANGO TUTORIAL
Building Skills In OOP
Pyramid For Humans
Flask Microframework
Building Skills In Python
Kivy Programming Guide
Snake Wrangling For Kids
An Introduction To Python
Programmez Avec Python 2
Programmez Avec Python 3
Python Module Of The Week
Learn Python The Hard Way
The Standard Python Library
Building Skills In Programming
Python Scientific Lecture Notes
Making Games With Python & Pygame
Python 101 (an introduction to python)
How To Think Like A Computer Scientist
Natural Language Processing With Python
Programming Computer Vision With Python
*/


/*
有时间看看eva剧场版http://www.zhihu.com/question/20633261
*/



2013-05-23晚SRT第四次组会，谢老师关于人脸检测提的几点建议：
1.hog和lbp可以结合使用
2.挖洞法
3.背景排除法
4.面向高度的分层
5.人脸和人身：先检测人脸，再由人脸推测人身，并验证
6.复杂性关键是侧脸、坐姿等影响，一定要结合纹理特征
7.视域

/*
暑期任务：
1.界面编程能力
2.网站管理
3.娱乐：服务器设置和facebook
4.实现最重要的一个设计：？
5.SRT
6.matlab

《GOLD》——这部由“日剧女王”天海佑希
7.Linux内核源代码情景分析 yu UNIX
*/

急需qt源文件

Qt笔记
1.每一个Qt类都有自己的头文件（并且大写）
2.widget的灵活性（每一个label都可以作为窗口显示）
3.

//////////////////////////////////////////////////////////////////

1.鸟哥linux--------------------1
2.PHP--------------------3
3.Java--------------------2
4.Qt--------------------4
5.Matlab--------------------5
6.algorithm--------------------6
7.矩阵代数--------------------7



//PHP
httpd.conf:1.ServerRoot&Listen Port	2.Dynamic Shared Object (DSO) Support	3.'Main' server configuration					4.DocumentRoot	5.
1.ServerRoot: The top of the directory tree under which the server's configuration, error, and log files are kept.


//
 Qt5推出一段时间了，经过了试用，虽然还存在一些问题，比如Designer 缺少 WebView 和 ActiveQt 的UI工具，此外 WebKit 的 Release 版本似乎和Visual-Studio 2012 Express 编译器不太吃劲，老是报运行时错误——好在目前用到的模块都测试过了。
1，修改路径系统。Qt4 的 QtGUI下很多类被独立到widgets模块里了，为了提高兼容性，把这些include 的抬头全去了，直接是 #include<qapplication> ，这样，通过 Qt += 模块名，即可弥合4,5之间的差异。
2，添加一个宏替换，Qt ::WFlag变成 Qt5 的 WindowFlags, 小问题。
3，插件系统的修改。 新的 Q_PLUGIN_METADATA 在插件实现类的首部，代替了以往在 CPP里Export 的模式，对迁移没有影响。加入编译预处理宏，判断一下标志，决定采用哪一种方法。
4，字符串处理方式问题。目前，由于项目对中文、英文和国际化的使用较为规范，没有遇到乱码的问题，可以认为兼容性较好。
5，第三方依赖性
      如果引用了 PostgreSQL 或 MySQL的Sql 连接插件，注意把 libpq 和  libmysql相关的库文件拷贝到可执行文件所在文件夹下，而不是 plugins 所在的文件夹，否则尽管可以枚举到驱动，但连接可能失败。如果引用了OCI的插件，注意不要拷贝oci.dll 到发布文件夹，在某些情形下，会导致连接失败。而是利用发布目的机器路径系统上的oracle 连接实例来获取依赖。
6、发布程序
     Qt5的plugins 文件夹中的内容，不要忘记一起发布。
总结：   经过测试, Qt4 到 5 的转换比 Qt3->4 要平滑很多，一般的项目均可以快速迁移。
-------------------------------
      顺便吐糟，编译Qt5对资源的消耗大大出乎意料，特别是那个 Webkit，Link时直接硬盘 100%狂闪，虚拟内存撑了N大，真是后悔内存没多买一条。内存碎片化估计也很严重，编译到outof mem后，重启系统接着来才成。在GCC下也是，Mac 没试过。
     以目前Qt代码量来看，再过几年没有4G的内存根本就没法编译。这样想来应该不止Qt，恐怕以后很多大一点的C++项目都是如此吧——雪球滚大了，不停的要兼容旧版、加入新功能，而且重构对很多项目来说是不可能的，只能越滚越大。




妖怪大战争

今年我做庄

//php学习笔记

php开发实战宝典：
1.php的运行在服务器端，在客户端看不到代码
2.术语：session，cookie

apache配置笔记：
1.xampp是一个shell，而服务器的运行是系统级别的，shell只负责检测和操作。
	实际上，xampp只检测它所绑定的apacheserver的端口（80），如果将自定义apache的listen设为82，则xampp检测不到。在这种情况下，两个sever可以同时运行
	
	补充一句，改为80不稳定
2.修改docroot之后，显示"Index of /"而不是直接打开index.htm文件，说明未支持htm文件.修改addtype之后需要重启服务器,同时要修改<IfModule dir_module>,额，，，极端情况下还要清一下缓存，比如把原来目录中的php移除

作如下约定：
xammp用于计算机，lab盘的apache2.2和php用于eclipse开发。于是将后者的文件目录迁移至L:\Code\eclipse\PHP

http://jingyan.baidu.com/article/c14654136589f40bfcfc4c9c.html XXXXX
http://linux.chinaunix.net/techdoc/net/2007/12/27/975288.shtml ok


//0903
1.在apcahe2.2中的vhost配置成功。apache已实现conf模块化管理。

2.关于403错误：http://www.cnblogs.com/qiantuwuliang/archive/2009/06/27/1512251.html
除了配置vhost，在httpd中也需要声明该目录的访问权限：
#vhost:127.0.0.1
<Directory "L:/Web/webpage">
    Options FollowSymLinks
    AllowOverride None
    Order allow,deny
    Allow from all
</Directory>

3.模块化的话，就好说了。自己在conf/ext中随便加一个外部文件，然后在httpd中声明调用它。
4.额，，，，没这么简单
5.tmd，放弃了！还是用xampp吧！
6.残留问题：localhost引导至documentroot（即L:\web\webpages）,而127.0.0.1引导至vhost(即L:\code\eclipse\PHP),他是怎么做到的？？？？？



//0902，重新安装apache和php
1.php5要求平台vc11，虽然下载了msvcr110.dll，但考虑到可能日后会安装vs12，为避免冲突，暂时放弃php5.5，采用php5.4.19
2.apache任然使用2.2版本

//java学习笔记
1.java数据结构部分注意vector与arrylist的区别：java具有天然的并行基因
2.java多线程开发注意线程池、syn、lock等概念并与Qt对比；事件委托模型与信号槽机制的对比
3.socket网络开发

//php开发笔记
1.网页文件根目录L:\Web，在此目录下开发新工程，并在eclipse调试目录中以“根目录+工程名”作为文件目录
2.apache2.2路径：L:\Programs\Apache2.2
3.php5.4.4路径：E:\Program Files\xampp\php
4.对php.ini进行配置，如resource limits

5.注意双引号和单引号的区别：双引号中的变量会被替换：定义字符串时尽量使用单引号，提高效率

//0801
java创建之初的考虑，就是一次编码、到处运行，是面向互联网的
java理念：java设计者耗费大量精力防止其他语言经常出现的典型问题。

java编程艺术阅读笔记：
1.一切都是对象 和 性能衡量 的平衡：保留八种简单数据类型（直接转换成二进制码）。同时包装之。
java精髓所在：以引用方式处理对象，以直接方式处理非对象。？？？？？
好处：便于垃圾处理，object；
2.java多线程支持，不依赖于操作系统，从而增强了可移植性。其核心是处理同步的方式：内置侦听器和内置通信方法。
3.内存管理、异常处理
4.通过interface关键字扩展了多态性
5.swing和awt的区别：
/*
	AWT 是Abstract Window ToolKit (抽象窗口工具包)的缩写，这个工具包提供了一套与本地图形界面进行交互的接口。AWT 中的图形函数与操作系统所提供的图形函数之间有着一一对应的关系，我们把它称为peers。 也就是说，当我们利用 AWT 来构件图形用户界面的时候，我们实际上是在利用操作系统所提供的图形库。由于不同操作系统的图形库所提供的功能是不一样的，在一个平台上存在的功能在另外一个平台上则可能不存在。为了实现Java语言所宣称的"一次编译，到处运行"的概念，AWT 不得不通过牺牲功能来实现其平台无关性，也就是说，AWT 所提供的图形功能是各种通用型操作系统所提供的图形功能的交集。由于AWT 是依靠本地方法来实现其功能的，我们通常把AWT控件称为重量级控件。 

	Swing 是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT 所能够提供的所有功能，并且用纯粹的Java代码对AWT 的功能进行了大幅度的扩充。例如说并不是所有的操作系统都提供了对树形控件的支持， Swing 利用了AWT 中所提供的基本作图方法对树形控件进行模拟。由于 Swing 控件是用100%的Java代码来实现的，因此在一个平台上设计的树形控件可以在其他平台上使用。由于在Swing 中没有使用本地方法来实现图形功能，我们通常把Swing控件称为轻量级控件。 

	AWT和Swing之间的基本区别：AWT 是基于本地方法的C/C++程序，其运行速度比较快；Swing是基于AWT 的Java程序，其运行速度比较慢。对于一个嵌入式应用来说，目标平台的硬件资源往往非常有限，而应用程序的运行速度又是项目中至关重要的因素。在这种矛盾的情况下，简单而高效的AWT 当然成了嵌入式Java的第一选择。而在普通的基于PC或者是工作站的标准Java应用中，硬件资源对应用程序所造成的限制往往不是项目中的关键因素，所以在标准版的Java中则提倡使用Swing， 也就是通过牺牲速度来实现应用程序的功能。 

	通俗的话: 

	AWT 是抽象窗口组件工具包，是 java 最早的用于编写图形节目应用程序的开发包。Swing 是为了解决 AWT 存在的问题而新开发的包，它以 AWT 为基础的。
	
	学swing 之前先学awt ,因为awt 是Java实现图形界面的基础。它能够完成编写界面的基本功能，最重要的是，事件的监听是由awt完成的。而swing是在awt基础上提供的新的界面工具包，它比awt运行速度快，界面也更加漂亮。 但是，事件的响应等工作还是要用awt来完成。学习awt,着重学习事件监听和响应。然后学习swing。
*/


6.applet的伟大：安全性和移植性。applet思想——>beans思想


//0803
逐渐熟悉eclipse编程环境：
1.区别局部变量和字段。如果要在一个对象中调用它的同级对象，则一个方法是将这个对象设置为final，或者直接将该对象提升为字段。
2.将缺省包（编程所在包）导出为.jar文件。eclipse的调试很方便，可以在一个项目中写几个测试文件（含有main入口）。
3.单步调试，在不用单步调试时，在“运行”中跳过所有断点。
4.在非GWT项目中插入GWT（环境：WindowBuilder（Google）），需要手动指定外部jar。

5.核心程序只负责抛出异常（异常的抛出可以个性化编写handleErr函数），而不负责解读异常，try_catch是调用函数（如main）的工作。

解释器与编译器，解释型语言:

//0803
linux内核设计的艺术 笔记
1.如果给你指导思想即“主奴机制”，让你去实现一个操作系统，你能吗？所以说，和硬件打交道，占了一半天下。
最主要的还是对内存的访问控制。
2.bois加载内核，对内存利用的极致！
3.head程序自己将自己废弃，实现分页机制
4.一切准备工作的核心目的就是：让用户程序以能进程的方式正常运行。1,运算（进程0）；2，与外设交互（进程1）；3，人机交互（进程2：完善进程1）
5.
6.
7.



//0803，Android
/*
今天为了看知乎日报（没有网页版），于是在windows下装了一个安卓虚拟机（实际上是一个模拟器，官方发布的sdk自带，用于程序调试）。正好我的eclipse没有装android环境，顺便得了一个环境，便于以后开发。

与上述linux系统交叉的一个关键问题是，文件系统的挂载问题。在安卓模拟器中需要挂载sdcard文件系统的镜像文件。

奇怪的是，我将文件夹中的eclipse工具转出来后，其设置能够与原文件夹同步。这说明两者在公用一个配置文件，可能在docu&sett文件夹中C:\Documents and Settings\Administrator\.android。

.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

我活了二十多年,这个是我见过最无聊的。。。。。。

0.颜色配置：
基本文件 30.epf
修改：关键字用八成深蓝，取消粗体；类统一用品红；数字用明黄；常量用深黄；字符串用草绿；方法用粉红，静态方法调用用灰蓝；注释用灰；return用草兰加粗体；另外修改垂直标尺栏显示错误和警告，在文本处用波浪线标出。
另外：1855.epf在修改背景色和行高亮色之后也不赖！
*/



//0805，PHP by Dw
PHP+5+项目开发实战详解-留言板详细实例 笔记
1.下载了mySQL官方GUI工具，安装在xammp的mysql路径下。至此，已经有两个sql可视化操作工具了（另一个是navicat）。用前者新建了一个连接“withadmintool”，root@localhost:3306，密码abc*
2.zen coding！ Dw就是tmd垃圾！
3.今天决定彻底放弃Dw，改在eclipse上开发web项目。首先安装web+Java EE等一系列组件。为了方便调试 ，下载apache的轻量级服务器tomcat 6.0。
4.建立 dynamic web project
5.
//0805,a C++ project with Eclipse
1.交叉编译：对应于主机编译
“在项目的起始阶段，目的平台尚未建立，因此需要做交叉编译，以生成我们所需要的bootloader（启动引导代码）以及操作系统核心；其次，当目的平台能启动之后，由于目的平台上资源的限制，当我们编译大型程序时，依然可能需要用到交叉编译。”
2.
3.

/*环境变量

今晚修复了一个大BUG！用了这么多年，竟然才发现环境变量中设置的默认编译环境是VC98!今天终于改到VC100中了！克服了一个错误，即使用VC100的link.exe时提示缺失mspdb100.dll，原因是没有设置成功Visual Studio 2010的环境变量。通过运行batch文件vcvars32.bat，设置之后还要手动添加path变量 。
用新工具，就是爽！

windows的Path变量应该如何管理？今天的想法是，为了稳定和助记，将常用的、重要的路径都单独设置为变量，然后在Path中引用。如VC100,MINGW32,MINGW64.在用eclipse写c++ proj时，出现了一个问题，即使用了变量中设置的mingw64。但第一个helloworld型proj（指定为mingw  gcc）所include的是c:\mingw，即32位版。不明所以。

拎一个问题是，std不能解析问题。原以为是include有问题，后来发现，只要保存文件之后就不再提示错误了。这是编译方式问题。不如java时时编译（？）提示方便。

launching file.exe has encounterd a problem。原因：gdb未安装或版本与mingw不符。（啥事gdb？）



//环境配置
1.eclipse3.7：java(WindowBuilder);PHP;Web;
1.eclipse4.2：c/c++;android;
1.eclipse4.3：c/c++;javaEE;javascript;PHP;server;Web;web;plug-in development;
配置任务：
1.mingw升级
2.avd产生

*/


/*java 自学笔记

//0804,java编程艺术
创建一个下载管理器：java swing
1.http1.0不可续传
2.download类：负责一个下载任务。由于多任务的要求，download类需要实现runnable接口
3.url.openConnection（）方法并不创建到url所指服务器的连接，而是只创建一个相关的URLConnection实例，并由此实例完成后续的属性设置和连接工作
4.连接工作之前要设置请求属性；连接通过connect()方法完成；之后需要检查响应；连接成功后获取下载内容信息。
5.断点续传的两个重要设置就是Range参数和RandomFile的seek方法。
6.finally语句：在其他return之前。如果finally中有return，则该return先执行，其余return被忽略。
7.WindowBuilder很强大，代码parser能力很强，可以直接由代码产生design视图
8.

//0806,emailer
1.Internet的两大用途？Web和Email？
2.自制的简易email可以更好地实现安全性。对email实施全面的控制
3.“从零开始写与Email服务器通信的程序是相当复杂的，没人会这么做”，java提供了Email库：javaMail
引入外部库的方法：项目属性->构建路径->库
4.“java里面有一个金科玉律：任何public非static函数的调用都是多态的。”？？http://zhidao.baidu.com/question/14360400.html
5.RMI机制：RPC的java版本。原理：“典型的服务器应用程序将创建多个远程对象，使这些远程对象能够被引用，然后等待客户机调用这些远程对象的方法。”RMI使用标准机制：stub和skeleton。（占位程序stub：远端客户的本地代理人）



今天百度，从Android虚拟机开始，到Android x86，然后了解ARM架构的发展史。
未解决问题：什么虚拟机软件可以安装arm架构的android？


//0806,Windows环境下的32位汇编语言程序设计——笔记
1.不同的汇编标准，大方向上有x86系统基于的cisc指令集和arm所依赖的risc指令集。后者有一个GNU工具。
还分为：微软的MASM汇编器和Borland的TASM汇编器，以及NASM（开放源代码）。MASM的向后兼容不好。
本机默认为VS100所带的Microsoft Macro Assembler，版本10.00
所装环境为masm32：Microsoft Macro Assembler，版本6.14；masm64：Microsoft Macro Assembler<x64>,版本8.00
MASM到5.0以后才完全支持80386指令
MASM32又™是什么？目标是为了让汇编能干大事！发布者Steve Hutchesson,而非微软官方。
2.创建资源.rc->.res.资源编译生成的文件格式在C和汇编中是通用的。所以一般资源脚本文件采用c语言格式

3.makefile语法：支持宏定义，很方便重用
4.获取资料
5.win32汇编和dos汇编还是有很大区别的。出发点就不一样。
6.win32中其实只有数据和代码之分。与dos不同，win32不必考虑堆栈，所以.stack段常常被忽略
.data段与.data?段在内存耗用上的区别
代码段的非可写权限（优先级3）



个人对环境配置格外感兴趣。遇到一个问题，在打开masm工具时调用cdm，能够修改成console字体，而关闭该工具之后就不能了。不知为何。
Lucida Console
Bitstream Vera Sans Mono
今天在VS中配置的masm终于成功了。1.要修改文件属性；2.修改生成自定义；3，修改项目属性（包括Microsoft Macro Assembler （微软宏汇编）的包含路径和子系统设置）
（注：其实对于masm32我们只需要它的头文件，其他的汇编编译器 ml.exe, 链接器 link.exe, 资源编译器 rc.exe 等， VS2010都自带的有)
修改vs的颜色设置：vassistx与asmhighter冲突。在从一个切换到另一个时，记得删除颜色缓存HKEY_CURRENT_USER\Software\Microsoft\VisualStudio\10.0\FontAndColors\Cache
节区。。。。
不要说你对windows系统了解，起码你对注册表还一无所知；
不要说你对体系了解，你连.exe的结构和原理还不知道


//0807
今天读F:\清华2013夏(大二)\JAVA\DEMO\236873JAVA项目开发实践\JAVA项目开发实践\chapter3中的聊天程序遇到的问题，笔记
1.通过读代码学java的效率还是很高的
2.RMI机制
3.chatter，chatclient，与chatserver三者怎么相互联系，工程的结构怎样的？
4.问题有：
package chatclient； //此时，将源程序放入一个新建package中
import chat.Chatter; //如果要包含的话，需不需要先编译？不用，只需要有这个包（目录）就可以
//总之，这跟c语言中的include头文件还是有些类似的
包：包即是将一些类聚集在一起的一个实体。有点类似namespace。这就引出了类的公有和私有问题

5.如何用makefile写！！！！
6.在连接iamges时出现“找不到源”错误，改成绝对路径也不行。。。
并且默认的根路径指的是workspace的路径，即L:\code\eclipse
好吧，是我先入为主了，问题并不出在路径上，而是使用的imageicon类“找不到源”
最终解决方案：当前类文件和图片在同一路径下即可
相对路径为什么不对？
卧槽，知道了。。images应该放在src下，否则必须用../../images/send.gif。。。。不过还是不对
7.什么是ant编译？http://blog.csdn.net/witsmakemen/article/details/7929761  类比makefile
8.yahoo！大体明白了公共jre和专用jre的区别。在eclipse中添加专用jre，并将此设置为默认，然后就不会出现找不到源的情况啦！因为源就在C:\Program Files (x86)\Java\jdk1.7.0\src.zip;
并且可以、查看源代码啦！！！！！



插播：
实践
http://blog.sina.com.cn/s/blog_5198c7370100eabg.html，RMIhttp://stevencjh.blog.163.com/blog/static/1218614612010102145853184/
以经典的 Hello world作为例子讲解。开发rmi的步骤如下。
1、编写远程接口，远程接口实现类
2、编译
3、生成接口实现类存根
4、在服务器端启动rmiregistry命令
5、在服务端注册发布远程对象
6、在客户端获取远程对象
	一、编写类	
	二、编译（注意以上类都没有包，这里主要是简化操作考虑）
	客户端文件夹在 E:/client(简称client),服务端在E:/server（简称server）
	分别编译以上4个文件。然后将Hello.class分别放到client和server下，将Client.class放到client下，Server.class放到server下，HelloImpl.class文件放到server文件夹下
	三、生成存根和骨架
	进入server文件夹在命令行下输入命令 rmic HelloImpl，将生成一个HelloImpl_Stub.class文件
	将此文件复制到client目录下（server与client均该文件）
关于编译源：http://blog.csdn.net/happytengfei/article/details/8676719
	dt.jar和tools.jar位于：{Java_Home}/lib/下，而rt.jar位于：{Java_Home}/jre/lib/下,其中：rt.jar是JAVA基础类库，也就是你在java doc里面看到的所有的类的class文件dt.jar是关于运行环境的类库tools.jar是工具类库,编译和运行需要的都是toos.jar里面的类分别是sun.tools.java.*; sun.tols.javac.*;
	
	1. rt.jar 默认就在 根classloader的加载路径里面 放在claspath是多此一举不信你可以去掉classpath里面的rt.jar 然后用 java -verbose XXXX 的方式运行一个简单的类 就知道 JVM的系统根Loader的路径里面不光rt.jar jre\lib下面的大部分jar 都在这个路径里 
	2. tools.jar 是系统用来编译一个类的时候用到的 也就是javac的时候用到 javac XXX.java 实际上就是运行 java -Calsspath=%JAVA_HOME%\lib\tools.jar xx.xxx.Main XXX.java javac就是对上面命令的封装 所以tools.jar 也不用加到classpath里面
	3. dt.jar是关于运行环境的类库,主要是swing的包 你要用到swing时最好加上
	注： 1）在编译时java使用的是JDK中的JRE中的JAR。 C:\Java\jdk1.5.0_06\jre\lib 2）采用java运行时，也用到是JDK中的JRE，因此测式发现在把rt.jar文件删除都会出错， ...

问题：java.lang.ClassNotFoundException: java.rmi.server.UnicastRemoteObject not found
原因：CLASSPATH设置中未添加java的相关lib

“从JDK5.0以后，这两个类就不需要rmic来产生了，而是有JVM自动处理，实际上他们还是存在的。”http://stevencjh.blog.163.com/blog/static/1218614612010102145853184/
http://gyabooks.iteye.com/blog/1049815
使用Eclipse编写Java RMI程序http://usiboy.iteye.com/blog/557436
非得逼我下个rmi插件
未解决



//0809
java网络编程《Java网络编程精解.pdf》笔记
1.网络基础：
	对应OSI模型，划分TCP/IP的四层模型
	“IP网址”是网络掩码与IP的与运算。子网划分：设置子网掩码。
	IP是面向包的协议，IP网络主机只能向本地网上的其他主机发送包。ARP地址解析协议，广播-反馈方式（反馈物理地址）。对于非本网传输，ARP返回路由器地址。
	TCP协议：建立在IP协议之上，属于进程层次。该协议推动了C/S模型的发展。java网络程序都采用这种模式
	区别应用层的协议和传输层协议：应用层协议如http，smtp，pop3，等
	传输层向应用层提供了Socket套接字 接口！
2.卧槽！这本书花了三章就只讲了一个socket！注意，getInputStream和getOutputStream表明，java是基于对象引用来工作的。注意字节数组和字符串的转换。socket具有半关闭方法。
3.第四章才是干货！非阻塞通信：“服务器程序只需要创建一个线程，就能完成同时与多个用户通信的任务”。
	非阻塞通信机制从JDK1.4开始，主要由java.nio包中的类实现（“为所有的原始类型提供(Buffer)缓存支持。字符集编码解码解决方案。 Channel ：一个新的原始I/O 抽象。 支持锁和内存映射文件的文件访问接口。 提供多路(non-bloking) 非阻塞式的高伸缩性网络I/O ”）
4.通过分时，用串行实现多任务，提高cpu的利用率。也就是所谓的“轮询”
5.SelectableChannel类及其子类都能委托Selector监控它们可能发生的一些事件爱你，这种委托过程又叫“注册事件”过程
6.回顾java中的“事件_监听器”类模型：事件类继承自EventObject，它的调用会触发对应的监听器。注意，监听器是注册在目标类上的（不是事件类），目标类的事件触发该类的监听器列表。
参考文件："java监听器.java"
7.问题：“
	RT为什么使用接口的时候，要在实现接口的类中实现接口中所有的抽象方法？想偷懒的话还要使用适配器，多麻烦呀！java语言为什么要这么规定呀！假如可以不实现所有的抽象方法的话，也就不用引入适配器这个概念了，这样不更好吗？”
  回答：标准化，松耦合。
8.简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式。
例如ByteBuffer类，不提供公开构造方法，只能通过调用allocate方法生成对象。（问题是：它的代码是怎么实现的？？）简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。工厂（creator）负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。
9.MappedByteBuffer用于文件操作，提升程序性能。通过将文件映射到虚拟内存。
10.Buffer&Channel！数据源->通道缓冲区->数据汇，操作对象都是缓冲区
11.为什么要用非阻塞模式？“非阻塞套接字在控制建立的多个连接，在数据的收发量不均，时间不定时，明显具有优势”。
12.通过channel，我们看到了缓冲区的魅力！
13.事件注册：目标类A作为注册的主体，监听器B作为参数（对象）；由目标类的事件C触发，由目标类注册的监听器处理和反馈。称作“A向B注册C事件”。
从这个角度看，侦听器是一种插件
14.SocketChannel，作为Socket的替代类
15.用SocketChannel的read方法可以读取一行字符串，它的作用与BufferedReader的readLine方法等价，比较麻烦，需要操纵ByteBuffer缓冲区，而且要处理字节流和字符串的转换。
相比之下，BufferedReader用输入输出流来处理就简单多了。
--//0815
16.http://weixiaolu.iteye.com/blog/1479656“服务端和客户端各自维护一个管理通道的对象，我们称之为selector，该对象能检测一个或多个通道 (channel) 上的事件。我们以服务端为例，如果服务端的selector上注册了读事件，某时刻客户端给服务端发送了一些数据，阻塞I/O这时会调用read()方法阻塞地读取数据，而NIO的服务端会在selector中添加一个读事件。服务端的处理线程会轮询地访问selector，如果访问selector时发现有感兴趣的事件到达，则处理这些事件。”
17.下载了《Java NIO》一书，作为参考资料。关于selector，注意：1.selectKey作为代理，是我们操作的对象。它提供chanel和其注册的selector信息。2.server一开始selector注册类型为accept，而client注册类型为connect。一旦连接成功，在进行read和write的注册。3.server方启动client的channel的非阻塞模式。
18.编解码问题：在send方法中，当通过SocketChannel的write（ByteBuffer buffer）方法发送数据时，不能直接发送字符串，而只能发送Bytebuffer中的字节。因此需要对字符串进行编码以转化成字节序列。charset的encode(String)方法实现。同时，charset的decode(ByteBuffer)方法负责解码。
19.cahp5 ：http服务器
20.ByteBuffer的三个属性：position，limit，capacity
//0818,RMI模型
21.
22.
23.
24.
25.
26.
27.

*/

//0829,2014

/*java 课程笔记

//2013-08-12 java编程语言 课程笔记
1.找不到类库了！！！！！！
2.java编码规范
	1.包名	全小写
	2.类名、接口名	首字母大写，单词首字母大写
	3.方法、变量首	字母小写，单词首字母大写，方法动词，变量名词
	4.常量名	全大写
3.java中引用的概念和实现
http://blog.csdn.net/b271737818/article/details/3943809
--//0816
4.第三讲：java面向对象编程
5.有没有私有(private)类？没有。[public] [abstract|final] class
6.类java.lang.Object。关于hashcode
7.类体：成员变量
8.声明时并不分配内存空间，只分配引用空间。关于引用：32位值。对象的引用指向一个中间数据结构
9.tx =new Point().x	注意：(自注)一个对象的成员存在引用，那么可以说这个对象还存在引用。
10.注意：private的权限是类级别的！！！default：同一个包。介于private和protected之间；protected：不同包中的子类；
11.方法重写的原则：(1)权限不缩小(2)异常不扩大。final：类不能继承，方法和变量禁止重写

不能降低可视性，因为外界访问的是abtract


http://hi.baidu.com/jayjaymi/item/be6ac33d48e7ed48033edcd4
关于“子类不能重写父类的private方法”，试了一下，语法上并不禁止，可以使用。“private是私有的，其他类是不能访问的，子类也不可以访问，所以你可以重新实现父类的该方法，不会有冲突，但是你重新实现的方法，不叫重写也不叫重载，是一个该子类新增的方法，和子类的一般扩展方法一样”
JAVA静态方法形式上可以重写，但从本质上来说不是JAVA的重写。因为静态方法只与类相关，不与具体实现相关。

对于“权限不缩小”，特别的，若父类方法的访问权限是public，则子类方法的访问权限只能是public。

重写的方法要和被重写的方法的方法名称、参数列表、返回类型都要一样。（返回类型可以是父类型的子类型）

12.static：类成员和类方法。所有类对象共享。单一内存。在对象声明之前已经建立。
原则：类方法不能使用实例变量而只能使用类变量。也不能使用this和super（这两个可以看做实例变量）
13.inner class：
地位同成员变量。内部类能够访问外部内的一切成员变量和方法，包括私有的，而实现接口或继承类做不到。http://blog.csdn.net/cntanghai/article/details/6094481

内部类对象可以访问创建它的对象的实现，包括私有数据；
内部类不为同一包的其他类所见，具有很好的封装性；
使用内部类可以很方便的编写事件驱动程序；
匿名内部类可以方便的定义运行时回调；

内部类是定义在其他类内部的类。
它几乎可以处于类内部任何位置，可以与实例变量处于同一级，或处于方法之内，甚至是一个表达式的一部分！内部类是JAVA语言的主要附加部分。

Learning JSP+Struts+HIbernate+Spring

关于final与static：
private static final String string;
final的意思是这个string不能再被改变。
static的意思是这个string在类被加载的时候就加载了。

（final其实是和abstract对应的，static是和实例变量（或实例方法）对应的）

14.abstract class：抽象方法也要加abstract修饰
15.接口：只有常量，没有变量
16.java的char是Unicode（UCS-2）编码，所以是双字节的，C++中的wchar_t类似于此。C++里的char是指ASCII编码的字符，就只有一个字节.
17.自动类型转换：从低级到高级；高级到低级的转换需要强制类型转换
奇怪的是，字符向int转换时用的是ascii码（无论是常值还是char变量，如(c=)‘a’都变成97）；
同时，int向char的强制转换也是用ascii码！
18.short s =10;s =(short)s*s------注意：相乘之后变成int
19.区分重载和重写！！！
静态多态性（编译时多态〕：由方法重载实现
动态多态性（运行时多态）：由方法重写实现

20.再看inner：
对于嵌套的类，如果要对外部其他类可见，需要import；
class Outer2 {
	Inner ins =new Outer().new Inner();
	public void outerprint() {
		this.ins.doStuff();
		this.ins.print();
	}
}

世界真奇妙！
世界真奇妙！
世界真奇妙！
21.接口的常量缺省具有public，final，static属性

22.正则表达式：，这个“规则字符串”用来表达，对字符串的一种过滤逻辑
[a-z]+   ：one or more
[a-zA-Z0-9]
[A-Za-z]+ [0-9] will match one or more letters immediately followed by one digit
abc|xyz will match either abc or xyz

/////////////////////////字符匹配：
. 一个点表示任意字符，除了换行符
\d 一个数字: [0-9]
\D 一个非数字: [^0-9]
\s 任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等: [ \t\n\x0B\f\r]
\S 非空白符: [^\s]
\w 用于单词的字符，例如字母或数字或下划线或汉字等: [a-zA-Z_0-9]
\W 不是用于单词的字符，与\w相反: [^\w]

/////////////////////////字符串匹配：
^ 字符串的开始
$ 字符串的结束
\b 单词的开头或者结尾
\B 不是单词的开头或者结尾
\A the beginning of the input (can be multiple lines)
\Z the end of the input except for the final terminator, if any
\z the end of the input
\G the end of the previous match

接口可以多继承
问：
22.1.\b和\W等价吗？
"//w+"的意思是"一个或多个单词字符"，因此它会将字符串直接分解成单词。find( )像一个迭代器，从头到尾扫描一遍字符串。

22.2.“现在，我们怎样来检查一个给定的单词是否被重复了三次。为完成这个任务，需充分利用正则表达式中的所熟知的向后扫描”
Pattern pattern =Pattern.compile("//b(//w+)//s+//1//b");
Pattern.CASE_INSENSITIVE);

22.3.匹配原理
http://su1216.iteye.com/blog/1611655 自动机

22.4.要区分find(),lookingAt(),match()的层次
区分start(),end()的含义（是指匹配的串的起始，而不是匹配的起始）
/////////////////////////重复数量：

*  重复零次或者更多次 >=0
+  重复一次或者更多次 >=1
？ 重复零次或者一次 0/1
{n}  重复n次
{n,}  重复n次或者更多次
{n,m} 重复n到m次

分组：用小括号来指定子表达式(也叫做分组)，然
后指定这个子表达式的重复次数

22.5.感觉^$是一个很强的控制

22.6.split和replace是难点
http://blog.csdn.net/allwefantasy/article/details/3136570

appendReplacement(StringBuffer sbuf, String replacement)对sbuf进行逐次替换，而不是像replaceFirst( )或replaceAll( )那样，只替换第一个或全部子串。这是个非常重要的方法，因为它可以调用方法来生成replacement(replaceFirst( )和replaceAll( )只允许用固定的字符串来充当replacement)。

"\\b(([A-Za-z]+)(-([A-Za-z]+))?)('([A-Za-z]+)(-([A-Za-z]+))?)?\\b"

/////////////////////////
23.Notes:
构建
– Neither Pattern nor Matcher has a public constructor;
• use static Pattern.compile(String regExpr) for creating pattern instances
• using Pattern.matcher(String text) for creating instances of matchers. 
– The matcher contains information about both the pattern and the 
target text.

24.m.find() returns 
– true iff the pattern matches any part of the text string,
– If called again, m.find() will start searching from where the last match 
was found
– m.find() will return true for as many matches as there are in the 
string; after that, it will return false
– When m.find() returns false, matcher m will be reset to the 
beginning of the text string (and may be used again).

“The game is over".substring(m.start(), m.end()) ：return exactly the matched substring.

25.集合collection
三个层次：
collection
set
list
几个重要的类：
ArryList,Vector,HashSet,TreeSet

26.映射Map
先获取Key的一个Set，然后用反复器访问
Set取出Key，再用Key去得到Value，这是访
问Map的所有元素的一种方法。
键允许为null，值也允许为null

26a.排序

27.泛型： Collection<Object>不是所有Collection的父类，应该使用泛型通配符void printCollection(Collection<?> c)
又如：public void drawAll(List<? extends Shape>s)

? 表示未知类型，不是任何一个确定的类型 ，不要尝试使用该类型对象的方法。应该用类型参数来定义泛型方法，在方法调用发生时编译器匹配具体类
static <T> void aToC(T[] a, Collection<T> c) {
for (T o : a)
c.add(o); 不会产生编译错误 
}

---//0821,异常机制
28.异常的捕获catch的安排：尽量将子类放在前面
区分主动异常和被动异常（运行时）
29.字节流和字符流的区别
http://blog.csdn.net/cynhafa/article/details/6882061 
是否使用缓冲区

http://www.cnblogs.com/oubo/archive/2012/01/06/2394638.html 
读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。
处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。
结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。

30.感受一下：设备亦文件！
31.补充：为什么需要iterator？
在前一种情况，容器承受了过多的功能，它不仅要负责自己“容器”内的元素维护（添加、删除等等），而且还要提供遍历自身的接口；而且由于遍历状态保存的问题，不能对同一个容器对象同时进行多个遍历。第二种方式倒是省事，却又将容器的内部细节暴露无遗。

32.理解“修饰”的概念！例如，PushbackInputStream类继承了FilterInputStream类是InputStream类的修饰者
 public PushbackInputStream(InputStream in, int size) ;in为被修饰的输入流。size为推回缓冲区的大小。默认缓冲区大小为1字节
33.对象的流，需要用到对象序列化Serialization

34.iterator是内嵌类！！！区分哪些操作是抽象类完成的，哪些是借助iterator完成的
http://tech.ccidnet.com/art/3737/20031024/472351_1.html 尤其是remove和add的一步一步的具体化

public abstract class AbstractCollection<E> implements Collection<E>
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E>
	private class Itr implements Iterator<E>
		 AbstractList.this.remove(lastRet);	//注意什么是this。同时注意，这里的remove是重载的，而不是AbstractCollection中的remove。public E remove(int index)
可以看到，Itr类中调用了大量AbstractList中的方法，例如get(int)、remove(int)等，但是这些方法要么是抽象的，要么只有一句：throw new UnsupportedOperationException(); 这样AbstractList的子类如果实现了这些方法，那么它们继承的iterator()也就有用了。如果不允许实现get(int)，remove(int)，那么iterator()也将被禁止。

35.接口继承接口可以不重写
36.在写第三题时遇到一个问题，关于抽象类的非抽象方法。为什么会有非抽象方法呢？独立于子类的，在抽象类层次统一的方法。尽管该方法也可以重写。
37.从comparable看声明与实例化的区别
38.堆排序和构建一棵搜索树，两者是什么关系？这和选择排序又是什么关系？和快排呢？
39.第四次作业
第一题
http://learn.tsinghua.edu.cn/learn/search_course.jsp
http://blog.csdn.net/zhuche110/article/details/2230997

//lesson 5
//0825,homework5
40.异常
"java.io.IOException must be caught, or it must be declared in the throws clause of this method."两种选择：在当前函数包含的块添加try-catch，或者在函数声明要向外抛出。要么自己解决，要么请人解决，不能不解决。能自己解决尽量自己解决
41.在Java程序的执行过程中，如果出现了异常事件，就会生成一个异常对象。生成的异常对象将传递给Java运行时系统，这一异常的产生和提交过程称为抛出。
42.当Java运行时系统得到一个异常对象时，它将会寻找处理这一异常的代码。找到能够处理这种类型的异常的方法后，运行时系统把当前异常对象交给这个方法进行处理，这一过程称为捕获catch。如果Java运行时系统找不到可以捕获异常的方法，则运行时系统将终止，相应的Java程序也将退出。
43.
异常类型：
error：通常Java程序不应该捕获这类异常，也不会抛出这种异常
运行时异常：继承于RuntimeException。Java编译器允许程序不对它们做出处理
非运行时异常：除了运行时异常之外的其他由Exception继承来的异常类。Java编译器要求程序必须捕获或者声明抛出这种异常
44.
捕获异常的顺序和不同catch语句的顺序有关,当捕获到一个异常时,剩下的catch语句就不再进行匹配。因此，在安排catch语句的顺序时，首先应该捕获最特殊的异常，然后再逐渐一般化。也就是一般先安排子类，再安排父类。
45.
捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。不论在try代码块中是否发生了异常事件，finally块中的语句都会被执行
46.
如果在一个方法中生成了一个异常，但是这一方法并不确切地知道该如何对这一异常事件进行处理，这时，一个方法就应该声明抛出异常，使得异常对象可以从调用栈向后传播，直到有合适的方法捕获它为止。“如果采用消极处理方式,则由调用该方法的方法进行处理;但是调用该方法的方法也可以采用消极和积极两种处理方式,一直传递到Java运行环境.”

//IO
47.字节流：Byte；字符流：2Byte(java字符是双字节，即unicode)
48.RandomAccessFile竟然会是不属于InputStream和OutputStream类系的。实际上，除了实现DataInput和DataOutput接口之外(DataInputStream和DataOutputStream也实现了这两个接口)，它和这两个类系毫不相干，甚至都没有用InputStream和OutputStream已经准备好的功能；它是一个完全独立的类，所有方法(绝大多数都只属于它自己)都是从零开始写的。这可能是因为RandomAccessFile能在文件里面前后移动，所以它的行为与其它的I/O类有些根本性的不同。总而言之，它是一个直接继承Object的，独立的类。

基本上，RandomAccessFile的工作方式是，把DataInputStream和DataOutputStream粘起来，再加上它自己的一些方法，比如定位用的getFilePointer( )，在文件里移动用的seek( )，以及判断文件大小的length( )。此外，它的构造函数还要一个表示以只读方式("r")，还是以读写方式("rw")打开文件的参数 (和C的fopen( )一模一样)。它不支持只写文件，从这一点上看，假如RandomAccessFile继承了DataInputStream，它也许会干得更好。只有RandomAccessFile才有seek方法，而这个方法也只适用于文件。BufferedInputStream有一个mark( )方法，你可以用它来设定标记(把结果保存在一个内部变量里)，然后再调用reset( )返回这个位置，但是它的功能太弱了，而且也不怎么实用。RandomAccessFile的绝大多数功能，如果不是全部的话，已经被JDK1.4的nio的"内存映射文件(memory-mapped files)"给取代了。
49.节点流指的是与存储介质直接连接的流，例如FileInputStream,StringReader等
--节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader  
--处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接.


http://wenku.baidu.com/view/90cda10203d8ce2f00662341.html
常用的节点流  
父 类 InputStream OutputStream Reader Writer  
文 件 *FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流 数 组 *ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组） 
字符串 *无  无 StringReader StringWriter 对字符串进行处理的节点流  
管 道 *PipedInputStream PipedOutputStream PipedReader PipedWriter 对管道进行处理的节点流 
 
常用处理流(也叫过滤流、修饰流)（关闭处理流使用关闭里面的节点流）  
父 类 InputStream OutputStream Reader Writer  
缓冲流 *BufferedImputStrean BufferedOutputStream BufferedReader BufferedWriter ----需要父类作为参数构造，增加缓冲功能，避免频繁读写硬盘，可以初始化缓冲数据的大小，由于带了缓冲功能，所以就写数据的时候需要使用flush方法咯  
转换流 *InputStreamReader OutputStreamWriter- 要inputStream或OutputStream作为参数，实现从字节流到字符流的转换  
数据流 *DataInputStream DataOutputStream -提供将基础数据类型写入到文件中，或者读取出来
过滤流  在读/写数据的同时可以对数据进行处理，它提供了同步机制，使得某一时刻只有一个线程可以访问一个I/O流，以防止多个线程同时对一个I/O流进行操作所带来的意想不到的结果。
• 类FilterInputStream和FilterOutputStream分别作为所有过滤输入流和输出流的父类


50.
顺便研究序列化---将对象所在的类型全部转换成二进制，然后写入到介质中去
*transient关键字--修饰成员变量，不写入该成员变量     
*Serializable接口--表示接口，怎样实现的呢，在序列化之前，首先判断 （对象 instanceof Serializable）如果返回true则执行序列化，否者抛出异常，并且里面有一个ID，是用来快速查找某个对象的时候使用
*Externalizable接口--外部化接口；他是Serializable接口的子接口，能手动控制序列化的方式

51.writer： flush( )刷空输出流，并输出所有被缓存的字

InputStreamReader和OutputStreamWriter：java.io包中用于处理字符流的最基本的类用来在字节流和字符流之间作为中介

BufferedReader和BufferedWriter：读入/写出字符除了Reader和Writer中提供的基本的读写方法外，增加对整行字符的处理

标准格式:
文件输入：
	String s;
	FileInputStream is;
	InputStreamReader ir;
	BufferedReader in;
	
	is=new FileInputStream(“test.txt”);
	ir=new InputStreamReader(is);//可对字符输入设置编码
	in=new BufferedReader(ir);
	
	while((s=in.readLine())!=null)
		system.out.println("Read: "+s);
		
	///////////////////////////////////////////
标准输入:
	InputStreamReader ir;
	BufferedReader in;
	
	ir=new InputStreamReader(System.in);
	in=new BufferedReader(ir);
	String s=in.readLine();
	System.out.println("Input value is: "+s);

文件输出：
String data ="你好,Android.2011";
 
File newFile = new File("Text.txt");
FileWriter write = new FileWriter(newFile,true);
BufferedWriter bufferedWriter = new BufferedWriter(write);

bufferedWriter.write(data);
bufferedWriter.newLine();//换行

bufferedWriter.flush();
write.close();
bufferedWriter.close();
刷新该流的缓冲。 

* 关键的一行代码。如果没有加这行代码。数据只是保存在缓冲区中。没有写进文件。

 * 加了这行才能将数据写入目的地。



52.Serialization
只有实现了Serializable的类的对象才可以被串行化。
ObjectInputStream和ObjectOutputStream将数据流功能扩展至可读写对象。在ObjectInputStream中用readObject()方法可以直接读取一个对象，ObjectOutputStream中用writeObject()方法可以直接将对象保存到输出流中。

串行化只能保存对象的非静态成员变量，不能保存任何的成员方法和静态的成员变量，而且串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存。
//0826，线程与网络

53.理解一下sleep：是cpu资源的转换，而不是空转。成为线程放弃cpu，进入阻塞
54.多线程冲突：1.原子操作被打断---通过引入互斥锁保证线程操作的完整性
55.
每个进程都有独立的代码和数据空间.线程：轻量的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC).

那么，java的多线程原理是什么呢？




http://publish.it168.com/2005/0820/20050820006501.shtml
56.在Java中想实现多线程有两种手段，一种是集成Thread类，另一种就是实现Runnable接口。
57.我们不能直接调用run()函数，而是通过调用start()函数来调用run()函数。在调用start()的时候，start()函数会首先进行与多线程相关的初始化
58.垃圾回收机制对Thread对象“不成立”。因为每一个Thread都会进行注册动作，所以即使我们在产生Thread对象时没有指定一个reference指向这个对象，实际上也会在某个地方有个指向该对象的reference
59.每个对象都有一个标志锁。当对象的一个线程访问了对象的某个synchronized数据（包括函数）时，这个对象就将被“上锁”，所以被声明为synchronized的数据（包括函数）都不能被调用（因为当前线程取走了对象的“锁标志”）。只有当前线程访问完它要访问的synchronized数据，释放“锁标志”后，同一个对象的其它线程才能访问synchronized数据。每个class也有一个“锁标志”。对于synchronized static数据（包括函数）可以在整个class下进行锁定，避免static数据的同时访问。
60.线程的概念模型
• 虚拟的CPU，封装在java.lang.Thread类中。
• CPU所执行的代码，传递给Thread类。
• CPU所处理的数据，传递给Thread

在java中多线程的实现是依靠同步机制来实现的。而同步机制的实现原理是什么呢？
在java中每一个对象都有一个对应的所对象和一个集合对象与之关联，当我们在对内存中创建一个对象实际上在虚拟机中创建了3个对象。当使用synchronized关键字的时候，其他对象首先会去找你想访问对象关联的那个所对象，如果这个所对象没有被别的对象使用，那么就使用此对象，并将所对象的状态改变，当有第二个对象想使用此对象的时候，也是去查找关联的所对象，当发现锁的状态为不可用，那么就会在关联的集合中存放起来。来一个，集合中就存放一个。当第一个对象使用完毕，就将锁设置为可用状态，在关联的集合中的对象就有可能被唤醒，争抢CPU的执行权。

Java调度器的任务是使优先级高的线程能始终运行，一旦时间片有空闲，则使具有同等优先级的线程以轮流的方式顺序使用时间片。只有当高级别的线程死亡时(除非用sleep(int millsecond)或wait()方法让出CPU资源)，低级别线程才有机会获得CPU资源。

遍寻原理不得，还是英文论坛靠谱啊：http://www.javamex.com/tutorials/threads/how_threads_work.shtml
61.
“注意：并不是在所有系统中运行Java程序时都采用时间片策略调度线程，所以一个线程在空闲时应该主动放弃CPU，以使其他同优先级（调用yield( )方法）和低优先级（调用sleep( )方法)的线程得到执行”

言下之意就是，有的系统会采用时间片策略调度，从而弱化线程优先级的权限。
比如示例程序：<name ,Priority>
T1 1
T1 1
T1 1
T3 5
T4 10
T2 10
T4 10
T3 5
T6 10
T7 10
T5 10
T5 10
T5 10
T7 10
T6 10
T6 10
T3 5
T4 10
T2 10
T7 10
T2 10

同步：
 由于调用run()函数取走的是对象锁，而调用prt()函数取走的是class锁，所以同一个线程t1（由上面可知实际上是不同线程）调用run()函数且还没完成run()函数时，它就能调用prt()函数。但prt()函数只能被一个线程调用，如代码（1）和代码（2），即使是两个不同的对象也不能同时调用prt()。
注：注意对象锁与类锁：一个runnable对象可以生成n个线程
 
62.yield():线程调度器把该线程放到同一优先级的Runnable队列的最后
63.生产者-消费者问题
64.wait,nofity,notifyAll必须在已经持有锁的情况下执行,所以它们只能出现在synchronized作用的范围内.
wait的作用:释放已持有的锁,进入wait队列.
notify的作用:唤醒wait队列中的第一个线程并把它移入锁申请队列.
notifyAll的作用:唤醒wait队列中的所有的线程并把它们移入锁申请队列
65.网络
URL：
protocol:resourceName
协议名指明获取资源所使用的传输协议，如http、ftp、gopher、file等，资源名则应该是资源的完整地址，包括主机名、端口号、文件名或文件内部的一个引用。

思想：获取URLConnec对象，之后就可以读写输入/输出流，完成数据的读写
66.Socket通讯
网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个socket

PrintStream os=new PrintStream(new BufferedOutputStream(socket.getOutputStream()));
DataInputStream is=new DataInputStream(socket.getInputStream());
PrintWriter out=new PrintWriter(socket.getOutputStream(),true);
BufferedReader in=new BufferedReader(new InputStreamReader(socket.getInputStream()));

os.close();
is.close();
socket.close();

• 注意关闭的顺序
主要是包装器的顺序
比如一个BufferedReader中会有一个InputStreamReader,这其中会有一个InputStream
按照后开先关的顺序,先关BufferedReader,然后是InputStreamReader,再是InputStream

67.UDP：典型应用是ping

• 收数据报:
DatagramPacket packet=new DatagramPacket (buf,256);
socket.receive(packet);
• 发数据报
DatagramPacket packet=new DatagramPacket 
(buf,buf.length,address,port);
socket.send(packet);

也就是，数据包是对socket的一种修饰
68.
69.

//0813 ,《java设计模式》
1.java中抽象类与接口的区别http://www.enet.com.cn/article/2007/1126/A20071126923475.shtml
	1.1abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract class。 
	1.2abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。其次，在abstract class的定义中，我们可以赋予方法的默认行为。但是在interface的定义中，方法却不能拥有默认行为，为了绕过这个限制，必须使用委托，但是这会 增加一些复杂性，有时会造成很大的麻烦。 
	1.3abstarct class在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is a"关系，interface表示的是"like a"关系。对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。面向对象设计中的一个核心原则ISP（Interface Segregation Priciple）。

2.适配器的两种模式：继承（接口包装，假设接口已经包含有用的方法）和委派（接口不行了）。对于后者，实现客户端类与有用类的协作而非指定接口去定义客户端类需要的行为。
3.关于适配器模式作为接口组的总结（这的确是一本好书啊！！！！！！！！！！！！！！！）
4.外观模式与样例的区别。
5.单例模式：是否延迟初始化。对于延迟初始化，需要考虑多线程同步问题。通过设置对象锁。
作者说：“单例模式或许是最富盛名的一个模式了。但他很容易被误用，因此不要轻易使用。不要让单例模式成为创建全局变量的一种花哨方法(单例模式常常会引入一些耦合)。。。。
“单例模式的机制比其意图更加容易记忆。解释如何保证一个类有且仅有一个实例，要比解释位和需要这种限制要简单得多！”
6.观察者模式：什么是“观察者”？设计模式的命名是一种很形象的描述。理解“感兴趣”和“观察”，也就明白了观察者模式的目的是什么。经典范例就是GUI应用。
page.74与page.314的递进，表明观察者模式并不是简单的注册侦听器，而是为了解耦。明确感兴趣者和感兴趣点分别是什么。
page.315的版本，将模型Tpeak分离出来，这就是所谓的MVC。
7.今天下载了布施曼(Frank Buschmann)的《面向模式的软件架构(POSA)》五卷。抽时间拜读。
8.要分层。将UI放在最上层，其实现放在最下层。
9.代理模式。负责，消息转发。书上给的例子是一个图片加载程序。远程代理的经典框架是RMI。还有动态代理。
代理会导致被代理者(类还是对象？)与其代理紧耦合。
10.
*/





//0813 《深入理解计算机系统》
1.leave：释放当前子程序在堆栈中的局部变量,使BP和SP恢复成最近一次的ENTER指令被执行前的值。
	相当于：
	MOV SP,BP
	POP BP

2.ENTER指令相当于
	PUSH BP
	MOV BP,SP
3.段描述符是GDT和LDT表中的一个数据结构项，用于向处理器提供有关一个段的位置和大小信息以及访问控制的状态信息。每个段描述符的长度是8字节，含有3个主要字段：段基地址、段限长和段属性。根据段类型中的段扩展方向标志E，处理器以两种不同方式使用段限长Limit。对于向上扩展的段（简称上扩段），逻辑地址中的偏移值范围可以从0到段限长值Limit。大于段限长Limit的偏移值将产生一般保护性异常。对于向下扩展的段（简称下扩段），段限长Limit的含义相反。
（段长度为什么是20位呢？4GB）
基地址字段Base（Base address field）：该字段定义在4GB线性地址空间中一个段字节0所处的位置。处理器会把3个分立的基地址字段组合形成一个32位的值。
4.
5.

/*
1.
tomcat端口和根目录配置：
在server.xml中</Host>之前添加
<Context path="/mysite" docBase="L:\Web\tomcat\mysite" debug="0" reloadable="true" crossContext="true">
		</Context>
表示环境寻址。并不是优先级问题。即使在<Server>根目录(L:\Programs\Tomcat\Tomcat6.0\webapps\ROOT)也有mysite目录，也不会寻此。

2.
eclipse的server和本地安装的tomcat、的连接关系：
在新建server时，选择tomcat版本后，要求提供本地tomcat安装目录。（事后也可以通过修改运行时环境来修改）。因此，在eclipse中启动的tomcat就是本地的tomcat。
在eclipse 中修改tomcat服务器，只是修改

3.详见pdf：浅谈Eclipse调用Tomcat服务的原理_+_tomcat更改虚拟部署目录图解.pdf

补充：
关于Tomcat在eclipse中的配置和运行，比较混乱。具体的，可以通过server项目的项直接修改。(并且这个项可以由tomcat服务器在运行设置时修改。。。好乱)
*/



//0815,Tomcat权威指南（第二版） 笔记
1.Tomcat 5.5 以后的binary 核心安装版不再集成Tomcat Administration Web Application，需要独立下载安装。而Tomcat 6.0.13的Administration Web Application仅包含在源码包中，没有独立下载的安装包。
2.关于用户user的配置，需要设置role为admin和manager(已经在CATALINA_BASE\conf\tomcat-users.xml中配置好)
3.tomcat用java编写
4.可以把tomcat当成独立的web服务器和servlet容器（实际上是内嵌web服务器，主要还是动态支持）。也追加了CGI脚本功能（注：jsp与servlet）。可以把apache和tomcat整合，但作者说“这实际上会减慢tomcat的响应速度”
5.重定向——绑定80端口到8080端口：(linux)iptables工具。原理：tomcat会认定请求来源于80端口，因为他在80端口打开了web服务连接器(在server.xml的connector)。但同时也追加端口号8080，除非手动增加代理选项proxyPort
6.UserDatabaseRealm从静态文件加载到内存中且只加载一次。该领域的默认的权限分配文件为tomcat-users.xml。解释一下rols的含义：
7.
8.
//0815,How Tomcat Works 笔记
1.
2.
3.

//0816,Java IO 笔记
1.
2.
3.

//0817,Android开发-	Mark L. Murphy- The Busy Coder's Guide to Android

1.更新sdk，安装各个api，包括一个google inc.的android_18 API
安装android_18的source和demo（注：source需要压缩到.zip文件才能使用）
2.在Nexus S模拟器上遍寻文件管理器不得，于是乎。。。。。用手机网络下载了一个re。。。但是，由于手机使用snapshot，无法在模拟器关闭时修改sdcard内容，也就无法安装知乎了！除非在模拟器运行时卸载sdcard。。这是一个逻辑问题。
3.读Mark L. Murphy,这是一个幽默而渊博的人！你应该像这种人看齐！而不是整天发牢骚！
4.注意，android.*中的android是一个包而不是一个类。注意这里的.的含义
5.android的界面设计是基于xml文件的，着相对于java的内嵌式界面设计是一大进步。
6.不过，最终还得由java程序来实现貌似。看看生成文件R.java中的变量就知道了。
7.
8.
9.
10.


//0818，php开发之  《PHPer 8：chap12：留言板》
http://www.phpchina.com/有时间应该多去论坛走走。别闭门造车。

http://developer.51cto.com/art/201011/233083.htm 你现在处在第二层，正在向第三层进行初步迈进。加油！多看看前辈的足迹。
“他们深知爬楼的游戏就像猴子上树一样，往下看是笑脸，往上看是屁股。为了多看笑脸，少看屁股，他们并没有在此停步不前，而是继续寻找到更上一层的楼梯，以便继续往上爬。”

在技术上的晋级，比在官场上的争斗要有意思多了。那是神圣的。

//0819,重装系统

//0819，汇编

/*汇编救急
//0820，汇编救急！！！！深入理解。。。。
1.习题3.30
2.实验：缓冲区溢出：
3.从3.4节：访问信息开始
八个寄存器：eax ecx edx（主要是操作数据）；ebx edi esi（主要是操作地址，分别表示：基地址，源地址，目的地址）；ebp esp (位置指针)；
注意，这里主要要区分数据和指针。
4.操作：
	操作数指示符（寻址）
	数据传送指令mov[b|z][b|w|l][b|w|l];
	注意push S：subl $4,%esp
				movl S,(%esp)
		popl D: movl (%esp),D
				addl $4,%esp
	算术和逻辑操作
		LEA（load effective address）是mov指令的变形，记忆的要点是：操作数每一个都视作绝对地址（指针）
		大多数指令，既可用于无符号，也可用于补码；只有移位运算对两者进行区分
	控制操作
		条件码 CF ZF SF OF
		除leal之外的所有指令都设置条件码
		cmp和test指令只设置条件码而不做其他操作 cmp[b|w|l],test[b|w|l]
		set指令读取条件码并写入操作数，详见page157。set等底层操作指令可能有同义名，随机选取一个。set指令可解释为t=a-b（三者都是补码表示）？？？？？？？？？？？？？？？？？？？。set结果可以存入8个寄存器中，也可以存入内存中。
		有符号比较，用的是设置符SF和溢出符OF的组合；无符号比较，用的是进位标志CF和零标志ZF组合。
		
		jmp相关指令类似
		
5.算术和逻辑-----弱点：整型数和浮点数操作，习题3.4
6.page213:一个重要的特性是：在IA32中即使操作数是一个字节或者是单字的，存储器的引用也是用双字长给出
----要区分地址和地址中的值
7.为什么要用 xorl %eax，%eax来置零呢?“通过汇编和反汇编我们发现，这条指令只需要2个字节，而mov指令需要5个字节”
8.单操作数乘法，要求另一个操作数在%eax；单操作数除法：%edx：%eax /% S
这里都是基于转为4字
存储两个寄存器的位置对于小端法机器来说是对的。%edx的高位在%eax低位偏移量为4的地方？？？？？？这里的高位是指寄存器高位，但实际上存的是数据低位！！！注意，大小端是针对寄存器的
同时，内存为什么以4位（一个字）一个单位呢？
9.控制语句------跳转指令

9.1.switch：使用跳转表

9.2.条件传送指令：与条件跳转不同，条件传送不必预测测试结果，只是读取源值，检查条件码，然后判断是否更新目标值（复制到目标寄存器）。但是，需要注意：副作用——可能非法

//整数表示
10.when x>=0&&x<2^(w-1)
when <0:
U2T: u-2^w
T2U: t+2^w
11.以偏置的观点看有符号整型数，比较好理解，这是一个卷饼的模型。而浮点数的偏置就是一个平移的模型
起始也可以从模的角度看这个问题。这样，一个正整数和一个负整数的差实际上是前者最高位扩展一个1之后的差。所以说，也可以看做是字面值向左统一偏置一个段（2^32）之后取模。我们称之为全偏置。
12.而浮点数借用上述观点就更好理解了，实际上是字面值e向左偏置。效果是：E=e的最高位取反表示的signed值，然后加1
13.为什么非规格数的偏置是E =e-bias？他是在什么意义上保证的平滑？
向下是平滑的，向上呢？
14.(想明白：是M*2^E,而不是M^E)
15."这不是偶然的，IEEE如此设计格式就是为了浮点数能够使用证书排序函数来进行排序"
16.
*/
mips汇编：
1.在windows下配置交叉编译，没有找到好的方法（linux下可以用gcc配置），于是下载了lcc，并用于mips汇编
2.经典的五级流水：IF，RD，ALU，MEM，WB。流水线划分级数越多，流水越密，则cpu利用率越高。理想状态是零空闲。
3.指令固定为四字节（只使用一个地址片）。（x86可以1~15字节）

注意区分栈的地址耗用和text段的地址耗用！！！！前者是4字节对齐，后者是1字节对齐


***********************************************************************************
***********************************************************************************
今天终于领悟到带符号数该怎么转化了！对于带符号负数，实际上你可以把0当做有效占位，把1当做无效占位，由于1111111111。。表示-1，所以最后的绝对值还要加上1！！！！
这也是对“取反加1”的一种解释！
***********************************************************************************
***********************************************************************************


4.Branch Delay Slot （跳转延迟），加载延迟（Load Delay Slot）

5.ll/sc

6.汇编器预处理
li伪指令：当立即数超过16位时，将指令拆分成li，li再具体映射到中间指令
其中，lui是一条很有用的指令，他可以将32位立即数表示成两个16位立即数的拼接

如：li $6,0x12345 --->   lui $6,0x1; ori $6,$6,0x2345

预处理又如：
lw $2,addr ----> lui at,%hi(addr); lw $2,(%lo(addr))(at) ;注意谁在前

7.lw $1,offset($2) :关于16位偏移地址是否足够：“这种方法已经足够存取C语言结构体的一个成员”

8.注意，linux栈模型中父过程存储的return address可以看做是eip的备份

9.关于偏移：univ(%edx)---谁是偏移还不一定呢

10.区分int中断和系统调用system_call。前者以ax、dx寄存器作为参数，后者类同普通函数调用，以栈顶传参。
同时注意mips下的函数调用。如 ori $2, $0, 10;syscall  以v0传参

11.参数压栈是逆序的，即z，y，x；这样，在读取的时候按地址递增读取






（1）完成课件《x86-32汇编编程-1》中第62页的“程序3——修改数据记录”这一程序的编写与调试，可以调用课上讲的程序示例，如read-record   write-record等。
（2）完成课件《x86-32汇编编程-2》中第19页提到的现有内存管理函数的改进，主要是两条——：
   （2.1）如果brk返回的地址大于请求的地址：这个情况需要考虑，如何有效利用才能够减少brk的调用次数；
   （2.2）释放时应将相邻的available块合并。
    完成程序的编写与调试，提供简单的使用实例。

要求：上交源代码、以及程序说明文档。

注：为减少大家工作，可能用到的已有的.s代码打包附在后面。

























/*反思
今天读知乎，学到了很多，是内心的思考。我发现我还活在最浅的一层。
首先是反思。然后是反思之反思。
*/

/*vim
vim中几个重要的键
1.

:w：save
:e：open
:q： quit
:wq==ZZ :save and quit

x：删除char
dd：delete line
a：insert after 
i：insert before
u：undo
^ :first in line
$ : last in line
/pattern :search

. :repeat
如果要设置编译和运行选项，可以在line.273上下进行。
*/


//0829，SRT
基于特征向量统计而非基于模板匹配的学习：

1.HOG+SVM
2.LBP+Adaboost
3.Harr+Adaboost
*
1.MIT face database
2.INRIA
3.Daimler

2013-05-23晚SRT第四次组会，谢老师关于人脸检测提的几点建议：
1.hog和lbp可以结合使用
2.挖洞法
3.背景排除法
4.面向高度的分层
5.人脸和人身：先检测人脸，再由人脸推测人身，并验证
6.复杂性关键是侧脸、坐姿等影响，一定要结合纹理特征
7.视域

//0901,汇编实验 《IBM-PC实验》
1.明天继续：vim：expe.c expe.s; 命令行：gdb unassmemble expe.o 关于gcc -c命令



//0901,androte 01：数据库基础
《Head first PHP&MySQL》

想写几个python程序玩，怎么办？

__cdecl 是C Declaration的缩写（declaration，声明），表示C语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。
_stdcall 是StandardCall的缩写，是C++的标准调用方式：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 retnX，X表示参数占用的字节数，CPU在ret之后自动弹出X个字节的堆栈空间。称为自动清栈。函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。
_fastcall是编译器指定的快速调用方式。由于大多数的函数参数个数很少，使用堆栈传递比较费时。因此_fastcall通常规定将前两个（或若干个）参数由寄存器传递，其余参数还是通过堆栈传递。不同编译器编译的程序规定的寄存器不同。返回方式和_stdcall相当。
_thiscall 是为了解决类成员调用中this指针传递而规定的。_thiscall要求把this指针放在特定寄存器中，该寄存器由编译器决定。VC使用ecx，Borland的C++编译器使用eax。返回方式和_stdcall相当。
_fastcall 和 _thiscall涉及的寄存器由编译器决定，因此不能用作跨编译器的接口。所以Windows上的COM对象接口都定义为_stdcall调用方式。

//java 大作业
要求比较高。一点点来吧。首先实现网络数据传输和共享功能，细节再具体细化。


用户行为 记录 分析 平台 


------>1.收集大家一天的行为和状态数据

------>2.客户端提提示信息(助手)

------>3.客户端数据上传到服务器端

------>4.用户行为数据的深度挖掘

------>5.社交网站分享


第一阶段：前期
I.开源中国
http://www.oschina.net/project/lang/19/java?tag=0&os=0&sort=view&p=2


1.关于apache mina网络框架和slf4j日志框架
mina中使用slf4j作为日志框架（不知道slf4j的同志们请google下）， 这个只是一个日志框架，是没有实现的，你需要一个具体的实现，比如说log4j（具体使用方法我就不说了，很简单，实在不知道给我发站内信）
mina包的使用之NioSocketConnector 


2.json：简单地说[2]，JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在函数之间轻松地传递这个字符串，或者在异步应用程序中将字符串从 Web 客户机传递给服务器端程序。

3.Zimbra协同办公套件 Zimbra强大的开源协同办公套件包括WebMail，日历，通信录，Web文档管理和创作。它最大的特色在于其采用Ajax技术模仿CS桌面应用软件的风格开发的客户端兼容Firefox,Safari和IE浏览器。


II.ok模板
1.Android瀑布流实例 android_waterfall

2.决定使用joomla建站，并配套插件

3.关于android推送http://www.oschina.net/question/54100_29551

在Android手机平台上，Google提供了C2DM（Cloudto Device Messaging）服务，起初我就是准备采用这个服务来实现自己手机上的推送功能。



III.基础练习
1.mysql
mysql GUI工具mysql administraltor要求输入connection信息。什么是connection？打开navicat就知道了。connection是一个通道，也是一个管理员认证，获得mysql\data\目录下的所有数据库。
通过mysql\bin\my.ini可以修改用户名、端口、密码。


http://jingyan.baidu.com/article/a3f121e41b141afc9052bb8e.html 还是离不了phpMyadmin
在xampp中修改mysql服务器的参数时，使用的还是phpmyadmin，在xampp中内嵌了一个myadmin

选择了生成密码，结果悲剧了！

/*
方法二： 
首先在 MySQL的安装目录下 新建一个pwdhf.ini, 输入文本：SET PASSWORD FOR 'root'@'localhost' = PASSWORD('*****'); 
用windows服务管理工具或任务管理器来停止MySQL服务 (任务管理器K掉 mysqld-nt 进程) 
Dos命令提示符到 MySQL安装目录下的bin目录 如我的是 D:\Program Files\MySQL\MySQL Server 5.1\bin 
然后运行： mysqld --init-file=../pwdhf.ini 进入保护模式
执行完毕 停止MySQL数据库服务 (任务管理器K掉 mysqld-nt 进程)，然后再重新以正常模式启动MYSQL 即可
*/
phpMyAdmin设置了一个自锁，在修改完mysql的密码之后，在myadmin上的权限就不在了，再次登录时就登不上了。无奈，只好修改文件config.inc.php。

接下来，关于mysql自带的管理工具mysql admin，启动时提示server服务和配置文件找不到，http://forums.mysql.com/read.php?34,243469,243519#msg-243519

还是github最靠谱！！
/*
L:\Programs\xampp\mysql\bin>mysql -u root -p
Enter password: ************
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 28
Server version: 5.5.32 MySQL Community Server (GPL)

Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> use database zjqtest;
ERROR 1049 (42000): Unknown database 'database'
mysql> use  zjqtest;
Database changed
mysql> select * from pwd
*/

PHP支持数据驱动的web表单

在w3chschool复习了一下php的基础知识。下一步：用php操作mysql！！！！！！！！！！


php单引号会忠实地输出，甚至连转义都不会，除了转义的单引号（\'）和转义的反斜杠（\\）
而双引号具有强大的力量，会把内部的包括单引号内的变量解析出来



技巧：
1、由于PHP将试图找出那些需要将其值插入到双引号内的变量，所以从理论上讲，使用单引号要快一些。但是，如果需要打印一个变量的值，则必须使用双引号。
2、因为有效的HTML常常包括许多用双引号括住的属性，所以当利用PHP打印HTML时，使用单引号最容易。
echo '<table width="200" border="1" cellspacing="5" cellpadding="2" align="center">';
如果想使用双引号打印出上面这段HTML代码，将不得不对字符串中的所有双引号进行转义，所以相对来说较麻烦。

mysql终端不要忘了USE命令指定待操作数据库

修改版：
<Directory "L:/Code/eclipse/PHP">
	#Options FollowSymLinks ---only this cannot share the subdir
	Options Indexes FollowSymLinks Includes ExecCGI
	AllowOverride All
    Require all granted
	#Allow from all
</Directory>


关于Hibernate的使用
这几天接到一些询问关于Hibernate使用的咨询，我整理了个Demo给大家，放在了课程文件关于用Hibernate封装SQL读取数据库的操作，大家可以down下来看看。我这里提醒下关于Hibernate使用的几个注意事项：
1.jar包版本问题：这是最容易出问题的，同学们需要注意hibernate实现所需要的jar包的版本，我在demo中挂了能使用的jar包套装，可以直接使用。或者可以到网上搜索下版本对应问题，寻找自己合适的版本，不再赘述。
2.配置文件的位置问题：hibernate主要的有两类配置文件，1）hibernate.cfg.xml，这是配置数据库相关信息的文件，详细见demo,可以放在任何位置，只要在生成factorySession时config即可，如果不想指明，就放在src下，编译时自动加载到class中；2）XXX.hbm.xml，这是映射文件，就是负责映射你的类和数据库中的表的文件，一定注意命名规范，否则找不到表中的字段
3. 数据库中字段的类型需要与Hibernate中的XXX.java中的类型映射正确（XXX.hbm.xml）
4. demo使用：我在demo的压缩包里放了测试数据库sql文件（test.sql），在你自己的本机上直接导入即可，注意用户名密码等配置信息（hibernate.cfg.xml中），然后导入project即可，入口为DAO.operation.Impl.OperateDataImpl.java 

其实使用Hibernate细心点就可以，基本都是配置问题，可以利用这个机会了解下开源框架的各种机制的使用方法，在以后开发中会大大节约开发工作量。  



关于Struts2的使用
我再上传个简单的Struts2框架传文件的Demo，一些配置信息参考（web.xml，struts.xml），如文件大小限制等。使用servlet处理是一样的，struts2只是封装了一层，调用更加简单而已。希望同学们了解struts2的映射机制，这样处理表单更加容易。demo同样上传到了课程文件中，大家可以下载看看。
注意：我上传的是Myeclipse的web project，如果大家使用的是Eclipse的Dynamic Web project，需要手工导入文件。


http://www.w3school.com.cn/jquery/jquery_intro.asp
jQuery 库包含以下特性：
HTML 元素选取
HTML 元素操作
CSS 操作
HTML 事件函数
JavaScript 特效和动画
HTML DOM 遍历和修改
AJAX
Utilities

伪类！

jQuery 元素选择器
jQuery 使用 CSS 选择器来选取 HTML 元素。
$("p") 选取 <p> 元素。
$("p.intro") 选取所有 class="intro" 的 <p> 元素。
$("p#demo") 选取所有 id="demo" 的 <p> 元素。

jQuery 属性选择器
jQuery 使用 XPath 表达式来选择带有给定属性的元素。
$("[href]") 选取所有带有 href 属性的元素。
$("[href='#']") 选取所有带有 href 值等于 "#" 的元素。
$("[href!='#']") 选取所有带有 href 值不等于 "#" 的元素。
$("[href$='.jpg']") 选取所有 href 值以 ".jpg" 结尾的元素。


网站只需四页：
1.首页（菜单导航、作者说明）
2.用户主页（用户信息）
3.查询结果页
4.用户登录页（登录/注册对话框）


后期


明天的任务：
1.下载pudn的strus2-hiber-例程
2.上午完成网页表单-struts，以及android程序学习
3.struts！！！！！
4.下午完成android界面
5.下午完成一个bomb




struts就是一个中间使者，他从jsp页面获取请求的action名字，将这个名字解析为具体的类；类处理完后返回一个消息，struts在将这个消息解析为具体的页面







1.读完 myweather，感觉：写xml parser和天气模块解决了
2.还有四个：
	share
	record
	check
	settings

3.读notepad，低级数据库解决了，settings中的密码和闹铃解决了
4.keytool -list -alias androiddebugkey -keystore L:\Android\sdk\.android\debug.keystore
-storepass android -keypass android


明天任务
1.
http://www.admin5.com/article/20120621/439464.shtml
完成struts初步
2.完成安卓myweather，notepad，maps的整合

#2013秋
#2013-0917
#406900530 隋唐五代史 60 0 张国刚 2-2(全周) 4201
#0919,中秋节计划
1.熟悉python
2.读论文，修改pmount程序
3.linux
4.matlab

#0919,python
0.python的无穷精度整数是怎么实现的？这涉及python解释器的实现
1.python的动态类型：基本原理--引用，顺便引出一些问题，如引用共享、垃圾收集---这些与java的确很像
2,python没有字符串中断符
3.函数也是对象，而且是实时产生

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
/*触摸板君
 * 中秋，让成龙电影陪你
linux关闭触摸板命令
终端输入如下命令： 
sudo modprobe -r psmouse
如果打开触摸板就是：
sudo modprobe psmouse
*/

/*鸟哥
 * 咦!似乎好像是可以喔!因为有可读[ r ]存在嘛!『错!』答案是非 root 这个账号的其它使用
者均不可进入 .ssh 这个目录,为什么呢? 因为 x 与 目录 的关系相当的重要, 如果您在该目
录底下不能执行任何指令的话,那么自然也就无法进入了,因此, 请特别留意的是,如果您想要
开放某个目录让一些人进来的话, 请记得将该目录的 x 属性给开放呦!至于目录的权限相关说
明, 我们会在底下继续介绍的。
另外,你也必须要更加的小心的是,在 Windows 底下一个档案是否具有执行的能力是藉由『 附
檔名 』来判断的, 例如:.exe, .bat, .com 等等,但是在 Linux 底下, 我们的档案是否能执
行,则是藉由是否具有 x 这个属性来决定的!所以,跟档名是没有绝对的关系的!
*/

/*灰帽
 * 调试器就是黑客的眼睛---《灰帽python》
 * apt-get install edb-debugger
一个优秀的调试器必须是可定制脚本的,能够自定义事件处理函数从而对程序进行自动化调试。举个例子,一个内存访问违例产生的缓冲区溢出,对于黑客来说相当的有趣。如果在平时正常的调试中你就必须和调试器交互,一步一步的收集信息。但是当你使用定制好的脚本操作调试器的时候,它就能够建立起相对应的事件处理函数,并自动化的收集所有相关的信息。这不仅仅节省了时间,还让我们更全面的控制整个调试过程。
*/

/*灰帽
 * “到目前为止,我们已经讲解完了调试器的基础知识和工作原理,接下来我们要亲自动手写一个 Python 调试器,这个基于 Windows 的轻量级调试器,将会用到我们目前学到的所有知识。”(尼玛！！！)
 * Windows debugging API
 * root is hack 
 * 实现这一功能的是一个强大的函数 CreateToolhelp32Snapshot(),它由kernel32.dll 导出。这个函数能枚举出一个进程内部所有线程的列表,以加载的模块(DLLs)的列表,以及进程所拥有的堆的列表。
*/

/*灰帽
 * 这里我们感兴趣的是保护页(Guard Page).这种类型的页面常被用于:分离堆和栈或者确保一部分内存数据不会增长出边界。另一种情况,就是当一个特定的内存块被进程命中(访问)了,就暂停进程。举个例子,如果我们在逆向一个网络服务程序,在其接收到网络数据包以后,我们在存储数据包的内存上设置保护页,接着运行程序,一旦有任何对保护页的访问,都会使 CPU 暂停,抛出一个保护页调试异常,这时候我们就能确定程序是在什么时候用什么方式访问接收到的数据了。之后再进一步跟踪观察访问内存的指令,继而确定程序对数据做了什么操作。
 * hook:形象的理解就是示波器表笔的钩子，负责截取信号进而分析
 * 。。。Hooking can also be used by malicious code. For example, rootkits, pieces of software that try to make themselves invisible by faking the output of API calls that would otherwise reveal their existence, often use hooking techniques. A wallhack is another example of malicious behavior that can stem from hooking techniques.
 * 
 * DEP 是一种在 windows(XP SP2, 2003, Vista)下实现的的安全保护机制,用来防止代码在栈或者堆上执行。这能阻止非常多的漏洞利用代码运行,因为大多的 exploit 都会把shellcode 放在堆栈上。然而有一个技巧能巧妙的绕过 DEP,利用微软未公布的 API 函数NtSetInformationProcess()。它能够阻止进程的 DEP 保护,将程序的执行权限转移到 shellcode。 
 * 
 * 很好,我们很清晰的看到了用户名和密码。但是如果从网络层看传输的数据,将是一堆经过 SSL 加密的无意义的数据。这种方法不仅对 OpenRCE 有效。当你浏览任何一个需要传输敏感数据的网站的时候,这些数据都将很容易的被捕捉到。现在再也不用手工操作调试器去捕捉了,自动化才是王道。
*/

//0920,中秋2,《python网络编程基础》
1.
同步和异步的区别 
 举个例子：普通B/S模式（同步）AJAX技术（异步）
同步：提交请求->等待服务器处理->处理完毕返回 这个期间客户端浏览器不能干任何事
异步: 请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕
2.xinetd
3.syslog
4.telnet
5.打字
6.socket是强大的
7.DNS
8.urllib(&urllib2)才是python的Web之美！
9.SSL：攻击并不总是发生在端点处，而很有可能是在中途，我们称之为man-in-the-middle
10.利用输入框进行恶意代码注入：主要是因网站偷懒，用了shell_exec()，给我们插入管道以机会
11.破解、重复、伪装、人体工程学
12.SSL可以通过端点认证、过程认证（数据认证）、过程加密来尽量保证安全
//0921,中秋3,《灰帽子python》
0.三种断点
1.kernal32引入windows debugging api,用于windows下的断点设置、中断处理
2.pydev这种高级玩意儿
3.Immunity Debugger这种更高级的玩意儿（只有windows下的，并且貌似没有源码）
4.如何处理病毒程序的反调试机制（更像在教我们写病毒啊有木有）
5.hook，以及wiki上关于hook的例程
6.wireshark，高端大气上档次
7.如何绕过加密，破解wireshark抓到的包（自己动手，丰衣足食）

//0922,周末，git 《Version Control with Git（2nd Edition）》
//纪：Proj Tekla开始。

1.ssh服务设置以及putty登录:http://www.cnblogs.com/nodot/archive/2011/06/10/2077595.html
2.

//0924,Detector
1.通道表示每个点能存放多少个数，类似于RGB彩色图中的每个像素点有三个值，即三通道的。图片中的深度表示每个值由多少位来存储，是一个精度问题，一般图片是8bit（位）的，则深度是8.
2.首先应该二值化还是滤波？
3.关于makefile：http://xpku.blog.163.com/blog/static/2396500200942732124813/
4.

//0924,论文++
/*

1.A People Counting System based on Head-shoulder Detection and Tracking in Surveillance Video

首先，为了减少计算成本和应付各种复杂监视前景提取的情况下，自适应组件号码选择策略混合高斯模型提议。其次，行人检测他们的头肩膀上，因为这部分是多样的，不太可能闭塞从一向下斜率查看。第三，每行人通过连续帧，使用跟踪卡尔曼过滤技术和成本的功能。最后，在由此产生的轨迹进行分析，以数人进入或离开现场。

Many approaches based on video content have beenproposed to solve the problem of people counting. In theliterature, author developed approaches relying on three maincategories: motion detection, feature clustering and map­ based method. 

Thesemethods can only acquire satisfactory results when thenumber of people in view is limited, and hence cannot beapplied in complex conditions such as illumination changes,serious occlusions, overlaps and arbitrary movements.Alternatively, the overhead camera is adopted to ease thecounting task by avoiding occlusions among people andsimplifying the human model. However, the overheadcamera can only monitor a limited region, which is not suitedfor wide area monitoring. 


（自注：1.能不能直接训练人数-前景像素？）

A linear SVM classifier istrained to search for head-shoulder component over theforeground region. Each person is tracked throughconsecutive frames using the Kalman filter and costfunction. The resulting trajectories are analyzed to count people entering or leaving the scene.


A.Foreground Extraction
（采用GGM，为了提高效率，采用自适应的K值）

B.People Dectection
（引http://www.360doc.com/content/10/0601/10/1412027_30625801.shtml：
	颜色特征是一种全局特征，典型就是颜色直方图，特别适用于难于自动分割的和不需要考虑空间位置的。
	纹理特征也是一种全局特征（注），只是利用了表面性质，这种特征的得出，是通过像素区域的统计计算得到的。依赖于运算，这种特征可能会对光照、分辨率很敏感。
	纹理特征的提取，除了Voronio的大名鼎鼎的棋盘格法（认为复杂纹理是由基本纹理元素组成）之外，还有就是基于模型的方法（注：模型法都是用模型再现场景，用这种成功再现的参数与该模型一起描述特征），比如隐马尔可夫随机场模型
	最后就是形状特征。包括轮廓（如边缘）和形状区域。目前没有比较完善的数学模型。
	边界描述，首先是微分图像得到边缘（注意，光得到边缘，并没有结束）。然后根据边缘信息得到边缘大小和边缘方向直方图（如灰度梯度方向矩阵）（其实，边缘统计得到的难道不是纹理特征吗？详见～/dowm/doc/chap9.pdf））

Zhu et al. [10] integrate the cascade-of-rejectersmethod with HOG features to speed up Dalal's method greatly, using linear SVM as weak classifier. 



2.Counting people using video cameras

	An intuitive solution to the problem of estimating the size of a crowd in an image will be,literally, to obtain a head count.While this would be a tedious, but yet feasible, task for ahuman it certainly is a difficult problem for an automatic system. That is exactly theproblem tackled in Ref. [2], where wavelets are used to extract head-shaped features fromthe image. Further processing uses a support vector machine to correctly classify thefeature as a “head” or “something else” and applies a perspective transform to account forthe distance to the camera.
	
	a face detection program [3] is used to determinethe person count. Unfortunately, as pointed out by its authors, this method is affected by theangle of view at which the faces are exposed to the camera. 

	Another approach has been suggested in Ref. [4], it aims to obtain an estimation of thecrowd density, not the exact number of people. It requires a reference image—where nopeople are present, in order to determine the foreground pixels in a new image. A single layerneural network is fed with the features extracted from the new image (edge count anddensities of the background and crowd objects) and the hybrid global learning algorithm isused to obtain a refined estimation of the crowd density.

	We just exploit the correlation between thepercentage of foreground pixels and the number of people in an image [5].

	[3] Sweeney, L. and Gross, R., 2005, Mining images in publicly-available cameras for homeland security. AAAI Spring Symposium on AI Technologies for Homeland Security, Palo Alto.
	[4] Cho, S.-Y., Chow, T.W.S. and Leung, C.-T., 1999, A neural-based crowd estimation by hybrid global learning algorithm, IEEE Transactions on Systems, Man and Cybernetics, August, Part B 29(4), 535–541.

	we selected the following two sources: (1) a publicly available webcam at Times Square; and (2) two webcams in the premises of the Accenture Technology Labs in Chicago.

	We implemented the following algorithms: (a) multiple linear regression; (b) k-nearest neighbour with Euclidean distance; (c) a two-layer resilient backpropagation neural network(BPNN) with a log-sigmoid transfer function for the first layer and ten neurons [8,9]. 


:-1: error: /usr/lib/libopencv_highgui.a(window_gtk.cpp.o): undefined reference to symbol 'g_type_check_instance_is_a'

*/

//0928,libsvm
//总结最近：1.站长面试 2.令狐冲 3.回家车票。最近的分支：1.hack（python/ssh/server）2.matlab 3.ml（opencv/svm/nns）4.makefile 5.git

libsvm的java使用，非常方便，尤其是在有源码的情况下，配合eclipse。
库的导入和源码关联以及环境测试：http://www.cnblogs.com/freedomshe/archive/2012/10/09/2717356.html
这里我们使用的是自己下载的源码包中的库。实际上系统安装的libsvm反而麻烦了许多。

关于SVM：
1.教材《统计机器学习》：
支持向量机由很少的重要的训练样本决定（想一想，也就是找到最严格的、最本质的分类标准）

核心任务是保证确信度。

基础算法是进行凸二次规划问题。

再次基础上的实践算法是拉格朗日对偶算法。不仅便于计算，而且自然地引入核函数，便于扩展。

net use z: \\vboxsvr\chunkshare
//1003,《编译原理》
1.
2.
3.
4.
5.
6.
7.
8.
//1009,git


//1010,CCP,Homework for Part I 

1 1． We have mentioned that bits have no inherent meaning. Given the bit pattern 
1000 1111 1110 1111 1100 0000 0000 0000 
What does it represent, assuming that it is 
1 a. a two’s complement integer? 
2 b. An unsigned integer? 
3 c. A single precision floating-point number? 
2 2． Write a simple C program that inputs a floating-point number and shows its bit representation in hexadecimal. 

1 3． In a Hamming code, some bits are ‘‘wasted’’ in the sense that they are used for checking and not information. What is the percentage of wasted bits for messages whose total length (data + check bits) is 2n − 1? Evaluate this expression numerically for values of n from 3 to 6. 

1 4． Convert 512ten into a 16-bit two’s complement binary number. 

1 5． Convert -78ten into a 16-bit two’s complement binary number. 

6．计算题：

x=16, y= -3

(1)用原码一位乘法计算[x×y]补。
(2)用布斯算法计算[x×y]补。
(3)用不恢复除数法计算[x/y] 原。

//1011,CPP
1. 针对第 7 页中 EBNF 描述的各单词类别,设计相应的正规表达式。(非书面作业)

2. 针对第 18 页中所描述的“注释”单词类别,设计相应的正规表达式。你可以先试着直接设计这个正规表达式,若觉得复杂,就采用第18页所述的方法进行设计。如果有兴趣,还可以在第一阶段实验中测试你的结果。(非书面作业)

3. 阅读并分析PL/0编译器的词法分析程序。(写出阅读和分析报告,通知时再提交)


opencv_haartraining -data data -vec a.vec -bg ../../NEG/ndsp.data -npos 3510 -nneg 399 -nstages 14 -nsplits 2 -mem 512 -nonsym -w 32 -h 32


//1014,hog
Histograms of Oriented Gradients for Human Detection(Navneet Dalal and Bill Triggs)

	The method is based on evaluating well-normalized local histograms of image gradient orientations in a dense grid. Similar features have seen increasing use over the past decade [4,5,12,15]. The basic idea is that local object appearance and shape can often be characterized rather well by the distribution of local intensity gradients or edge directions, even without precise knowledge of the corresponding gradient or edge positions. 

	For better invariance to illumination, shadowing, etc., it is also useful to contrast-normalize the local responses before using them. This can be done by accumulating a measure of local histogram “energy” over somewhat larger spatial regions (“blocks”) and using the results to normalize all of the cells in the block. We will refer to the normalized descriptor blocks as Histogram of Oriented Gradient (HOG) descriptors. 

	An overview of our feature extraction and object detection chain. The detector window is tiled with a grid of overlapping blocks in which Histogram of Oriented Gradient feature vectors are extracted. The combined vectors are fed to a linear SVM for object/non-object classification. The detection window is scanned across the image at all positions and scales, and conventional non-maximum suppression is run on the output pyramid to detect object instances, but this paper concentrates on the feature extraction process.


	文献[9]中的算法将HOG特征和线性SVM相结合，能够很好地区分人体和非人体。因此，本文采用线性SVM进行行人验证，需为其确定的模型参数为惩罚系数C。 首先对每张不含人的训练图片随机采样10个子图片得到负训练样本，并与规范大小的正训练样本一起构成最初的训练样本。然后，利用前文所述的边缘对称性对其进行检测，并用检测为行人的样本训练SVM。考虑到训练时间的限制，本文只选取1 110个负样本和1 110个正样本进行训练得到初分类器。最后，用该分类器对所有不含人的训练图片进行密集扫描检测得到困难负样本，并与之前的初负训练样本合并，得到负训练样本，共2 198个。 正样本的正确接收率(True Positive Rate, TPR)和支持向量数是评价SVM的两大重要指标。本文采用十折交叉验证方法来计算这2个指标，进而确定参数C。在验证过程中，将收集到的1 110个正样本随机地等分成10组，取其中9组与上述得到的负训练样本一起作为训练样本，剩下的一组作为测试样本以计算TPR，并取10次实验结果的均值作为最


	We selected 1239 of the images as positivetraining examples, together with their left-right reflections (2478 images in all). A fixed set of 12180 patches sampled randomly from 1218 person-free training photos provided the initial negative set. For each detector and parameter combination a preliminary detector is trained and the 1218 negative training photos are searched exhaustively for false positives (‘hard examples’). The method is then re-trained using this augmented set (initial 12180 + hard examples) to produce the final detector. The set of hard examples is subsampled if necessary, so that the descriptors of the final training set fit into 1.7 Gb of RAM for SVM training. This retraining process significantly improves the performance of each detector (by 5% at 10−4 False Positives Per Window tested (FPPW) for our default detector), but additional rounds of retraining make little difference so we do not use them.
	To quantify detector performance we plot Detection Error Tradeoff (DET) curves on a log-log scale, i.e. miss rate FalseNeg  versus FPPW.


	http://hi.baidu.com/yanggmbright/item/c8cb7cedeed12eb62f140b99
	http://zhaohong180.blog.163.com/blog/static/1510057220118103128277/
	(adaboost)其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。使用adaboost分类器可以排除一些不必要的训练数据特征，并将关键放在关键的训练数据上面。    


//1015,hog2
	This code implements a multiscale detector for visual object recognition and notably for human detection. It requires three external libraries:

	-- Imlib2       for reading/writing images
	-- Blitz        for efficient array processing
	-- Boost        for many other general c++ utilities not present in ISO C++


<pre class="brush: shell; gutter: true">
amadeuzou@ubuntu:~/Projects/opencv/OLTbinaries/test$ ls ./neg &gt; neg.list
amadeuzou@ubuntu:~/Projects/opencv/OLTbinaries/test$ ls ./pos &gt; pos.list
</pre>

//编译lear不同过，前期主要是blitz中的tinyvec升级，（期间删除了对tinyvec-et的包含。。）后期主要是文件include出问题。。
//总结一下今天的安装工作：编译安装（在/usr/local）了imlib2、blitz、boost（编译了一个钟头。。）。
//在OLTbinaries中实验，发现可执行文件引用的blitz动态库版本不对，因此貌似要从lear重新生成这些可执行文件。
//下一步，放弃编译lear，直接使用
//为了方便，安装了colorgcc和colormake（其实就是两个perl脚本）。

//编译不成功，算了，还是直接用opencv的hogsvm工具链吧！


//阶段总结：1.链接（库）不能直接复制，否则会broken	2.搜索的第一要务是找和自己的处境最相似的人	3.gcc与g++不一样	4.gcc(或g++)的-m32选项需要安装multilib	5.链接库找不到，原因是-L写在前边了！！	6.perl脚本的使用


//今天终于可以交差了--谢谢http://1.happylyang.sinaapp.com/?paged=2， 提醒我光有一个libImlib2.so是不够的，于是我把从ubuntu下载的i386包重新安装了



//1019，调通了load_alt函数并merge进了qt中（其中最大的问题是hogdescriptor的参数问题）。下一步可以在detectMultiScale的参数上做文章，包括ROI设置



//1019,研习python脚本
//1019,git第二讲：git的数据库系统可以借鉴进数据库设计
//1020,Marathon!
乐音体系的数学原理 黄力民

关于协和音：音高之比越简单，两音的感觉效果越纯净、愉快、和谐。但是受八度数限制，以及纯净的副效果（空洞），八度音被当作一个音处理。除了2：1以外，引入3：1，3：2

//1022
High Performance MySQL, 3rd Edition

1.Transaction logging helps make transactions more efficient. 

2.MySQL stores each database (also called a schema) as a subdirectory of its data directory in the underlying filesystem. When you create a table, MySQL stores the table definition in a .frm file with the same name as the table.Each storage engine stores the table’s data and indexes differently, but the server itself handles the table definition.

/*
http://zhidao.baidu.com/link?url=fb20VVxDVcvNz3-o8tLqy1m-XlB3LO0bJ-QBMdfIrraYvlm5fVCHT2w9JjoyMetuxpGNI70QlQ6HedhPBUAxua
MVC模式是指设计模式
我们现在开发B/s最常用的模式
Model View Control
中文意思是模型,视图,和控制器
就是说做项目时把这三个东西分开,简单的说就是要分开三层.模型层,一般在开发中就是Hibernate用的层.把对像映射到数据库

View是指视图,也就是用html也显示数据的层 控制一般是指Struts所用的层.控制项目的流程.数据流,转向等等

一般这三层要弱奥和.以使的项目有很好的可重用性
-----

ORMapping
是指对象关系映射.是模型层的一种处理对像的方式.
举个例吧:就是如何把一个对象的各种状态保存到数据库里面
*/
Hibernate是一个轻量级的ORMapping框架
http://www.cnblogs.com/dcba1112/archive/2011/05/01/2033805.html


最简单的方法:把hibernate-release-4.0.0.Beta4.zip包里面lib/required下的jar包全部添加到工程的library里面,另外还需添加slf4j的实现包slf4j-log4j12-1.5.8.jar和log4j的实现包log4j-1.2.16.jar,还有别忘了把JDBC的驱动jar包(例如mysql-connector-java-5.1.26-bin.jar)也加入到library里面.

这两天研究了一下 context.lookup("java:comp/env/XXX")和直接context.lookup("XXX")的区别 


今天受打击了。的确应该好好练练英语口语了。

由以下理解什么是session，色和那么是transaction
try{
	//准备数据
	UserModel um = new UserModel();
	um.setUuid("1");
	um.setUserId("id1");
	um.setName("name1");
	um.setAge(1);
	s = sf.openSession();
	t = s.beginTransaction();
	s.save(um);
	t.commit();
} catch (Exception err) {
	t.rollback();
	err.printStackTrace();
} finally {
	s.close();
}


我们为什么需要架构？一切都是为了更简单。






//1025
《深入浅出Struts2》

智能的默认设置、annotation 的使用以及“惯例重于配置”原则的应用,而这一切都大大减少了 XML 配置。
JSP全名为Java Server Pages，其根本是一个简化的Servlet设计。（它的主要目的是将表示逻辑从Servlet中分离出来。JSP指令控制JSP编译器如何去生成servlet。）

JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。Web服务器在遇到访问JSP网页的请求时，首先执行其中的程序段，然后将执行结果连同JSP文件中的HTML代码一起返回给客户端。插入的Java程序段可以操作数据库、重新定向网页等，以实现建立动态网页所需要的功能。

JSP技术使用Java编程语言编写类XML的tags和scriptlets，来封装产生动态网页的处理逻辑。网页还能通过tags和scriptlets访问存在于服务端的资源的应用逻辑。JSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计。

在通信量大的服务器上，Javaservlet的优点在于它们的执行速度更快于CGI程序。各个用户请求被激活成单个程序中的一个线程，而无需创建单独的进程，这意味着服务器端处理请求的系统开销将明显降低。

在早期的每一个 JSP 文件中,都可以找到以下两种情况之一:
	剪切和粘贴的代码 —— Java 代码从一个 JSP 中复制到第二个,第三个,等等。这种情况会导致在原始代码中存在的缺陷或者错误传播开来,并且大大增加了工作量,因此必须要对此做出改变。
	
	调用通用的 Java 格式化对象——通用的格式化代码或者是逻辑代码被组织到一个可重用的对象中,然后每一个 JSP都会使用这个通用的对象。
	
基于这些情况,一种最佳实践,或者可以称之为一种模式,就应时而生了——在 JSP 中使用 Java 对象。标签开始被引入进来对可重用的Java 对象进行封装。标签提供了用以访问底层代码的表层代码,它与 HTML 很相像,设计人员(而不是开发人员)和 IDE 可以通过它与动态内容互,组装出面局 。

基于 Action 的框架把 Servlet 和 JSP 的概念合并到了一起。它的想法是把对当前用户所见的页面请求的处理动作,分拆成处理逻辑和表现逻辑,让它们各司其职。在这个模式中,Servlet 是控制器,集中处理所有的客户端页面请求。（模型-视图-控制器：MVC）


出于解决这种复杂度的需要,基于组件的框架开始流行起来。它们在用户界面组件和表示这些组件的类之间提供了一层紧密的连接,它们是事件驱动型的,并且比起基于 Action 的框架而言,更具有面向对象的特征。


《Struts2实战》好书！
1.Web很简单————像所有优秀的解决方案一样，如果它不简单，就不可能成功。

2.关于标签库：
	清单A：执行XML/XSL 转换的示例标签及其所在的HTML页面
	<%@ taglib uri="http://www.jspinsider.com/jspkit/JAXP" prefix="JAXP"%>
	<JAXP:TransformerTag>
	<JAXP:XMLFile>c:/xml/example.xml</JAXP:XMLFile>
	<JAXP:XSLFile>c:/xml/example.xsl</JAXP:XSLFile>
	</JAXP:TransformerTag>
	以上的示例使用了简单的标签来访问处在幕后的更强大代码
标签很容易从一个JSP项目迁移到其他项目。一旦建立了一个标签库，则只需要将所有的东西打包为一个JAR文件，你就可以在任何的JSP项目中重新使用。

3.约定替代配置！---->自动化！

4.关于HTTP的弱性和Servlet API的作用（底层）。

5.让JAVA开发人员不感到无趣和乏味也是相当重要的目标！

6.AOF：面向动作的框架。原因：尽管调用方式不同，但他们完成个了一个一致的工作流模式

7.框架的任务：1.自动化日常任务，2.提供结构化的解决方案（例如：对动作进行抽象）

8.struts中使用的MVC变体——前端控制器。控制器的作用是将请求映射到动作。这里的动作就是所谓的模型。模型就是事物本身，是一个黑盒子，由数据模型和业务逻辑共同组成。

9.拦截器的工作举例：日志、数据验证、转换、上传。用好拦截器可能会有很好的效果。

10.初识Struts2：声明性架构（1.管理性质的配置 2.声明应用程序的架构），两种实现方式：1.XML 2.JAVA注解

11.servlet容器？？比如tomcat（新手）。（要做到IDE、构建工具无关，甚至连Ant和Tomcat都不行。Struts 2社区采用流行的Maven 2作为构建和管理工具。）之后将war文件部署到tomcat上。http://blog.csdn.net/xuexin25java/article/details/7975324

12.web.xml中定义了filter为struts2

13.聲明性架構的靈活性。

14.所谓WEB-INF等等是servlet规范。web.xml：部署描述符

15.Java Beans 和 ValueStack是数据流的核心。数据搬移实际上是由部分拦截器实现的(如params)
	--关于数据冲突问题，引出与struts1的根本区别：为每一个映射到这个动作的请求创建一个action实例
	-- 结果路由(ActionMapping)是通过控制字符实现的








//1027,Jflex&byacc
/*

《Jfelx Mannual》

1.%eof{...%eof}其中用户代码遇到文件结束时只执行一次,用户代码将被放到 void yy do eof()方法中,并且不返回任何值。如果需要返回值应该使用%eofval{...%eofval}指令或者《EOF》规则。
			
2.总而言之，包含状态和排除状态的只有在规则前没有状态列表时才体现出来。那些状态列表为空的规则只能匹配除排除状态以外的所有规则。
	
3.语法结构使用 BNF 范式形式给出(可以认为是正规表达式的一种方言？)
	//http://www.jflex.de/manual.html
	Syntax

	The syntax of the "lexical rules" section is described by the following BNF grammar (terminal symbols are enclosed in 'quotes'):
	LexicalRules ::= Rule+ 
	Rule         ::= [StateList] ['^'] RegExp [LookAhead] Action 
				   | [StateList] '<<EOF>>' Action
				   | StateGroup 
	StateGroup   ::= StateList '{' Rule+ '}' 
	StateList    ::= '<' Identifier (',' Identifier)* '>' 
	LookAhead    ::= '$' | '/' RegExp
	Action       ::= '{' JavaCode '}' | '|'

	RegExp       ::= RegExp '|' RegExp 
				   | RegExp RegExp 
				   | '(' RegExp ')'
				   | ('!'|'~') RegExp
				   | RegExp ('*'|'+'|'?')
				   | RegExp "{" Number ["," Number] "}" 
				   | '[' ['^'] (Character|Character'-'Character)* ']' 
				   | PredefinedClass 
				   | '{' Identifier '}' 
				   | '"' StringCharacter+ '"' 
				   | Character 

	PredefinedClass ::= '[:jletter:]' 
					  | '[:jletterdigit:]' 
					  | '[:letter:]' 
					  | '[:digit:]' 
					  | '[:uppercase:]' 
					  | '[:lowercase:]' 
					  | '.'	
4.当对输入流进行词法分析时,词法分析器依据最长匹配规则来选择匹配输入流的正规式,即所选择的正规式能最长地匹配当前输入流。如果同时有多个满足最长匹配的正规式,则生成的词法分析器将从中选择最先出现在词法规范描述中的那个正规式

5.The generated class contains (among other things) the DFA tables, an input buffer, the lexical states of the specification, a constructor, and the scanning method with the user supplied actions.

6.(the func yylex() )It may return a value of the specified returntype (in which case the scanning method return with this value), or if it doesn’t return a value,the scanner resumes consuming input until the next expression is matched. If the end of fileis reached, the scanner executes the EOF action, and (also upon each further call to the scanning method) returns the specified EOF value 


7.与Byacc/J的合作： 
	Since Yacc’s architecture is a bit different from CUP’s, the interface setup also works in a slightly different manner. BYacc/J expects a function int yylex() in the parser class that returns each next token. Semantic values are expected in a field yylval of type parserval where “parser” is the name of the generated parser class.
	
	The lexer expects a reference to the parser in its constructor.

8.Yacc invokes two disambiguating rules by default:
	1. In a shift/reduce conflict, the default is to do the shift.
	2. In a reduce/reduce conflict, the default is to reduce by the earlier grammar rule (in the input sequence).

9.优先级和结合性与每个文法规则相关联；它是这个规则主体的最后的记号或文字的优先级和结合性。如果使用了 %prec 构造，它替代这种缺省。一些文法规则可以没有与之关联的优先级和结合性。

10.在有归约/归约冲突时候，或者有移进/归约冲突并且输入符号或者文法规则之一没有优先级和结合性的时候，则使用在章节开始处给出的两个去歧义规则，并报告冲突。如果有移进/归约冲突，并且文法规则和输入符号有与之关联的优先级和结合性，则以有利于关联着更高优先级的动作(移进或归约)的方式解决冲突。如果优先级相同，则使用结合性；左结合暗示归约，右结合暗示移进，而无结合暗示错误。


11.使用右递归规则解析器会更大，项目将从右至左的见到和归约。更严重的是，如果读的是非常长的序列，解析器的内部栈就有溢出的危险。所以，只要合乎情理用户就应当使用左递归。

12.
	Decaf:在嵌套的作用域中重新声明的标识符屏蔽外层的同名标识符,但不允许在局部作用域中声明与外层的局部作用域或参数作用域中的变量同名的变量。另外,类名不会被任何非全局标识符屏蔽。
	
	定义一个类的时候将会创建一个新的类型名称以及一个类作用域。一个类定义是一个成员域的列表,每一个成员域要么是一个变量,要么是一个函数

	所有的方法都是公开的(到处都可以访问)。因此,访问一个对象的状态的唯一手段是通过它的成员函数。

13.
	类,函数和类成员变量可以在声明之前使用,唯一的条件是该符号是在引用处是可访问的。局部作用域中的变量必须先声明后使用。
*/

//1030
	(SRAM)ISSI-IS61LV25616AL
//1030,srt

1.实验室背景切片，构成负样本
2.下载人群，裁剪头肩，组成正样本（或者直接利用原来的）
3.adaboost训练
4.为了搜索不同大小的目标物体，分类器被设计为可以进行尺寸改变，这样比改变 待检图像的尺寸大小更为有效。

/home/chunk/Programs/lib/OpenCV-2.4.2/apps/traincascade

	http://code.opencv.org/issues/1834
	Thanks for the detailed report and especially for the vec-file. The problem is that your vec-file has exactly the same samples count that you passed in command line -numPos 979. Training application used all samples from the vec-file to train 0-stage and it can not get new positive samples for the next stage training because vec-file is over.
	
	The bug of traincascade is that it had assert() in such cases, but it has to throw an exception with error message for a user. It was fixed in r8913.
	
	-numPose is a samples count that is used to train each stage. Some already used samples can be filtered by each previous stage (ie recognized as background), but no more than (1 - minHitRate) * numPose on each stage. So vec-file has to contain >= (numPose + (numStages-1) * (1 - minHitRate) * numPose) + S, where S is a count of samples from vec-file that can be recognized as background right away. I hope it can help you to create vec-file of correct size and chose right numPos value.


5.加入IN的负样本数据，扩展后的svm训练了37分钟。满心欢喜以为炼成了神器，结果发现：
	明显过于严格了！结果FP (false positive) 很少，但MR(missing rate )也少！
6.今晚组会，师兄的提示：(a) 通过将正负样本再细分(如正脸，侧脸，背脸)，在检测的时候进行聚类 (b)利用帧间信息进行筛选

7.param for old svm : 2 32 1.01 2

//1101
git
1.
	The object store is designed to be efficiently copied during a clone operation as partof the mechanism that supports a fully distributed VCS.
	
	Git places only four types of objects in the object store: the blobs, trees, commits, and tags.

	The index is a temporary and dynamic binary file that describes the directory structure of the entire repository. 

	It’s important to see Git as something more than a VCS: Git is a content tracking system. First, Git’s object store is based on the hashed computation of the contents of its objects, not on the file or directory names from the user’s original file layout. 

2.cmake

//1102,homework
1.
	1)词法分析代码的主体结构。
	2)语法分析代码的主体结构。
	3)语法分析和词法分析的衔接方式。
	4)语法分析过程中的错误处理机制。
	
	仅需阅读和上述报告要点相关的部分,阅读过程中应设法将这部分源代码分离出来。PL/0 编译程序的符号表组织以及运行时存储组织相关内容,后续课程会在一定程度上涉及到,但在这次作业中不必关注。代码生成和目标机相关内容,不必关注。
	
	自注：可以考虑与lex.l以及parser.y的比较

2.
Chapter 1 excercise:
5th edition: 1,3,4,9,10,11,12,15,20,23.
4th edition: 1,3,4,10,11,12,14,17,25,35.

Chapter 2 excercise:
5th edition: 1,3,4,5,9,20,25,37,38,39,40,48.
4th edition: 1,3,4,5,9,20,28,41,42,43,44,54.
	

//1103
网络原理
1.<1.3>网络组织成一个层次栈，每一层都可以看作一个虚拟机
2.层的设计：除了尽可能减少层与层之间必须传递的信息量外，还要使得接口清晰（便于替换）
3.没有一个第n层以下的头会被传给第n层
4.协议和接口：第4层通信依赖第四层协议，但要通过调用3/4接口实现


当发送窗口和接收窗口的大小固定为 1 时,滑动窗口协议退化为停等协议。由于停等协议规定只有一帧完全发送成功后才能发送新的帧,因而只用一比特来编号就够了。

问题：由于停等协议要为每一个帧进行确认后才继续发送下一帧,大大降低了信道利用率,因此又提出了后退 n 协议。（发送窗口的大小为 k,接收窗口仍是 1）

选择重传的接受窗口不小于发送窗口吗？？

考试范围：感知器、SVM、SOM、Deep Learning、Recurrent Network
答疑时间：周四（11月7日）晚7:00-9:00
答疑地点：FIT 4-402  



//1110
《Hibernate in action 2》好书！
1.持久化
2.数据是独立的。数据比任何一个应用程序更长久。关系技术提供了一种在不同程序或同一程序的不同技术之间共享数据的方式
3.面向对象的领域模型和基于表格的关系模型，范式不匹配，传递闭包
4.映射粒度问题、同一性问题、数据关联问题、数据导航(效率)问题
5.持久层------DAO(Data Access Object) or ORM(对象关系映射)
6.[题外]用ant编译时2注意的两点：
	<javac   encoding="gbk">
	<path id="project.class.path">
		  <!-- Include our own classes, of course -->
		  <pathelement location="${class.root}" />
		  <!-- Include jars in the project library directory -->
		  <fileset dir="/usr/lib/java">
			<include name="*.jar"/>
		  </fileset>
	</path>
7.
8.


Eclipse GEF http://download.eclipse.org/tools/gef/updates/releases
Eclipse GMF http://download.eclipse.org/modeling/gmf/updates/releases/
Eclipse EMF http://download.eclipse.org/modeling/emf/updates/releases/
Google eclipse Plugin http://dl.google.com/eclipse/plugin/3.7
JBoss SOA http://download.jboss.org/jbosstools/updates/stable/indigo/soa-tooling/

yinfoo2013@126.com
abc***
APP ID：244132
APP KEY：d8a1098f69934c549833d51b0d64e018
Secret Key：fdcc4d190ca641c2b146273b1e2c1651

我真傻 真的.我单知道雪天是野兽在深山里没有食吃，会到村里来；我不知道春天也会有。



?useUnicode=true&amp;characterEncoding=utf-8



1.利用帧差法提取出前景。问题在于，对于基本不懂的人体，就会漏检一直。不过可以通过多帧帧差。采用增量式的帧差法，逐步修正。

2.利用已知背景进行背景剪除。不过这降低了系统的适应性和自动化水平。

3.一种基于多层背景模型的前景检测算法

4.backrecognize 基于opencv的背景建模,运动物体检测 Special ...



App Key：928469235
App Secret：18708fbd7f8d20781d503e6a8e207639
应用地址：http://okaa.tekla.com



近期项目年度总结，今天接到通知，需要几位SRT同学提供各自的总结材料。

请每位同学至少提供至少1页A4纸（电子版）总结资料，正常字体，行距。图片大小适中。

包括项目的最新进展情况，提供使用的相关理论的说明（可以参考现有资料），并（重要）提供当前可运行系统的截图、功能说明、相关图表等等。

非常重要，请务必在11月25日（下周一）前提交材料。



//1122,python Django

http://developer.51cto.com/art/201006/205314.htm
呈现页面仅仅完成了事情的一半，可能还不到一半。获得“页面源代码”会让您更进一步。要真正理解给定Web页面或与Web服务器的一系列交互的背后的原理，需要了解更多


http://djangobook.py3k.cn/chapter02/
Django 带有一个内建的轻量级 Web 服务器，可供站点开发过程中使用。我们提供这个服务器是为了让你快速开发站点，也就是说在准备发布产品之前，无需进行产品级 Web 服务器（比如 Apache）的配置工作。该开发服务器会监测代码变动并将其自动重载，这样一来，你可快速进行项目修改而无需作任何重启。


注意，该例中，我们将 current_datetime 视图函数作为对象传递，而不是调用它。这是 Python (及其它动态语言的) 的一个重要特性：函数是一级对象（first-class objects）， 也就是说你可以像传递其它变量一样传递它们。很酷吧？


在python中空的列表 ( [] )，tuple( () )，字典( {} )，字符串( '' )，零( 0 )，还有 None 对象，在逻辑判断中都为假，其他的情况都为真。


{% for %} 允许我们在一个序列上迭代。与Python的 for 语句的情形类似，循环语法是 for X in Y ，Y是要迭代的序列而X是在每一个特定的循环中使用的变量名称。每一次循环中，模板系统会渲染在 {% for %} 和 {% endfor %} 之间的所有内容。{% for %} 标签在循环中设置了一个特殊的 forloop 模板变量。这个变量能提供一些当前循环进展的信息


这个模板语言来源于World Online的开发经验和Django创造者们集体智慧的结晶。下面是关于它的一些设计哲学理念：

业务逻辑应该和表现逻辑相对分开 。我们将模板系统视为控制表现及表现相关逻辑的工具，仅此而已。模板系统不应提供超出此基本目标的功能。

出于这个原因，在 Django 模板中是不可能直接调用 Python 代码的。所有的编程工作基本上都被局限于模板标签的能力范围。当然， 是 有可能写出自定义的模板标签来完成任意工作，但这些“超范围”的 Django 模板标签有意地不允许执行任何 Python 代码。


在讲解了模板加载机制之后，我们再介绍一个利用该机制的内建模板标签： {% include %} 
到目前为止，我们的模板范例都只是些零星的 HTML 片段，但在实际应用中，你将用 Django 模板系统来创建整个 HTML 页面。这就带来一个常见的 Web 开发问题：在整个网站中，如何减少共用页面区域（比如站点导航）所引起的重复和冗余代码？
解决该问题的传统做法是使用 服务器端的 includes ，你可以在 HTML 页面中使用该指令将一个网页嵌入到另一个中。事实上， Django 通过刚才讲述的 {% include %} 支持了这种方法。但是用 Django 解决此类问题的首选方法是使用更加简洁的策略—— 模板继承 。


Django 的模板继承系统解决了这些问题。你可以将其视为服务器端 include 的逆向思维版本。你可以对那些 不同 的代码段进行定义，而不是 共同 代码段。

由于 C 由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），Django 也被称为 MTV 框架 。在 MTV 开发模式中：


objects 是干什么的？技术上，它是一个 管理器（manager） 。 管理器 将在附录B详细描述，在这里你只要知道它处理有关数据表的操作，特别是数据查找。所有的模型都自动拥有一个 objects 管理器；你可以在想要查找数据时是使用它。




python manage.py sqlall messageboard
python manage.py syncdb


Publisher.objects.filter(country="U.S.A.", state_province="CA")
Publisher.objects.filter(name__contains="press")
象Python自己一样，Django也使用 双下划线来做一些小魔法，这个 __contains 部分会被Django转换成 LIKE SQL语句 :WHERE name LIKE '%press%'
Publisher.objects.get(name="Apress Publishing")
Publisher.objects.order_by("name")
Publisher.objects.all()[0]


Meta是什么？Django使用内部类Meta存放用于附加描述该模型的元数据。 这个类完全可以不实现，不过他能做很多非常有用的事情。

(Python is based on Promise ?)


注意在 request.GET 中使用了 get() 方法，这可能让大家不好理解。这里的 get() 是每个python的的字典数据类型都有的方法。使用的时候要小心：假设 request.GET 包含一个 'q' 的key是不安全的，所以我们使用 get('q', '') 提供一个缺省的返回值 '' (一个空字符串)。如果只是使用 request.GET['q'] 访问变量，在Get数据时 q 不可得,可能引发 KeyError .

在这个查询中， icontains 使用SQL的 LIKE 操作符，是大小写不敏感的。

表单的action是 . ， 表示当前的URL。这是一个标准的最佳惯常处理方式：不使用独立 的视图分别来显示表单页面和结果页面；而是使用单个视图页面来处理表单并显示搜索结果。

Web应用安全的金科玉律是从不要相信进来的数据，所以验证是必需的。

最有意思的一行是 {{ form.as_table }}。form是ContactForm的一个实例，我们通过render_to_response方法把它传递给模板。as_table是form的一个方法，它把form渲染成一系列的表格行(as_ul和as_p也是起着相似的作用)。请注意：<table>和<form>标签并没有包含在内；我们需要在模板里定义它们，这给予我们更大的控制权去决定form提交时的行为。Label元素是包含在内的，令访问性更佳（因为label的值会显示在页面上）。

forms框架把每一个字段的显示逻辑分离到一组部件（widget）中。每一个字段类型都拥有一个默认的部件，我们也可以容易地替换掉默认的部件，或者提供一个自定义的部件。


修改form的显示的最快捷的方式是使用CSS。错误的列表可以做一些视觉上的增强，<ul>标签的class属性为了这个目的。




http://stackoverflow.com/questions/4336713/django-switching-to-jinja2

While it's just my own experience, I found converting from Django to Jinja2 to be worthwhile for the following reasons:

The design and implementation of Jinja2 seemed more intuitive to me, both as a software developer and template designer;
Jinja2 is more extensible (at least in the ways I've sought to extend my template engine);
Jinja2 is more flexible in terms of permitting logic-code to be run (but it gives you enough rope to hang yourself with);
Jinja2 is regarded as significantly faster (though I haven't done any benchmarks, this is always subject to debate depending on the tests used, and in any event largely irrelevant in the total wait time for a query that has to do DB lookups);
Jinja2 gives significantly more helpful error output than Django (i.e. traces to the line number in the template where the error occurred). Edit: According to Dor's comment, Django gives helpful error messages that point to the line and context of a problem, much like Jinja2.
If you haven't had any trouble with Django's template engine, Jinja2's should feel relatively intuitive, if perhaps a bit more polished (or it did to me, at any rate). As well, I found the Coffin project well written and reasonably helpful when converting from Django to Jinja2 – both for its use, and as an example of how to extend Jinja2.

All that being said, Django's template engine is solid and quite capable for most tasks. I believe it's being improved in the next revision of Django, and there is quite a lot of effort to add to its capabilities by quite a number of dedicated developers. As a result there are no worries of it becoming unsupported in the near to medium-term future.

Again, that's just my experience, for what it's worth – I hope that's helpful.

//1125


data负责和磁盘打交道

create 如果在磁盘中的话。。也可以在内存中buffer

train：分析一批sql语句，确定索引的建立策略。索引可以先存在磁盘上。


load：先存buffer，满了再存磁盘。如insert。

preprocess：如：。。。where a.s=b.s 且两者都不是主键时，可以建索引。
	又如，对于join操作，知道join的顺序优化。
	又如，对于范围判定，可以事先排序。
	查询优化。


最终,如果一个Form实体的数据是合法的,它就会有一个可用的cleaned_data属性。 这是一个包含干净的提交数据的字典。 Django的form框架不但校验数据,它还会把它们转换成相应的Python类型数据,这叫做清理数据。

(r'^somepage/$', views.method_splitter, {'GET': views.some_page_get, 'POST': views.some_page_post)}

# views.py
from django.http import Http404, HttpResponseRedirect
from django.shortcuts import render_to_response
def method_splitter(request, GET=None, POST=None):
	if request.method == 'GET' and GET is not None:
		return GET(request)
	elif request.method == 'POST' and POST is not None:
		return POST(request)
	raise Http404
def some_page_get(request):
	assert request.method == 'GET'
	do_something_for_get()
	return render_to_response('page.html')
def some_page_post(request):
	assert request.method == 'POST'
	do_something_for_post()
	return HttpResponseRedirect('/someurl/')


增加额外的manager方法是为模块添加表级功能的首选办法。 (至于行级功能,也就是只作用于模型对象实例
的函数,一会儿将在本章后面解释。)








/*
泓一大师语录
不让古人是谓有志，不让今人是谓无量。 
? 
有才而性缓，定属大才。有智而气和，斯为大智。 
? 
以恕已之心恕人则全交。以责人之心责已则寡过。 
? 
在事者，当置身利害之外。建言者，当设身利害之中。 
? 
处逆境，必须用开拓法。处顺境，心要用收敛法。 
? 
喜闻人过，不若喜闻已过。乐道己善，何如乐道人善？ 
? 
临事须替别人想，论人先将自己想。 
? 
静坐，常思已过。闲谈，莫论人非。 
? 
对失意人，莫谈得意事。处得意日，莫忘失意时。 
? 
不尽人情，举足尽是危机。不体物情，一生俱成梦境。 
? 
不见已短，愚也；见而护，愚之愚也。不见人长，恶也；见而掩，恶之恶也。 
? 
德盛者其心平和，见人皆可取，故口中所许可者多。德薄者，其心刻傲，见人皆可憎， 
故目中所鄙弃者众。 
? 
智者达观三世，念念知非；愚人只重目前， 裤吭 恶。 
? 
步步占先者，必有人以挤之。事事争胜者，必有人以挫之。 
? 
以情恕人，以理律已。 
? 
恶，莫大于纵已之欲。祸，莫大于言人之非；施之君子，则丧吾德，施之小人，则杀吾 
身。 
? 
事当快意处，须转。言到快意时，须住。殃咎之来，未有不始于快心者。故君子得意而 
忧，逢喜而惧。 
? 
不为自己求安乐，但愿众生得离苦。（《华严经》） 
? 
盛喜中，勿许人物。盛怒中，勿答人书。喜时之言，多失信。怒时之言，多失体。 
? 
人生最不幸处，是偶一失言而祸不及；偶一失谋而事幸成；偶一恣行而获小利；后乃视 
为常故，而恬不为意。则莫大之患，由此生矣。 
? 
以虚养心，以德养身，以仁养天下万物。以道德养天下万世。 
? 
气，忌盛。心，忌满。才，忌露。 
? 
自处超然，处人蔼然。无事澄然，有事斩然。得意淡然，失意泰然。 
? 
以淡字交友，以聋字止谤，以刻字责已，以弱字御侮。居安，虑危。处治，思乱。 
? 
不为外物所动之谓静。不为外物所实之谓虚。 
? 
意粗，性躁，一事无成。心平，气和，千祥骈集。 
? 
公，生明。诚，生明。从容，生明。 
公生明者，不蔽于私也。诚生明者，不杂以伪也。从容生明者，不淆于惑也。 
? 
心志要苦，意趣要乐，气度要宏，言动要谨。 
? 
事能常足，心常惬。人到无求，品自高。 
? 
静能制动，沉能制浮，宽能制褊，缓能制急。 
? 
人好刚我以柔胜之，人好术我以诚感之。 
? 
处事大忌急躁。急躁则自顾不暇，何暇治事？ 
? 
必有容，德乃大。必有忍，事乃济。 
? 
知足常乐，终生不耻。知止常止，终生不辱。 
? 
宜静默，宜从容，宜谨严，宜俭约。 
? 
谦退是保身第一法，安祥是处事第一法，涵容是待人第一法，恬淡是养心第一法。 
? 
心术，以光明笃实为第一。容貌，以正大老成为第一。言语，以简重真切为第一。平生 
无一事可瞒人，此是大快。 
? 
律已，宜带秋气。处世，须带春风。 
? 
人褊急，我受之以宽宏。人险仄，我带之以坦荡。 
? 
修己，以清心为要。涉世，以慎言为先。 
? 
心不妄念，身不妄动，口不妄言，君子所以存诚。内不欺已，外不欺人，上不欺天，君 
子所以慎独。 
? 
物，忌全胜。事，忌全美。人，忌全盛。 
? 
安莫安于知足，危莫危于多言。 
? 
学一分退让，讨一分便宜。增一分享用，减一分福泽。 
? 
不自重者，取辱。不自畏者，招祸。 
? 
处难处之事愈宜宽。处难处之人愈宜厚。处至急之事愈宜缓。 
? 
何以息谤？曰："无辩"。何以止怨？曰："不争"。人之谤我也，与其能辩，不如能宽。 
人之侮我也，与其能防，不如能化。 
? 
一动于欲，欲迷则昏。一任乎气，气扁则戾。 
? 
一念疏忽是错起头，一念决裂是错到底。 
? 
不让古人是谓有志，不让今人是谓无量。 
? 
动若不止，止水皆化波涛；静而不扰，波涛悉为止水。水相如此，心境亦然。不变随缘 
，真如当体成生灭；随缘不变，生灭当体即真如。一迷即梦想颠倒，触处障碍；一悟则 
究竟涅盘，当下清凉。 
? 
人生多艰，不如意事常八九，吾人于此当镇定精神，胸中必另有一番境界。 
? 
省察以后，若知是过，即力改之。诸君应知：改过之事，乃是十分光明磊落，足以表示 
伟大之人格。故子贡云："君子之过也，如日月之食焉。过也人皆见之，更也人皆仰之。 
"又古人云："过而能知，可以谓明；知而能改，可以即圣"。诸君可不勉乎。 
? 
以和气迎人，则 咯l灭。以正气接物，则妖氛消。以浩气临事，则疑畏释。以静气养身 
，则梦寐恬。 
? 
刘念台云："学者遇事不能应，终是此心受病处，只有炼心法，更无炼事法。炼心之法， 
大要只是胸中无一事而已。无一事，乃能事事，此是主静功夫得力处。" 
? 
离贪嫉者，能净心中贪欲云翳，犹如夜月，众星围绕 。（《理趣六波罗密多经》） 
? 
行少欲者，心则坦然无所忧畏，触事有余，常无不足。（《佛遗教经》） 
? 
世出世事，莫不成于慈忍，败于忿躁。故君子以慈育德，以忍养情。德育，天地万物皆 
归我春风和气之中；情养，乖戾妖孽皆消于光天化日之下；然后以之自成，则为净满自 
尊；以之成物，则为慈力悲仰。仅一念瞋起，百万不过积恚所招；世局土崩，皆无远虑 
所致；士生斯世，宜如何努力以障狂澜也。 
? 
人情应酬可省则省，不必迁就勉强敷衍。 
? 
佛子，菩萨摩诃萨已修初地，欲入第二地当起十种深心。所谓正直心、柔轻心、堪能心 
、调伏心、寂静心、纯善心、不杂心、无顾恋心、广心、大心。菩萨以此十心，得入第 
二离垢地。" 
? 
以仁义存心，以忍让接物。 
? 
小人乐闻君子之过。君子耻闻小人之恶。此存心厚薄之分，故人品因之而别。 
? 
欲论人者，先自论。欲知人者，先自知。 
? 
严着此心以拒外诱，须如一团烈火，遇物即烧。宽著此心以待同群，须如一片春阳，无 
人不暖。 
? 
视人之善，犹己之善。视己之善，犹人之善。念念同观，亘古无间。法界偕游四德城， 
方满最初宏誓愿。 
视人之恶，犹己之恶。视己之恶，犹人之恶。猛省力除，无令愧怍。法界众生三毒除， 
彼我同归无上觉。 
视人之乐，犹已之乐。视已之乐，犹人之乐。所欲与共，嫉妒永却。法界同欣法喜充， 
不向偏空寻略约。 
善恶性具，善恶性空。何喜何怒，如空御风。默持机咸，妙应无穷。大圆镜智照不疲， 
岂似权乘作意通。（《四无量心铭》） 
? 
一、杀生--短命多病 
二、偷盗--贫穷。其财不得自在 
三、邪淫--妻不贞良，不得随意眷属 
四、妄言--多被诽谤，为他所诳 
五、两舌--眷属乖离，亲族弊恶 
六、恶口--常闻恶声，言多诤讼 
七、绮语--言无人受，语不明了 
八、悭贪--心不知足，多欲无厌 
九、嗔恚--常被他人责长短，恒被他所恼害 
十、邪见--生邪见者，其心谄曲。 
以上为十恶业。反之，则为十善。 
? 
因是观之，吾人欲得诸事顺遂身心乐业之果报者，应先力修善业，以种善因；若唯一心 

求好果报而决不肯种少许善因，是为大误。譬如农夫欲得米谷而不种田，人皆其为愚也 
。故吾人欲诸事顺遂身心安乐者，须努力培植善因。将来或迟或早必得良好的果报。古 
人云：祸福无不自己求之者，即是此意。 
? 
余五十年改过迁善之事，今且举十条为常人所不注意者，先与诸君言之：一、虚心。二 
、慎独。三、宽厚。四、吃亏。五、寡言。六、不说人过。七、不文已过。八、不覆己 
过。九、闻谤不辩。十、不瞋。 
? 
瞋习最不易除。古人云："二十年治一怒字，尚未消磨得尽。"但我等亦不可不尽力对治 
也。 
*/

//new ubuntu,2013-12-07
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._


//12-08 ,DSP
			2.1
1.函数的正交：理解爲向無限維的擴展
2.计算三角函数展开的系数时，注意1/T是由于三角函数的范数产生的
3.注意有限范围（a，b）和无穷范围的意义及其转换
4.注意三角函数的w是取决于T的，这就保证了正交函数集

			2.2
5.关于FS的讨论：对于FS，gn（t）是周期的，对于FS在区间内外均可，对于非周期信号f（t），应该在{gn}的一个周期内
6.[典型FT] 阶跃信号u(t)不满足绝对可积条件，但是存在FT
7.[FT性质] 注意几个交叉：反褶共轭、压扩（尺度）、0与面积、脉宽带宽、时移特性、频移特性
8.[FT性质] 卷积定理

			2.3
9.中心：如何求周期信号的FT？
10.（1）通过非周期信号的FT。利用：周期重复公式 sigmod（f(t-nT)），以及FT的齐次性、时域平移特性，
			最终归结为sigmod(e^-jwnT)
	（2） （f(t-nT)）用搬移函数表示（卷积），转化为频域乘积，解冲击信号的FT，
			归结为sigmod(e^-jwnT)
	（3）其实（2）的实践，最终将一个普通周期信号的FT转化为一个特殊周期函数的FT
	
11.（4）通过周期信号的FS：很简单，就是sigmod符号的位置变化。物理意义：由冲击串组成
	（5）此时，再回到（2），得到普通周期信号的另一种表示：对单周期函数抽样。
		以上两种表示的联系：Fn= F0(nw)/T，即 周期函数傅里叶级数展开的系数 正比于 单周期FT频谱密度值

12.自注：F函数是什么？一方面，它是谱函数。为什么会是冲击串呢？
13.时域抽样---

	抽样定理：”超出三界外，不在五行中“。基本原理是傅里叶变换对。 dw = (ws-2wm)
		(1) 信号是频带受限的;
		(2) 采样率至少是信号最高频率的两倍。
	问题：而实际处理信号时,信号都是有限长的,因此频带并不是有限的!抽样将会导致信号的频谱发生混叠。
		在实际处理信号时,通常需要将信号通过一个模拟滤波器进行处理,去掉信号中的高频成分,使信号能够满足采样要求,然后再进行采样。
	信号恢复：将抽样信号通过截止频率为wc放大倍数为Ts的低通滤波器
14.频域抽样：思想---从傅里叶变换对的角度看，FT也是信号。

15.时域和频域：周期性和连续性的交叉对应

			3.1
16.第三章要解决的问题是如何得到抽样信号（离散，序列）的FT频谱。以及截取信号与FT频谱的关系。
17.注意一个问题：实际信号一般难以用函数式表示，因此难以用解析式的方式得到连续谱。因此也就难以采用频域采样。
18.DTFT：连续时间信号信号f(t)频谱的数值近似
	仅使用抽样值的序列f(nT),即可计算出理想抽样信号的频谱密度函数。
	序列值求出的频谱密度函数仍然是周期函数。
19.数字信号：时间间隔归一的离散信号(序列)，对应的DTFT归一化频谱为"数字频谱".
20.能计算频域中频谱密度函数的卷积吗 ???——————周期函数的“卷积”定义。圆周卷积:积分限制在一个周期内。



//1215
嗯，情况都包括了。另外，能不能把最后一部分的各种遮挡再具体一些？同时写一下每部分具体要拍摄的视频的长短和拍摄段数以及每段里面人的个数变化。
祝好



//12-08 ,db
数据库系统全书，chap11
1.数据结构的基础假设是RAM模型（随机访问模型），数据库是基于磁盘模型。应该尽量减少主存与二级存储器之间的交互
2.计算的IO模型：块访问次数（读或写）的次数近似于算法的时间（毫秒）
3.主存中的索引不求精致，但求有效。“即便采用最笨的线性搜索。。。”把工作都放在贮存中。
数据库管理系统原理与设计（第3版）
4.什么是索引技术？什么事缓冲区管理器？为什么要连续存储、读取？
5.记录文件是DBMS的一个重要抽象
6.卧槽：DBMS的体系结构！！！“文件层将文件中的记录存储于一组磁盘页，并负责跟踪这些页”
7.“索引是在磁盘上的组织数据记录的一种数据结构，用于优化某类数据检索”。聚簇索引（文件）与非聚簇索引，主索引与次索引
8.索引的数据结构：哈希、B树。duiyuB树，磁盘IO等于树的高度。
9.文件组织：“堆文件假设”
10.代价模型：读写一个磁盘页的时间D，文件所需（无浪费）的磁盘页数B
11.DBMS最底层：磁盘空间管理器。
	实现页-块的映射和管理，隐藏操作系统硬件，提供基于页的服务。
	实现：磁盘块位图用于跟踪，（简单地）基于操作系统提供的文件系统
12.磁盘与主存的交换层：缓冲区管理器。
	替换策略：<pin-count,dirty>,LRU（最近最少使用）、时钟替换。
	与操作系统的缓冲区（虚存）对比：预测引用模式，强制写回
13.记录文件：页链表法、页目录法
14.页格式：槽rid=<pageid,slotnum>，槽目录
15.记录格式：
16.
17.
18.

//12-09,Maven实战
1.什么是构建
2.maven的中央仓库的概念
3.技巧：创建符号链接以便于升级
4.
5.
6.
7.
8.


/*
soory my sword.
修改密码：34796

存储还能用吗？？？？？

显卡还能用吗？？？？？

声卡还能用吗？？？？？

键盘还能用吗？？？？？

风扇还能用吗？？？？？

*/


//1213,dbms
1.sql语句解析，替换直接从schema加载数据;


//1215.倚天屠龙记，至赵敏出，约50%。

//1217,周二，复习计原存储一章












1.替换Lexer.l为PA1中的
2.替换PArser.y为PA1中的
3.BaseLxer中添加Double
4.Tree.java 中添加Double、Repeat等属性

	至此，测试用例中可以对5个。
5.BaseType.java 中增添Double
6.BuildSym.java 中增添Double、visitRepeatLoop
7.TypeCheck.java 中增添Double，补全checkCallExpr
	至此，测试用例中只有miscerror.decaf     ERROR!
8.在BadPrintArgError错误信息中添加double
	至此，测试用例全部通过


//1223,软工大作业展示
泡泡堂1
	cocos2dx
	googletest单元测试
	多人在线游戏的同步：指令转发（客户端、gaoxaio、不稳定）、状态同步（服务端，稳定）、
	通信：C++原生socket，javascript
泡泡堂2
	架构：负载均衡——4个工程分别负责注册等，也便于分工。工程之间通过通信来交流而不是函数接口。
	流畅性：视觉要求——每秒30帧。网络延迟在50ms，所以需要美妙发10次。需要补帧利用惯性，由于时间很短，即使游戏者更改，也不会太突出。
泡泡堂3
	没有用游戏引擎。动画的使显示通过状态机实现。
	内核原型中位于服务器，通过传动作而不是全局信息来同步解决卡。需要客户端也要有内核。
图书馆1
	数据库与数据处理-服务器处理逻辑-用户网站-桌面管理员
	bootstrap-struts-json-c#
	为什么是struts-hibernate的重框架？软工课，体会一个正规项目的开发
	为什么website+native app？体会多重框架
	文档的重要性：团队合作，写了是用来看的;协同编辑;多milestone;分工-多交流-即使调整。
	关于开发框架：struts改ruby？实际上应该关注框架的设计思想，而不是使用方法。
卡牌1 
	cardmaster
	游戏界面渲染、服务器、游戏逻辑。
	服务器：不能请求-应答的简单模型;ajax？不行;数据推到前台的技术——commit长连接
	游戏逻辑：状态机：开始-发牌-教派-出牌-打算-结束
	前端：html5技术处理video，遗憾在于在没有很多的库。标签页形式
		casualjs;游戏引擎
		impress：3D
		jquery
		backbone
		
		chrome
		fiddler调试
		
		前端：没有教程，通过看别人项目学习，学了些江湖气。
卡牌2
	trumponline
	GWT框架：将java转javascript
	规则集设计
卡牌3：
	go语言
	revel框架
	规则集：状态机-太庞大;Labview图形化界面编程，复杂;文本化，
	
infohub1：
	dirby数据库：基于apache
	OAuth2.0：接口比较低端。直接使用weiboforjava源代码
	前台：bootstrap
	RSS解析：Rome
	jsoup：解析http
	
infohub2：
	
infohub3：
	git9：uknow开放源码
	unknow->uknow
secoder1：
	任务系统：众包;
	成绩评定系统：组内互评;
	讨论系统：
	框架：
		flask+jinja2
		WTForms

//http://www.cnblogs.com/suger/archive/2011/11/10/2243954.html
	
	命令 	描述 
	ABOR	中断数据连接程序
	ACCT <account>	系统特权帐号
	ALLO <bytes> 	为服务器上的文件存储器分配字节
	APPE <filename>	添加文件到服务器同名文件
	CDUP <dir path>	改变服务器上的父目录
	CWD <dir path>	改变服务器上的工作目录
	DELE <filename>	删除服务器上的指定文件
	HELP <command>	返回指定命令信息
	LIST <name>	如果是文件名列出文件信息，如果是目录则列出文件列表
	MODE <mode>	传输模式（S=流模式，B=块模式，C=压缩模式）
	MKD <directory>	在服务器上建立指定目录
	NLST <directory>	列出指定目录内容
	NOOP	无动作，除了来自服务器上的承认
	PASS <password>	系统登录密码
	PASV	请求服务器等待数据连接
	PORT <address>	IP 地址和两字节的端口 ID
	PWD	显示当前工作目录
	QUIT	从 FTP 服务器上退出登录
	REIN	重新初始化登录状态连接
	REST <offset>	由特定偏移量重启文件传递
	RETR <filename>	从服务器上找回（复制）文件
	RMD <directory>	在服务器上删除指定目录
	RNFR <old path>	对旧路径重命名
	RNTO <new path>	对新路径重命名
	SITE <params>	由服务器提供的站点特殊参数
	SMNT <pathname>	挂载指定文件结构
	STAT <directory>	在当前程序或目录上返回信息
	STOR <filename>	储存（复制）文件到服务器上
	STOU <filename>	储存文件到服务器名称上
	STRU <type>	数据结构（F=文件，R=记录，P=页面）
	SYST	返回服务器使用的操作系统
	TYPE <data type>	数据类型（A=ASCII，E=EBCDIC，I=binary）
	USER <username>>	系统登录的用户名
	
	
	FTP状态代码说明 
	110 Restart marker reply. In this case, the text is exact and not left to the particular implementation; it must read: MARK yyyy = mmmm where yyyy is User-process data stream marker, and mmmm server's equivalent marker (note the spaces between markers and "=". 
	重新启动标志回应。这种情况下，信息是精确的并且不用特别的处理；可以这样看：标记 yyyy = mmm 中 yyyy是 用户进程数据流标记，mmmm是服务器端相应的标记（注意在标记和等号间的空格） 
	120 Service ready in nnn minutes. 
	服务在NNN时间内可用 
	125 Data connection already open; transfer starting. 
	数据连接已经打开，开始传送数据. 
	150 File status okay; about to open data connection. 
	文件状态正确，正在打开数据连接. 
	200 Command okay. 
	命令执行正常结束. 
	202 Command not implemented, superfluous at this site. 
	命令未被执行，此站点不支持此命令. 
	211 System status, or system help reply. 
	系统状态或系统帮助信息回应. 
	212 Directory status. 
	目录状态信息. 
	213 File status. 
	文件状态信息. 
	214 Help message.On how to use the server or the meaning of a particular non-standard command. This reply is useful only to the human user. 
	帮助信息。关于如何使用本服务器或特殊的非标准命令。此回复只对人有用。 
	215 NAME system type. Where NAME is an official system name from the list in the Assigned Numbers document. 
	NAME系统类型。 
	220 Service ready for new user. 
	新连接的用户的服务已就绪 
	221 Service closing control connection. 
	控制连接关闭 
	225 Data connection open; no transfer in progress. 
	数据连接已打开，没有进行中的数据传送 
	226 Closing data connection. Requested file action successful (for example, file transfer or file abort). 
	正在关闭数据连接。请求文件动作成功结束（例如，文件传送或终止） 
	227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). 
	进入被动模式 
	230 User logged in, proceed. Logged out if appropriate. 
	用户已登入。 如果不需要可以登出。 
	250 Requested file action okay, completed. 
	被请求文件x作成功完成 
	257 "PATHNAME" created. 
	路径已建立 
	331 User name okay, need password. 
	用户名存在，需要输入密码 
	332 Need account for login. 
	需要登陆的账户 
	350 Requested file action pending further information 
	对被请求文件的x作需要进一步更多的信息 
	421 Service not available, closing control connection.This may be a reply to any command if the service knows it must shut down. 
	服务不可用，控制连接关闭。这可能是对任何命令的回应，如果服务认为它必须关闭 
	425 Can't open data connection. 
	打开数据连接失败 
	426 Connection closed; transfer aborted. 
	连接关闭，传送中止。 
	450 Requested file action not taken. 
	对被请求文件的x作未被执行 
	451 Requested action aborted. Local error in processing. 
	请求的x作中止。处理中发生本地错误。 
	452 Requested action not taken. Insufficient storage space in system.File unavailable (e.g., file busy). 
	请求的x作没有被执行。 系统存储空间不足。 文件不可用 
	500 Syntax error, command unrecognized. This may include errors such as command line too long. 
	语法错误，不可识别的命令。 这可能是命令行过长。 
	501 Syntax error in parameters or arguments. 
	参数错误导致的语法错误 
	502 Command not implemented. 
	命令未被执行 
	503 Bad sequence of commands. 
	命令的次序错误。 
	504 Command not implemented for that parameter. 
	由于参数错误，命令未被执行 
	530 Not logged in. 
	没有登录 
	532 Need account for storing files. 
	存储文件需要账户信息 
	550 Requested action not taken. File unavailable (e.g., file not found, no access). 
	请求x作未被执行，文件不可用。 
	551 Requested action aborted. Page type unknown. 
	请求x作中止，页面类型未知 
	552 Requested file action aborted. Exceeded storage allocation (for current directory or dataset). 
	对请求文件的x作中止。 超出存储分配 
	553 Requested action not taken. File name not allowed 
	请求x作未被执行。 文件名不允许 
	这种错误跟http协议类似，大致是： 
	2开头－－成功 
	3开头－－权限问题 
	4开头－－文件问题 
	5开头－－服务器问题


	/*
	 err = ftpclient.c_download(
	 "/home/chunk/workspace/c++/tmp/r_dltest.txt",
	 "/home/chunk/workspace/eclipse/myftp_c/tmp/l_dltest.txt"
	 );
	 if (err) {
	 puts("download failed");
	 exit(-1);
	 }
	 puts("download ok");
	 err = ftpclient.c_upload(
	 "/home/chunk/workspace/eclipse/myftp_c/tmp/l_uptest.txt",
	 "/home/chunk/workspace/c++/tmp/newdir/", "r_uptest.txt");
	 if (err) {
	 puts("upload failed");
	 exit(-1);
	 }
	 puts("upload ok");

	 err = ftpclient.c_quit();
	 if (err) {
	 puts("quit failed");
	 exit(-1);
	 }
	 puts("you quit");
	 */


//1224
0.疑问：关于观察者模式
1.增加PA1和PA2的内容，注意：修改了basetype以保证double，否则会改很多地方，比较麻烦
2.注意到助教已经把PA2部分内容补全了，于是为了方便以及防止出现新的冲突，就没有merge进自己的代码
2.运行cleantree，。。。

	至此，
		indexout.decaf      OK :)
		neglength.decaf     OK :)
	
3.对比输出和原PA3包中的正确输出，确定目标是FUNCTION的翻译，主要是补全运行时库调用的翻译
4.修改print，大部分都对了。
	至此，
		casterror.decaf     ERROR!
		math.decaf          ERROR!
		queue.decaf         ERROR!
		stack.decaf         ERROR!
		t4.decaf            ERROR!

5.接下里解决for循环分。
6.添加repeat-until。

	至此，只有casterror.decaf和t4.decaf 报错。
	
7.记得网络学堂有同学指出需要继承break。添加break。t4仍然不通过。查看输出，发现在visitIdent时出现NullPointerException异常。经过一番查找、替换、试验，最终锁定问题：虽然助教在typecheck大部分已经补全，但没有repeat-until。添加repeat。t4.decaf通过。
8.补全visitTypeCast。casterror.decaf通过。

	至此，所有测例（包括blackjack）通过。
	
9.关于VTable的还原，参考网络学堂@许建林同学的建议，去除VTable的parent成员。然后去除Mips、Translater、TransPass1涉及VTable.parent的部分。修改之后，测例仍能通过。

/*
 * 突然想就此打住。换一条路。也许会有所不同。
*/




//1226.读BT
1.BT：<key，data>水平。向BT*page隐藏键值对的细节。如getentryfrombytes、getbytesfromentry、printpage（debug）
2.
page：定义data[]
HFpage:细化data[]的结构，如增加说明头部。定义了dump、insert、delete等重要操作。注意slot的意义。（就是一张页中的目录）
	insert的策略是：无论如何都要新开辟一块数据区，如果有空闲slot，则令其指向这块新空间否则新建slot。
	delete时同时删除数据空间！然后将所有左边的数据右移。
	（注意：slot和usedPtr是相向生长的）	
tuple：元组。封装一条记录。
BTSortedPage：继承自HFPage，对slot进行排序。
BTIndexPage：
BTLeafPage：





FrameDesc：帧描述类，描述缓冲池中的每一页。构成frametable（就是缓冲池中的目录）
BufHTEntry：哈希表项，是一个链表单元，描述缓冲池中的每一页
BufHashTbl：哈希表，由哈希表项的链表构成。描述缓冲池中的每一页，容纳20个桶。
	插入一页时，必须同时指定它的帧描述对象，将它们构成的哈希表项插在对应的桶的桶顶。
Clock：时钟替换。
BufMgr：采用双目录结构（frame目录，hash目录），另外包含一个替换管理器replacer。
	注意，pin与unpin交由replacer，最终是由frametable实现。（注意，如果有替换发生，需要另一个表hashtable同步）



https://bugs.eclipse.org/bugs/show_bug.cgi?id=356057
额。。。。。。

Try to rebuild the index (Right click on the project -> Index -> Rebuild)



强大的sscanf


put /home/chunk/workspace/eclipse/myftp_c/tmp/l_uptest.txt /home/chunk/workspace/c++/tmp/new/ up


/*
//1226,软工复习
1.cost：4-2-4比例
	A recommended distribution of effort across the software process is 40% (analysis and design), 20% (coding), and 40% (testing)‏

2.项目管理：人是关键。
	Scheduling。
	Defining a Task Set。
	Task Network和关键路径CPM 。
	Timeline Chart
	Basic Principles for Project Scheduling：Compartmentalization，Interdependency，Time allocation，Effort validation，Defined responsibilities，Defined outcomes，Defined milestones，
，
3.Software Process and Project
	软件生命周期：
		Requirements
		Specification (Analysis)
		Design
		Implementation
		Integration
		Maintenance
		Retirement

		“The quality of a software system is governed by the quality of the process used to develop and evolve it.”		-- Watts Humphrey（软件质量之父，提出了软件能力成熟度模型，即SEI CMM，5级）

	Software Process Models：（注意一下位置;Software Process Spectrum）
		Waterfall	:W. Royce，1970,（不足。。。Building software is by nature an iterative social learning process）
		Evolutionary	：Incremental Development，Spiral（螺旋）
		RUP: Rational Unified Process（统一软件开发过程）？？？？？？？？？？
		SEI CMM，5级
		Agile Alliance
			Individual and interactions over processes and tools 
			Working software over comprehensive documentation
			Customer collaboration over contract negotiation
			Responding to change over following a plan
			
			Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
			Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.
			Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale. 
			face-to-face conversation
			。。。
			（感觉敏捷开发是为天才和受虐狂定做的）
4.Requirements Engineering 
	but what you don’t understand is what I said is not what I mean.”
	Why requirements engineering is critical?
		Software requirements defects are the most expensive
		
	What are the key issues of requirements engineering?
		correct, complete, consistent, and verifiable. 
		The acquisition, analysis, specification, validation, and management of software requirements
		(采集，分析，规范，验证和管理)
		Layers of Software Requirements:
			Business requirements
			User requirements
			System requirements
			Software specification(Written for developers.)
			
		Functional	
			Functional requirements/功能性
			
			Non-functional requirements(Define system properties and constraintse.g. reliability, response time and storage requirements. Constraints are I/O device capability, system representations, etc./ a particular CASE system, programming language or development method?Requirements which arise from factors which are external to the system and its development process e.g. interoperability requirements, legislative requirements, etc.)适用性，重点不在软件功能属性，而在于软件其他属性
				Product requirement
				Organisational requirement
				External requirement
				
				Non-functional requirements may be more critical than functional requirements. If these are not met, the system is useless
			Domain requirements
					
		Specification（规范）		
			
	What are the process and activities of requirements engineering?
		采集，分析，规范，验证和管理。在此之前先进行可行性研究。
		（关于SRS：在做SRS的时候，一定要明确要描述的对象是SRS的整体。也就是说做整个软件的SRS时，描述的对象是整个软件，在做子系统的SRS时，描述的对象时整个子系统。我们要把这个软件，或者这个软件子系统当成一个黑盒子，具体分析它与外界的接口和它内部所要完成的功能。）
		Requirements Completeness and Consistency：
			In principle, requirements should be both COMPLETE and CONSISTENT
			In practice, it is impossible to produce a complete and consistent requirements document.
			
		Requirements Validation
			Requirement review
				Verifiability
				Comprehensibility
				Traceability
				Adaptability
				
				Conflicts
				contradictions
				errors
				omissions（遗漏）
		Requirements Management	
			traceability
				Source traceability：Links from requirements to stakeholders who proposed these requirements
				Requirements traceability：Links between dependent requirements
				Design traceability：Links from the requirements to the design
			changes
				Problem Analysis and Change Specification
				Change Analysis And Costing
				Change Implementation
						
5.UML Use Case Modeling
	Requirements Elicitation
		Focus on the WHAT, not the HOW
		Keep the details of the design (Which you don’t know yet!!) out of the use case
	Uniform Modeling Language (UML)
		OOAD（Object Orient Analysis Design，面向对象的分析和设计）
	Three Amigos
		Booch (Grady Booch) & 
		OMT   (Janes Rumbaugh) & 
		OOSE (Ivar Jacobson)
		OMG: Object Management Group（对象管理组织）
	Architecture: 4+1 view：
		Design
		Implementation
		Process
		Deployment
		Use case
	Actors & Use Cases & System
		Setting System Boundary
		Identifying Actors
		Use Case Scenario
			Uses cases are actions that a user takes on a system
			focuses on interaction, not internal system activities
			takes into account the actor's point of view, not the system's
			
				None of these requirements should be represented directly in a use case：
					Order cost = order item costs * 1.06 tax.
					Promotions may not run longer than 6 months.
					Customers only become Preferred after 1 year.
					A customer has one and only one sales contact.
					Response time is less than 2 seconds.
					Uptime requirement is 99.8%.
					Number of simultaneous users will be 200 max.
				Most of these requirements are non-functional, so the use cases wouldn't explicitly mention them.  The user doesn't see them directly in the success scenario.
			Action sequence
				Pre-condition前置条件：An observable status of the system before the use case starts.
				Post-condition后置条件: An observable status of the system after the execution of the use case.
				Basic event flow基本路径: “Happy Day” scenario, normal path
				Extended event flow扩展路径: abnormal branches

			Use Case Relationship
				includes 大家都要用，模块化
					You have a piece of behavior that is similar across many use cases
				extends	这个可以有
					A use-case is similar to another one but does a little bit more.Put the normal behavior in one use-case and the exceptional behavior somewhere else

			weather station
			http://www.uml-diagrams.org/use-case-diagrams-examples.html#airport
			http://www.uml-diagrams.org/bank-atm-uml-use-case-diagram-example.html?context=uc-examples
			http://www.uml-diagrams.org/examples/online-shopping-use-case-diagram-example.html?context=uc-examples
			Actor
				All the roles interacted with the system have  been represented by Actors
				Each actor is associated with at least one use case
				Compose the actors if one actor includes the other
				Decompose the actors if they are associated with different unrelated use cases
			Use Case
				All the major functionalities of the system have been represented by use cases
				Commonality analysis among use cases to identify new use cases and the extension, generalization and inclusion relationships among use cases
				Decompose complex use cases
		
		
6.Software Design
	The longer you postpone coding, the sooner you’ll be finished.
	The process of defining the architecture, components, interfaces, and other characteristics of a system or component.

	The beginning of wisdom for a [software engineer] is to recognize the difference between getting a program to work, and getting it right.

	Design Principles
		KISS = Keep It Simple Stupid
		Modularity
			Modularization Cost Curve
			Types of cohesion	几种聚合类型
				coincidental cohesion
				logical cohesion
				temporal cohesion
				procedural cohesion
				communicational cohesion
				sequential cohesion
				functional cohesion		
			
			Types of coupling   几种耦合类型
				Content coupling
				Common coupling
				External coupling
				Control coupling
				Stamp coupling
				Data coupling
				
			Strong cohesion & Weak coupling
				Simpler communication
				Simpler correctness proofs
				Changes influence other modules less often
				Reusability increases
				Comprehensibility improves

		Separation of Concern	
		Design for CHANGE
		Design for REUSE
			Design with and for reuse
			To avoid “reinventing the wheel”
			Reuse granularities 粒度

7.Object-Oriented Design 
	
	封装、继承、多态（Polymorphism）

	Class Analysis
		RUP
	UML Package and Class Diagram 
		Package
			Sub-system, a way to decompose the system
			Each modeling element is assigned to a package
		UML Class Diagram
			Association
				Binary Association
				Association between two classes
				Multiplicity: define the range of allowable cardinalities. 
				N-ary Association
				Association among three or more classes. 
				Qualified Association
				Qualifier: an attribute or a list of attributes whose values serve to partition the set of instances associated with an instance across an association. 
				Association Class 关联类
				An association that also has class properties.
			Class Relationship
				Aggregation 聚合
				Composition 组合
				Generalization (Inheritance) 继承
				Dependence 依赖
				
				聚合：表示两个对象之间是整体和部分的弱关系，部分的生命周期可以超越整体。如电脑和鼠标，多边形和点

				组合：表示两个对象之间是整体和部分的强关系，部分的生命周期不能超越整体，或者说不能脱离整体而存在。组合关系的“部分”，是不能在整体之间进行共享的。
				
				这里区别聚合和组合的关系，关键还是在于它们之中整体和部分的关系强、弱，以及它们之间的依附关系。
		
				关联：简单的可以认为，如果一个类作为了另外一个类的属性，那一定是关联关系。但你要知道，聚合是一种特殊的关联，而组合又是一种特殊的聚合。一般的关联我们认为是平级的、无整体部分关系的，如朋友关系。

				依赖：对象之间的临时关系，临时性体现在不超越方法的周期。简单的说，在方法使用到的，如参数类，就一定是依赖关系。
			UML Sequence Diagram 
				
				
				
				
8.Software Design Pattern
	Favor Composition over Inheritance
		Both composition and inheritance are important methods of reuse.
		Inheritance was overused in the early days of OO development.
		Over time we’ve learned that designs can be made more reusable and simpler by composition.
		The available set of composable classes can be enlarged using inheritance. 
	Program to the Interface not implementation
	
	Creational patterns(5)

	




观察者与被观察者的主仆关系，前者为仆，后者为主。但在汇编作业中，观察者不仅要观察，还要强制执行，所以挟持了主。



Creating template methods
Optimizing class hierarchies
Incorporating composition relationships


为什么需要重构？


重构的好处
http://baike.baidu.com/link?url=sdavZ7hsw071-Dro4nijO16eaDXoX8m_euj5XFq0V7h0CJZUBFmCJdB8F7s5xUxu
	能改进软件设计使软件更容易被理解
	能帮你找到bug
	提高软件的开发速度
	什么时候进行重构

	三次法则：事不过三，三则重构.意思是说，一件事情，第一次只管去做，第二次做类似的事情会产生反感，但无论如何还是做了，第三次再做类似的事情，你就应该重构。
	在添加新功能时进行重构。
	在修改bug时进行重构。
	在代码复审时进行重构。
	为什么重构有用

	难以修改的程序具有以下特征：
	难以阅读的程序，难以修改
	逻辑重复的程序，难以修改
	添加新行为时需要修改现有的代码，难以修改
	带复杂条件逻辑的程序，难以修改
	好的程序应该是：
	容易阅读
	所有逻辑都只在唯一地点指定
	新的改动不会危及现有的行为
	尽可能简单的表达条件逻辑
	对软件的生命造成威胁的因素只有一个：需求的变更。一个软件总是为解决某种特定的需求而产生，时代在发展，客户的业务也在发生变化。有的需求相对稳定一些，有的需求变化的比较剧烈，还有的需求已经消失了，或者转化成了别的需求。在这种情况下，软件必须相应的改变。
	考虑到成本和时间等因素，当然不是所有的需求变化都要在软件系统中实现。但是总的说来，软件要适应需求的变化，以保持自己的生命力。
	这就产生了一种糟糕的现象：软件产品最初制造出来，是经过精心的设计，具有良好架构的。但是随着时间的发展、需求的变化，必须不断的修改原有的功能、追加新的功能，还免不了有一些缺陷需要修改。为了实现变更，不可避免的要违反最初的设计构架。经过一段时间以后，软件的架构就千疮百孔了。bug越来越多，越来越难维护，新的需求越来越难实现，软件的构架对新的需求渐渐的失去支持能力，而是成为一种制约。最后新需求的开发成本会超过开发一个新的软件的成本，这就是这个软件系统的生命走到尽头的时候。
	重构就能够最大限度的避免这样一种现象。系统发展到一定阶段后，使用重构的方式，不改变系统的外部功能，只对内部的结构进行重新的整理。通过重构，不断的调整系统的结构，使系统对于需求的变更始终具有较强的适应能力。

	代码味道：
	http://www.cnblogs.com/mywolrd/archive/2012/04/24/2467395.html
		重复的代码是多数潜在BUG的温床！
		过长的函数
		过大类
		过长的参数列表
		发散式变化
		。。。
		
9.Software Testing		
		
	Verification and Validation 验证与确认
		Verification: Are we building the product right?
			Software conforms to its specification 符合规范
		Validation: Are we building the right product?
			Software meets the needs of the customer 满足需求
	Testing
		Venn：
		S: the expected behavior of the system defined by the specification

		P: the behavior that exposed by the system implementation

		T: The behavior that detected by test cases 

		The verified implemented requirements
		The unverified implemented requirements
		The verified unspecified behavior
		The test cases for un-implemented requirements
		The missing and unverified requirements
		The unspecified but implemented, unverified behavior
		The test cases for unspecified, unimplemented behavior 

		测试的覆盖率是指种类的覆盖，这样更有可能找到bug。而非代码的覆盖。
			A good test case is one that has a high probability of finding an as-yet undiscovered error. 
			A successful test is one that uncovers an as-yet undiscovered error.
		Pareto图来自于Pareto定律，该定律认为绝大多数的问题或缺陷产生于相对有限的起因。就是常说的80/20定律，即20%的原因造成80%的问题。	
			
		WT
			Control flow testing
				Coverage Testing
				Path testing
			Data flow testing
		
			Cyclomatic complexity 		
				= number of edges - number of nodes +2
				= number of decisions +1
				= number of regions

		BT	
*/			
	
	
	
	
复习计划
1230
	复习编译1/4 （5.6.7）
1231
	论文
	复习编译2/4  （8,9,10）
0101
	ftp
	复习编译3/4	（11,12，作业）
0102
	实验室结题
	复习信号1/4
0103
	复习信号2/4
0104
	复习信号3/4
0105
	复习网原1/4
0106		
			
//1230,编译复习			
			
			
//1231,文革

//01011

//0103,database
实验报告内容
	正文	 Hi，本学期的数据库课程快要结束了，为了帮助大家整理本学期完成大作业的经历和收获，同时也为了便于助教更详细地了解大家的完成情况，给出更客观的成绩，请大家在1月10日之前，以组为单位提交一份报告（发到助教的邮箱里）。报告需要包括（不限于）如下内容：

	1. 系统的架构（是否采用多线程、是否采用第三方库等）；

	2. 存储模型，即数据的存储方式（数据的存储格式、是否进行数据划分、数据如何排序、是否根据access pattern进行优化等）；

	3. 索引结构（采用何种数据结构、根据什么策略建立索引等）；

	4. Cache策略（如何使用内存，如果自己实现了cache的话，采用了何种替换策略）；

	5. 查询执行策略（采用何种优化方法、查询执行的过程）；

	6. 其它重要的特征；

	7. 参考资料（如果有，列出标题或网址即可）；

	8. 每个组员的贡献率（百分比形式）。

	在报告中，最好能够对一些细节问题画图或举例说明，比如：对于自己维护数据文件的组，最好能讲清数据文件的格式，是文本文件还是二进制文件，如果是二进制文件，每个字节都表示什么含义；在查询优化部分，最好能以一个较复杂（含较多join）的查询为例，说明查询树的构造过程。

	另外，大家如果对冯老师上课的内容，以及本次大实验的形式和内容有什么意见和建议，或者在完成大作业的过程中产生的一些感想和学习经历，也欢迎写到报告中，这部分不会影响大家的成绩。

	说明：
	（1）报告占10分，不想让大家占用大量的时间写报告，所以只要写的清楚、让我明白系统是怎么设计的、每个人都做了些什么，便于我最后能够更客观的给成绩就可以。
	(2) 网站上现在给出的分数是按照去年的标准给的，满分30分，今年会在这个基础上做一些调整。
	(3) 为了防止大家的测试结果互相影响，我们同时只会测一个组的代码，所以越往后，交的人越多，等的时间就越长，建议大家现在就多交多测，大家加油呀~  

内存和时间限制说明
	正文	 内存：目前提供1G

	放宽了各测试点的时间限制：
	project/select:900s 
	join: 3600s 
	tpcc1/tpcc10：1800s
	tpch1:1800s
	tpch3:3600s
	tpch10: 7200s 

	加油做吧O(∩_∩)O~  


大作业的提交内容
	正文	 目前有几组同学在交作业，再强调一下提交内容，只交client文件夹，把client文件夹打包成.tar.gz的格式提交上来，确保文件夹里面的Makefile是正确的。

	之前有同学反映编译不能通过，我发现是我服务器上的tool工具跟给大家的版本不一致造成的，很抱歉之前没有发现这一点，现在这个问题已经修复了，大家放心提交：）

	如果还有什么问题，随时给我发邮件：）


关于TPCC和TPCH测试点
	正文	 TPC-C和TPC-H都是事务处理数据的标准规范，它并不是指的是具体的数据，而是一套生成事务处理数据的标准，根据它里面提到的表和表格之间的依赖关系，我们生成了后五个测试点，其中W和SF表示数据集的大小。

	TPCC涉及到9个表，数据量比较小，最大的表大概在几百兆左右

	TPCH涉及到8个表，数据量相对大，最大的表几个G

	关于TPCC和TPCH规范，请参考 http://www.tpc.org/tpcc/default.asp


1.学习B+ tree http://blog.csdn.net/hguisu/article/details/7786014











////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
/* 2014 */





//0123,PERL
>:<$%@abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._

//0125,linux kernel
Linux内核源代码情景分析

1.minx是一个微内核，而linux 是一个宏内核
2.注意：我们所学的计算机组成、计算机网络体系结构在操作系统的研究中各居什么地位？感觉操作系统更侧重网络体系结构的实现，这是大头.
3.如何理解设备亦文件？这就要从微内核和宏内核的区别说起，以及原始unix内核的设备添加。相关的涉及安全性问题（回顾黑客防线）
4.你所不了解的早期8位机与16位机
5.实地址模式的由来
6.GNU C：由于大量inline函数的使用，相当一部分代码从.c转移到.h
7.对一类特殊宏操作的解释：do { do something;} while(0)
8.对大量使用的双端队列的说明：抽象结构——list_head
9.page 206:"读者以后将会看到，时钟中断和对时钟中断的服务，就像动物的心跳、脉搏。而现在内核的脉搏尚未开始。"
10.do_IRQ(struct pt_regs regs):体现汇编和C的完美结合。
11.
12.
13.

//0131,linux命令行与shell脚本编程


//0202,linux内核完全注释
1.linux内核五个模块：进程调度、内存管理、文件系统、进程通信、网络接口。
2.单内核模式（宏内核）中用用程序的调用是通过中断指令int 80来实现的
3.中断分为两类：硬终端和软中断。其中软中断（异常）又分为fault和trap
20140302
4.linux 0.11采用单内核模式
5.进程调度是五大模块的的核心
6.内存管理是我们的切入点
7.p54：关于task0的启动————什么是内核态？什么是用户态？所谓内核态，就是kernel代码的执行者，而用户态就是用户程序的执行者
8.另外，由内核态通过伪中断进入用户态，这是不是有所启发？
9.新进程的创建过程：先完成复制和自我完善，再进行系统注册。在自我完善阶段，需要设置为不可中断。
10.进程调度：万事开头难——只需要开头就行。
11.tss.ss0:记录这个特殊位置，它同时是进程空间中保存任务数据结构的起始位置。亦即这一页既保存任务数据结构，也作为内核态堆栈页。
之所以可以这样设计，是因为它仍然在内核态所在的空间中。（？？？？？？）
12.PC和IP是一个东西，今天才弄明白！
PC 是计算机科学中使用的一个术语。IP 是 x86 兼容 CPU 中的一个寄存器。简单来说，在 x86 兼容 CPU 上，CS 段寄存器和 IP 寄存器两个寄存器就是实现计算机科学中的 PC 这个概念的具体设施。

13.boot启动为什么不直接将系统模块加载进内存头部呢？这是因为在setup程序开头部分（如果分为3部分的话）还要用到BIOS 设置的中断表
15.与lab1不同的是，bootsect不仅要加载内核，还要指明文件系统的设备
16.注意这三块（boot，setup，system）在启动盘（磁盘）上的存储是相连的，分别占据1,4,many个扇区。实际过程中，system映像是在文件系统中的，所以我们一般不使用bootset，而是使用专门的引导程序，如grub。实际流程是第一个扇区存放MBR，然后再由MBR加载grub。注意此时内核映像与根文件系统不能共存（？？？？？）
17.setup程序的第一部分是读取机器数据，并覆盖bootsect（大逆不道）;第三部分也就是我们所熟悉的打开保护模式，包括设置两个表，开A20和8259,设置c20,长跳转
18.注意为什么gdt的第一个表象被设置为空（null）：初始化？？？？？
19.从head.s开始就进入了内核模块(“head”名字的意义)，虽然这个程序还在boot/目录下
注意此时已经进入了保护模式，在linux0.11中从这里开始的汇编程序采用gnu格式。
20.head.s任务艰巨，完成中断、分段和分页的初始化工作。head.s之后也会被自己设置的四个页表覆盖（历史的车轮滚滚）
21.movl $0x10,%eax
# 再次注意!!! 这里已经处于32 位运行模式，因此这里的$0x10 并不是把地址0x10 装入各个
# 段寄存器，它现在其实是全局段描述符表中的偏移值，或者更正确地说是一个描述符表项
# 的选择符。
22.初始化后的页结构：
0x0-0x1000(4k) 页目录（占一页）
0x1000-0x2000(4k) 页0
0x2000-0x3000(4k) 页1
0x3000-0x4000(4k) 页2
0x4000-0x5000(4k) 页3
23.以下是Linus对分页的注释。。。
	/*
	* Setup_paging
	*
	* This routine sets up paging by setting the page bit
	* in cr0. The page tables are set up, identity-mapping
	* the first 16MB. The pager assumes that no illegal
	* addresses are produced (ie >4Mb on a 4Mb machine).
	*
	* NOTE! Although all physical memory should be identity
	* mapped by this routine, only the kernel page functions
	* use the >1Mb addresses directly. All "normal" functions
	* use just the lower 1Mb, or the local data space, which
	* will be mapped to some other place - mm keeps track of
	* that.
	*
	* For those with more memory than 16 Mb - tough luck. I've
	* not got it, why should you :-) The source is here. Change
	* it. (Seriously - it shouldn't be too difficult. Mostly
	* change some constants etc. I left it at 16Mb, as my machine
	* even cannot be extended past that (ok, but it was cheap :-)
	* I've tried to show which constants to change by having
	* some kind of marker at them (search for "16Mb"), but I
	* won't guarantee that's all :-( )
	*/
24.注意，mian程序的开始是由setup_paging的ret造成的，因为在此之前已经将main的地址人工压栈，所以setup_paging实际上是模拟了一次程序调用。
此时的内存分布见p.127
25.伟大的写时复制技术（COW）：以gfs的快照为例http://autumnice.blog.163.com/blog/static/555200201010265035695/
26.mm两大机制：
写时复制机制 COW
需求加载机制 LOD
27.从《内核代码情景分析》得：
分段根本不必要！尤其是GDT只存了四项，而虚地址经过GDT的映射根本不发生变化，并且权限检查与页式权限检查是重复的。
而实际的linux中也只是“装模作样地糊弄i386”而已！
由此引出的疑问：程序员不是可以通过设置CS或DS轻松地攻破段机制！问题在于页机制是真正的防护。
28.注意，在linux0.11中的mem_map是一个字节图，而在linux2.x中则是一个page结构数组（同时连成一个双向链表），在这些page结构中的一些担当管理区，下辖固定的页面。
29.从物理空间和用户空间两方面看内存管理：即从供和需的两个角度来看。
从用户空间（即虚存空间）来看，vm_area_struct结构
30.p83：mm/page_alloc.c 270 315：This is the 'heart' of the zoned buddy allocator。
31.
32.
33.
34.
35.
36.
37.
38.
39.
//0203.[并行计算——结构·算法·编程].陈国良.文字版
第二篇 并行算法的设计
1.数据挖掘(data mining)是数据“模型”的发现过程
2.有些人将数据挖掘看成是机器学习的同义词。毫无疑问,一些数据挖掘方法中适当使用了机器学习算法。机器学习的实践者将数据当成训练集来训练某类算法,某些场景下上述的数据利用方式是合理的。机器学习擅长的典型场景是人们对数据中的寻找目标几乎一无所知。另一方面,当挖掘的目标能够更直接地描述时,机器学习方法并不成功。
3.
4.
5.
6.| xargs grep -i --color=auto
7.find . -type f \( -perm +100 -printf '\033[32m%p\033[0m\n' -or -print \)
8.http://serverfault.com/questions/180749/linux-colorize-find
9.
10.
11.
12.
13.
14.
15.
find . -iname \*$1\* 
#wrong: find . -iname '*$1*'

//0210,BigData

大数据：互联网大规模数据挖掘与分布式处理

Hadoop权威指南第2版中文版
1.mapreduce与rdbms的比较：前者可以视作后者的补充。
另一方面，关系数据往往是规范的，以保持数据的完整性且不含冗余。
2.数据本地化特征是mapreduce的核心特性。无共享框架（shared-nothing）
3.hadoop调度让我们有种计原构建计算机的感觉
4.mapper的数据本地化优化（data locality optimization），本地化优势
5.“集群上的带宽限制了mapreduce作业的数量，因此最重要的一点是尽量避免map任务和reduce任务之间的数据传输”
6.推与拉？？？
7.hadoop的hdfs才是精髓所在。
分布式文件系统还需要面对网络编程的泥沼。同时，节点不稳定和负载不均也是分布式文件系统的复杂所在。
8.流式，块抽象，管理者-工作者模式
9.hdfs://localhost/
10.
11.
12.
13.
14.
15.

Hadoop--
1.
2.
3.
4.
5.




//0214,hack
黑客反汇编揭秘 第二版

1.从黑客装备开始
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.

mount -t vboxsf share chunkshare
http://pascal.inrialpes.fr/soft/olt/













//0304

利用qemu+gdb调试linux-0.11

	//http://blog.sina.com.cn/s/blog_85882089010170r3.html
	//http://www.oldlinux.org/Linux.old/bochs-images/
1.
		选取后人重新改过的linux-0.11-2011,编译时添加选项-fno-stack-protector
2.关于qemu
	-L dir 指向BIOS和VGA BIOS所在目录
	-hda/-hdb/-hdd/-hdc “文件名” 使用“文件名”作为硬盘0/1/2/3镜像。
	-cdrom “文件名” 使用“文件名”作为光盘镜像（文件应该是ISO类型）。
	Windows 下的使用者，可以透过下列指令使用实体光盘：
	-cdrom //./x: -> x 代表光盘名称/位置
	例如：-cdrom //./e: -> 使用 E:\ 为光盘
	-fda/-fdb “文件名” 使用“文件名”作为磁盘0/1镜像。
	-boot [a|d|c] 使用磁盘<a>，光盘<d>，或者硬盘<c>启动。
	-m容量指定内存的大小，单位是MB。
	-soundhw c1,... 使用声卡设备。
	-soundhw ? 列出所有可使用的声卡
	-soundhw all 使用全部声卡
	-usb 允许使用usb设备。
	-usbdevice 名字 添加一个usb设备“名字”。
	-net nic 创建一块新的网卡。



	你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：

	x/<n/f/u> <addr>

	n、f、u是可选的参数。

	n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
	f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。
	u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。

	<addr>表示一个内存地址。
	n/f/u三个参数可以一起使用。例如：

	命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。

	输出格式
	一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量 的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：

	x 按十六进制格式显示变量。
	d 按十进制格式显示变量。
	u 按十六进制格式显示无符号整型。
	o 按八进制格式显示变量。
	t 按二进制格式显示变量。
	a 按十六进制格式显示变量。
	c 按字符格式显示变量。
	f 按浮点数格式显示变量。


	==[使用GDB文本界面]======================================================
	gdb Text User Interface(TUI) GDB 文本用户界面
	(1) 打开TUI模式
		方法一: 使用‘gdbtui’ or ‘gdb-tui’开始一个调试
		$ gdbtui -q sample
		(gdb) ....

		方法二: 使用切换键 `ctrl+x ctrl+a` or `ctrl+x A`
	(2) TUI模式下有4个窗口,
			command      命令窗口. 可以键入调试命令
			source       源代码窗口. 显示当前行,断点等信息
			assembly     汇编代码窗口
			register     寄存器窗口
		除command 窗口外,其他三个窗口不可同时显示.其可用 layout 命令来进行选择
		自己需要的窗口. 可参见 `help layout` .
	(3) 设置TUI
		set tui border-kind kind
		Select the border appearance for the source, assembly and register windows.
		The possible values are the following:
		space:      Use a space character to draw the border.
		ascii:      Use ascii characters ‘+’, ‘-’ and ‘|’ to draw the border.
					acs Use the Alternate Character Set to draw the border. The 
					border is
		drawn:      using character line graphics if the terminal supports them.
	(4) 更详尽的说明
		http://sourceware.org/gdb/current/onlinedocs/gdb_23.html#SEC235.



//03XX
schedule:
1.13:00-14:30 hack
2.14:30-15:30 chapt3
3.15:30-16:30 hack or git
4.16:30-17:30 challenge or lab2

1.19:00-20:30 chap4
2.20:30-21:30 hack
3.21:30-22:30 SHUZHI
4.23:00-24:00 read

//0309,webzine
http://www.80vul.com/webzine_0x05
链接: http://pan.baidu.com/s/1sjLdpqH 密码: t3yy
1.
2.
3.
4.
5.
6.
7.
8.
9.


//0310,课外探讨
1.自动并行化编译器

	http://www.docin.com/p-277009133.html
	
2.动态编译
	动态编译是某些程式语言在执行时用来增进效能的方法。尽管这技术源于Self但使用此技术最为人所知的是Java。它可以做一些只在执行时才能得知的最佳化。使用动态编译的执行环境 一开始几分钟执行慢，之后，完成大部分的编译和再编译后，会执行快。因为初始效能的延迟，动态编译不适用于一些情况。在许多实作中，一些可以在编译时期做的最佳化被延到执行时期才编译，导致不必要的效能降低。即时编译是一种动态编译的形式。
	一个非常近似的技术是递增式编译。递增式编译器用于POP-2、POP-11、一些Lisp的版本，如Maclisp和最少一种版本的ML语言（Poplog ML）。这要求编程语言的编译器成为执行环境的一部分。结果，可以在任何时候从终端、从档案、或从执行中程式所建造数据结构中读取源码。然后，转成机器码区块或函数（有可能取代之前同名的函数），之后可立即被程式使用。因为执行中对互动开发和测试的速度的要求，编译后的机器码所做的最佳化程度不如标准'批次编译器'。然而，递增式编译过的程式跑起来通常比同一个程式的解译版本还快。递增式编译因而提供了编译和解译语言优点的混合版。 为了移植性，递增式编译通常采两步骤。第一个步骤会编译到中间与平台独立的语言，然后再到机器码。在这例子，移植只须改变'后端'编译器。不同于动态编译，递增式编译在程式执行后不会做更进一步的最佳化。

//0310,作业

1.数字图像处理：自己写代码！！！
	今天解决了两个问题：eclipse配置opencv的库导入;cdt的自动补全的设置http://stackoverflow.com/questions/5509052/eclipse-cdt-for-c-c-development-how-to-invoke-content-assist-automatically-w
	并且Ctrl+Tab会有模板哦！

	opencv_objdetect opencv_video opencv_imgproc opencv_videostab opencv_legacy opencv_stitching opencv_highgui opencv_calib3d opencv_ts opencv_ml opencv_features2d opencv_contrib opencv_flann opencv_core opencv_photo

line52
	<listOptionValue builtIn="false" value="opencv_objdetect"/>
	<listOptionValue builtIn="false" value="opencv_video"/>
	<listOptionValue builtIn="false" value="opencv_imgproc"/>
	<listOptionValue builtIn="false" value="opencv_videostab"/>
	<listOptionValue builtIn="false" value="opencv_legacy"/>
	<listOptionValue builtIn="false" value="opencv_stitching"/>
	<listOptionValue builtIn="false" value="opencv_highgui"/>
	<listOptionValue builtIn="false" value="opencv_calib3d"/>
	<listOptionValue builtIn="false" value="opencv_ml"/>
	<listOptionValue builtIn="false" value="opencv_ts"/>
	<listOptionValue builtIn="false" value="opencv_features2d"/>
	<listOptionValue builtIn="false" value="opencv_contrib"/>
	<listOptionValue builtIn="false" value="opencv_flann"/>
	<listOptionValue builtIn="false" value="opencv_core"/>
	<listOptionValue builtIn="false" value="opencv_photo"/>
	
opencv_objdetect
opencv_video
opencv_imgproc
opencv_videostab
opencv_legacy
opencv_stitching
opencv_highgui
opencv_calib3d
opencv_ml
opencv_ts
opencv_features2d
opencv_contrib
opencv_flann
opencv_core
opencv_photo

/usr/include/opencv

2.
	There are a few peculiarities with the GUI in OpenCV. The DestroyImage call fails to close a window (atleast under Linux, where the default backend was Gtk+ until 2.1.0) unless WaitKey was called to pump the events. Adding a WaitKey(1) call right after DestroyWindow may work.

	Even so, closing is not guaranteed; the the WaitKey function is only intercepted if a window has focus, and so if the window didn't have focus at the time you invoked DestroyWindow, chances are it'll stay visible till the next DestroyWindow call.

	I'm assuming this is a behaviour that stems from Gtk+; the function didn't give me any trouble when I used it under Windows.
3.


从“东哥与ncmm”事件引出：抛开事实不论。即使真有其事，那么在微博要想广泛传播也实属不易。这给我们提出的问题是——能否分析一起微博事件的源头？


第一次作业（同学们久等了！）
非常抱歉 米娜桑！作业来了⊙︿⊙
(1)某一部件A的处理时间占整个运行时间的百分比为f1,部 件B的处理时间占整个运行时间的百分比为f2;
如果将A部件和B部件的处理速度分别加快到原来的S1和 S2倍,则采用加速措施后能使整个系统的性能提高多少?
(2)假定要将某一执行部件改进后速度提高10倍,改进后被改进部件执行时间占系统总运行时间的50%。问改进后,获得的加速比是多少?
备注：
由于本次作业布置的较晚，还望同学们见谅！但是题目不多，还是周四交吧~
备备注：
作业按照去年传统，以电子版方式提交网络学堂，请采用doc或者pdf等所见即所得文档类型！（跪求不要latex源码Orz，但是用txt这种的。。。也还是不要吧）如果以后涉及可能需要作图等比较复杂的操作，可以采用人肉画图然后拍照的形式╭(′▽`)╯。不过可以练练使用洋气的各种PC作图软件╰(￣▽￣)╮ 蓝后！作业内容中请标志清楚自己的姓名以及学号。最后，请大家一起为马航祈祷。


“认真完成作业，好人一生平安。”

from 助教酱 



//0313


调查问题：乡镇学校合并及校车安全问题调研

//0314

"由于 gcc 编译出的虚拟起始地址从 0xC0100000 开始..."
	1.另外,ucore 的入口地址也改为了 kern_entry 函数,这个函数位于 init/entry.S 中,分析代码
		可以看出,entry.S 重新建立了段映射关系,从以前的
		Virtual Address= Linear Address
		改为
		Virtual Address=Linear Address-0xC0000000

	2.由于物理内存页管理器管理了从 0 到实际可用物理内存大小的物理内存空间,所以对于这些物理内存空间都需要建立好页映射关系。

//0319,emacs
Survival guide for the first week of emacs

When you start using emacs for the first time, your habits fight you every inch of the way. Your fingers long for the good old familiar keybindings. Here's an overview of the most commonly used shortcuts to get you through this pain:

C Shorthand for the ctrl-key
M Shorthand for the meta-key (bound to cmd on my mac settings)
S Shorthand for the shift-key
Files

C-x C-f Open a file. Starts in the current directory
C-x f Open a recently visited file
C-x o Open a file in the current project (based on .git ++)
C-x C-s Save this file
C-x C-w Save as ...
C-x C-j Jump to this files' current directory
C-x b Switch to another open file (buffer)
C-x C-b List all open files (buffers)
Cut copy and paste

C-space Start marking stuff. C-g to cancel.
C-w Cut (aka kill)
C-k Cut till end of line
M-w Copy
C-y Paste (aka yank)
M-y Cycle last paste through previous kills
C-x C-y Choose what to paste from previous kills
C-@ Mark stuff quickly. Press multiple times
General

C-g Quit out of whatever mess you've gotten yourself into
M-x Run a command by name
C-. Autocomplete
C-_ Undo
M-_ Redo
C-x u Show the undo-tree
C-x m Open magit. It's a magical git interface for emacs
Navigation

C-arrow Move past words/paragraphs
C-a Go to start of line
C-e Go to end of line
M-g M-g Go to line number
C-x C-i Go to symbol
C-s Search forward. Press C-s again to go further.
C-r Search backward. Press C-r again to go further.
Window management

C-x 0 Close this window
C-x 1 Close other windows
C-x 2 Split window horizontally
C-x 3 Split window vertically
S-arrow Jump to window to the left/right/up/down
Help

F1 t Basic tutorial
F1 k Help for a keybinding
F1 r Emacs' extensive documentation

//0317,homework

第一次大作业
<<密码学原理与实践（第三版）>> 第一章（30页）：1.5, 1.16, 1.21, 1.29
第二章（54页）：2.2, 2.9, 2.13, 2.17
截至时间：3月31日

本次作业以第三版为准，请使用第二版的同学参考附件！
作业文件：  第一次大作业密码学原理与实践（第二版）.docx


第一次大作业
<<密码学原理与实践（第二版）>> 
第一章（32页）：1.5, 1.16, 1.21, 1.29
注：
1.16(b)更改如下：
解密下列是用置换密码加密的密文，密钥是(a)中的置换
TGEEMNELNNTDROEOAAHDOETCSHAEIRLM

第二章（59页）：2.2, 2.9, 2.13, 2.17
截至时间：3月31日


//0319,数据库exp1 - Approximate String Search
	– createIndex()函数
	– searchJaccard()函数
	– searchED()函数
	请不要修改这三个方法的声明,可以根据需要
	自行添加其他方法。

	函数声明：int createIndex(const char *filename, unsigned q);
		filename： 输入文件：
			每行一个字符串，代表一条记录
			每条记录的id为其行号，从0开始
		q：如使用qgram方法，该参数为q值
		
		作用：读取指定的输入文件并建立索引
		创建成功请返回SUCCESS
		创建失败请返回FAILURE

	函数声明：int searchJaccard(const char *query, double threshold, vector<pair<unsigned, double> > &result);
		query：查询串
		threshold：Jaccard阈值
		vector<pair<unsigned, double>> &result，返回的结果，每个pair是<字符串id,  与query之间的Jaccard相似度>，需按照id从小到大排序，且无重复结果
		返回值同createIndex

	函数声明：int searchED(const char *query, unsigned threshold, vector<pair<unsigned, unsigned> > &result);
		query：查询串
		threshold：ED阈值
		vector<pair<unsigned, unsigned>> &result，返回的结果，每个pair是<字符串id,  与query之间的编辑距离>，需按照id从小到大排序，且无重复结果
		返回值同createIndex
		
		评测标准:
			正确性：
				返回的结果均满足查询要求
				满足查询要求的结果全部被返回
			时间：跑的越快越好，最快的有奖品 
			空间：要求能够跑动最终评测数据集（一般不需考虑）
		提交材料：
			所有的源代码，不包括main.cpp
			设计文档：描述算法设计思路以及实现难点
		网络学堂提交
		
		W = log 2 (tf+1) * idf where
			tf : # of times ‘term’ appears in a document d
			idf : number of documents / number of documents containing‘term’
			Intuitively: rare ‘terms’ are more important


	1. createIndex函数只会被调用一次，需要同时建立好适用于ed和jaccard的索引；
	2. jaccard的计算规则如下，采用q-gram切分，若q=2，则"aaabc"和"aabc"的jaccard = jac({"aa", "aa", "ab", "bc"}, {"aa", "ab", "bc"}) = 3/4 = 0.75。
	//////////////////////////////////////
	问题
	1.ED如何计算？如果采用两重循环建表开销较大;另外，建表是否需要或者能否在index阶段建立？如果不能，如何利用threshold快速过滤？
	2。createIndex中的参数q有何用？
	3.每条记录是什么格式？是单词还是句子？（当然是句子的说，甚或是网页，但是如果是句子，那么ED方法岂不是很不靠谱？）能否使用cosine距离？

	4。感觉这两者的目的不一样：一个是近似查找，一个是搜索（回顾一下人工智能课程的贝叶斯估计）
		但是如果将单词拆成gram，并将gram视作句子的单词，那么这两者是类似的

		q-grams may capture small typing mistakes
		 ‘Jaccard’ vs ‘Jacard’ ->
		{‘Jac’,’acc’,’cca’,’car’,’ard’} vs
		{‘Jac’,’aca’,’car’,’ard’}
		 Common terms ‘Jac’, ‘car’, ‘ard’ would be enough to
		result in high value of Cosine(‘Jaccard’, ’Jacard’).

	5.ED+DP(scan+verify)代表了一种蛮力方法，其中DP的复杂度是O((2*T+1)*min(r,s))
	6.q-gram(filter+refine)
		Have false positives 有误报
		Have no false negatives 无漏报
		| Q R ∩ Q S | ≥ max(| R |, | S |) − q + 1 − τ * q 原因在于这个判断式过于宽容
		Given a query Q, we find all the strings sharing enough grams with grams of Q as candidates

	7.一旦确定使用q-gram方法，需要建立倒排列表


//0324,about cripanalysis
补记：
1.模拟退火算法的参数难调是一方面，其实主要还是k变化的步长太小并且方向函数太过简单
2.遗传算法感觉在方向性上更靠谱，但是目前的问题是速度太慢，瓶颈在于新text的矩阵计算量大

//0324,OS lab3

understand:

MD5 Checksum: 
e3771c08fda9afa06c859eea1f3f153a
//0325,cache
第一次实验：存储层次分析及程序优化

实验内容：
1、使用C/C++语言编写程序测量你所使用的机器的Data Cache结构参数
2、根据你机器的Cache结构对给出的应用程序进行相应优化

具体的实验要求与实验原理(见附件)：
实验方法简介.pdf
实验要求.pdf

需要优化的程序(见附件)：
matrix_mul.cpp

实验提交时间：2014-04-02


Classifying Misses: 3 Cs
	Compulsory — 
		The first access to a block is not in thecache,so the block must be brought into the cache.Also called cold start misses or first reference misses.(Misses in even an Infinite Cache)
	Capacity — 
		If the cache cannot contain all the blocksneeded during execution of a program, capacity misses willoccur due to blocks being discarded and later retrieved.
	Conflict — 
		If block-placement strategy is set associative ordirect mapped, conflict misses (in addition to compulsory &capacity misses) will occur because a block can bediscarded and later retrieved if too many blocks map to itsset. Also called collision misses or interference misses.


Loop Interchange
 
	Motivation: some programs have nested loops that
	access data in nonsequential order
	Solution: Simply exchanging the nesting of the loops
	can make the code access the data in the order it is
	stored =>
	reduce misses by improving spatial locality;
	reordering maximizes use of data in a cache block
	before it is discarded

Blocking

	Motivation: multiple arrays, some accessed by
	rows and some by columns
	Storing the arrays row by row (row major order)
	or column by column (column major order) does
	not help: both rows and columns are used in
	every iteration of the loop
	(Loop Interchange cannot help)
	Solution: instead of operating on entire rows and
	columns of an array, blocked algorithms
	operate on submatrices or blocks => maximize
	accesses to the data loaded into the cache
	before the data is replaced

Merging Arrays

	Motivation: some programs reference multiple arrays
	in the same dimension with the same indices at the
	same time =>
	these accesses can interfere with each other,leading
	to conflict misses
	Solution: combine these independent matrices into a
	single compound array, so that a single cache block
	can contain the desired elements

Loop Fusion

	Some programs have separate sections of code that
	access with the same loops, performing different
	computations on the common data
	Solution:
	“Fuse” the code into a single loop =>
	the data that are fetched into the cache can be used
	repeatedly before being swapped out => reducing
	misses via improved temporal locality


1.补边法
2.放弃局部变量和查找表
3.循环体考虑指令缓存。紧循环。


1.交换

A

	for (i = 0; i < 1000; i++) {
		for (k = 0; k < 1000; k++) {
			for (j = 0; j < 1000; j++){
				d[i][j] += a[i][k] * b[k][j];
			}

		}
	}

a[i][k]读取次数少了，避免了重复读取
b[k][j] 读取连续读取

time spent for original method : 13230000 ms
time spent for new method : 7770000 ms

B
	for (k = 0; k < 1000; k++)  {
		for (i = 0; i < 1000; i++){
			for (j = 0; j < 1000; j++){
				d[i][j] += a[i][k] * b[k][j];
			}

		}
	}

2.Blocking
B（Block factor）取多大呢？首先，最好能保证三个小matrix都能存放在cache中，即3*(B*sizeof(int))^2 <= cache size

B ～=25,取B =20

同样a[i][k]读取次数少了，不过读取没有连续;另外两项与上一个方法是对称的;所以总体来说，这个方法会略慢

time spent for original method : 13240000 ms
time spent for new method : 7940000 ms


time spent for original method : 13150000 ms
time spent for new method : 12940000 ms

orig:
time spent for original method : 13020000 ms
time spent for new method : 12690000 ms

time spent for original method : 12990000 ms
time spent for new method : 12850000 ms

time spent for original method : 12790000 ms
time spent for new method : 12770000 ms

http://www.cplusplus.com/forum/general/35557/
1. Why am I not getting results that show an increase at 64K
2. How can I estimate the size of my L1 data cache?
3. How do applications like CPU-X and CPU-Z etc calculate the cache sizes?

http://igoro.com/archive/gallery-of-processor-cache-effects/
	Allocate a BIG char array (make sure it is too big to fit in L1 or L2 cache). Fill it with random data.
	Start walking over the array in steps of n bytes. Do something with the retrieved bytes, like summing them.
	Benchmark and calculate how many bytes/second you can process with different values of n, starting from 1 and counting up to 1000 or so. Make sure that your benchmark prints out the calculated sum, so the compiler can't possibly optimize the benchmarked code away.
	When n == your cache line size, each access will require reading a new line into the L1 cache. So the benchmark results should get slower quite sharply at that point.
	If the array is big enough, by the time you reach the end, the data at the beginning of the array will already be out of cache again, which is what you want. So after you increment n and start again, the results will not be affected by having needed data already in the cache.
	notice:
		1.Probably HW prefetching will figure out steps of 'n', and will load ahead of you. 
		2.I think this idea should work, however try to take n steps in a random way to avoid prefetching, something like n + (r * c), where c is a 2's power value bigger than possible cache line size and r is a random value. you need to be sure that n + (r * c) is in your array probably using modulo. 
			@auselen -- I also thought about the effects of prefetching before writing this answer, but I still recommend that the OP try this method first, and see how the results work out. The inner loop of this benchmark should compile down to ~4 instructions (~3 if he uses sentinels). If you have 1 cache miss every 4 instructions, I don't think even prefetching will help you much. Other readers who know CPU hardware better than me are free to correct me here! –  Alex D
		
		
//0326,datamining
1. As a highly application-driven discipline, data mining has been widely applied in many areas. We brieﬂy presented two highly successful and popular application examples of data mining: business intelligence and Web search engines, in our textbooks. Do you think that data mining can also be applied to the following areas? If yes, please provide a brief yet concrete example, if not; please briefly state your reasons.
1) Software Engineering.
随着软件需求的日益增长和开发技术的快速发展,软件系统的规模和复杂性急剧增长,其开发活动更加难以控制。在软件工程领域中,那些传统的定性的方法和简单的统计技术难以解决数据及信息量爆炸式增长所带来的困扰。因此,从程序、文档及相关数据集中发现规律并用以指导软件工程活动就显得尤为必要。在程序代码分析、故障检测、软件项目管理、开源软件开发等软件活动中运用数据挖掘技术，主要是采用有效的分类、聚类、预测和统计分析技术从各种软件资源库中发现潜在的知识、规则等用以反馈指导软件工程活动,以达到改进软件产品质量、提高开发效率的目的。

2) Transportation.
将数据挖掘技术应用于智能交通系统中,利用挖掘得到的模式对交通管理决策提供有效支持。
3) Sociology.

2. Describe the steps involved in data mining when viewed as a process of knowledge discovery.

3. Classify the following attributes as binary, discrete, or continuous. Also classify them as qualitative (nominal or ordinal) or quantitative (interval or ratio). Some cases may have more than one interpretation, so briefly indicate your reasoning if you think there may be some ambiguity.
Example: Age in years. Answer: Discrete, quantitative, ratio
(a) Number of patients in a hospital. 
(b) ISBN numbers for books. (Look up the format on the Web.) 
(c) Military rank.
(d) Ability to pass light in terms of the following values: opaque, translucent, transparent. 
(e) Density of a substance in grams per cubic centimeter. 
(f) Distance from the center of campus.

4. Briefly outline how to compute the similarity between objects described by the following, you can propose your own methods.
(a)Nominal attributes
(b)Asymmetric binary attributes
(c)Numeric attributes
(d)Term-frequency vectors


//0327
每天学点python：
	http://segmentfault.com/q/1010000000160563
	...而且，这个步进值同样可以是负数，对应的形式就是seq[end:start:step]，在start<=索引值<end中，隔|step|-1个字符来截取元素。我是这样来理解步进值的，它是规定了切片操作的方向，正值代表的是正方向（从左向右）切片，负值代表的是反方向切片。
	所以a[-4:-16:-3]的意思就是：反方向从-16<=索引值<-4的元素中，隔两个元素来截取。
	所以当你想要把这个序列反转的时候，你就可以从反方向截取所有元素a[::-1]。

	http://stackoverflow.com/questions/12142133/how-to-get-first-element-in-a-list-of-tuples
	How to get first element in a list of tuples?
	b = [int(i[0]) for i in a]
	new_list = [ seq[0] for seq in yourlist ]


//0328,周五晚
1.python数据分析，以及代码vulcan
2.omp
3.读书


//0329.openmp

gcc -fopenmp –o t10 t10.c
export OMP_NUM_THREADS=2

	1.重要概念。有些子诧只能用亍lexical extent,有些子诧可用亍dynamic extent
	2.#pragma omp parallel clause1 clause2 ...

		if(scalar-expression)
		num_threads(integer-expression )
		default(shared | none)
		private(list)
		firstprivate(list)
		shared(list)
		copyin(list)
		reduction(operator : list)
		
	3.工作分担构件,#pragm omp parallel 构件结束时会有一个隐式同步(费时操作,可以丌同步,需用nowait子语)


	4.#pragm omp for

		private( list)
		firstprivate( list)
		lastprivate(list)
		reduction( operator : list)
		schedule(kind[, chunk_size] )
		collapse(n )
		ordered
		nowait
	5.#pragma omp sections 每个section仅被一个线程执行一次

		private( list)
		firstprivate( list)
		lastprivate(list)
		reduction( operator : list)
		nowait

	6.组合构件：
		#pragma omp parallel for clause1 clause2 ...
		for(..) {...}
		
		#pragma omp parallel sections clause1 ...
		{ }
		减少两行代码,减少一次隐式同步。
		
	7.#pragma omp threadprivate(a)

	8.数据属性 PRIVATE, SHARED 
		生存期子语private(list)
		#pragma omp parallel private(a, b) 这个诧句表明发量a和b在每个线程均有丌同的值,是各个线程的本地发量
		实现机制:当一个发量被指定为私有,所有线程在迚入幵行区域的时候,立刻创建一个相同类型的新发量,在整个幵行区域内,线程使用新发量代替原始发量
		注意：
			每个线程都为私有发量创建一个新发量,这很耗资源
			or循环中的计数发量,和指定为threadprivate的发量,即使没有使用private子句显式地指定,但它们均自劢成为每个线程的私有发量
		
		生存期子语shared(list)
		#pragma omp parallel shared(c, d)
		这行代码指明,在导诧对#pragma omp parallel作用范围内,发量c和d的值能被所有线程看到
		注意：
			所有线程访问相同的内存地址来读写共享发量d,幵丌意味着线程x修改d的值后,线程y就能立即看到d的新值
			Openmp的具体实现(如gcc),可能会将共享发量d的值存入一个临时发量,幵在后面更新d(丌一定是立即更新)
			强制更新共享发量需用导诧#pragma omp flush
			多个线程同时读写相同内存地址时,结果丌定,编程时程序员必须避免这种情况。可以选用#pragma ompatomic原子操作共享发量
			
		default(shared|none)
		#pragma omp parallel default(shared) private(a)
		default(none):所有发量必需用private/shared子诧显示地声明属性,除非它是threadprivte发量、for循环的计数发量
		
		firstprivate(list)子语
		#pragma omp parallel private(a) firstprivate(b)
		在幵行区域开启处,a的值丌定,b的值延续前面串行区域的值(b=1) （个人理解：新开辟加复制初始化（赋值））
		
		lastprivate(list)子语
		只有一个线程的发量赋值,耗时丌多
		OpenMP诧句结束时,隐式同步将发量值带回。如果使用了nowait子诧,带回的发量值丌确定
		
		
			
	9. OpenMP中数据属性相关子句详解 http://blog.csdn.net/gengshenghong/article/details/6985431

		A private variable within the parallel region has no storage association with the same variable outside of the region. 
		firstprivate解决了进入并行区的问题，即在进入并行区域的每个线程的副本变量使用并行区域外的共享变量进行一个初始化的工作，
		那么下面有一个问题就是，如果希望并行区域的副本变量，在退出并行区的时候，能反过来赋值给并行区域外的共享变量，那么就需要依靠lastprivate了
		
		NOTE!!!!!!!!!!!!!!!!!!!!!!!：
		
		并行区域内有多个线程，是哪一个线程的副本用于赋值呢？
		是否是最后一个运行完毕的线程？否！OpenMP规范中指出，如果是循环迭代，那么是将最后一次循环迭代中的值赋给对应的共享变量；如果是section构造，那么是最后一个section语句中的值赋给对应的共享变量。注意这里说的最后一个section是指程序语法上的最后一个，而不是实际运行时的最后一个运行完的。
		

		threadprivate只能用于全局变量或静态变量	threadprivate和上面几个子句的区别在于，threadprivate是指令，不是子句。threadprivate指定全局变量被OpenMP所有的线程各自产生一个私有的拷贝，即各个线程都有自己私有的全局变量。一个很明显的区别在于，threadprivate并不是针对某一个并行区域，而是整个于整个程序，所以，其拷贝的副本变量也是全局的，即在不同的并行区域之间的同一个线程也是共享的。


	10.reduction(operator:list)子语 ————a = a op expr is called a reduction operation.
		当一个发量被声明为shared,所有的线程都会修改它的值,因此必须保证每次只有一个线程在修改,否则结果丌确定
		#pragma omp for reduction(+:a)
		将一组发量(list)不一个运算符关联起来,每当list中的发量不operator一起使用时,openmp就保证丌让多线程同时修改一个内存地址
		
		实现机制:每个线程为list中的发量创建一个私有副本幵刜始化,在后续计算中,有副本代替原共享发量。幵行构件结束处,用所有线程的私有副本来更新共享发量
		注意：
			创建副本消耗资源(内存)
			如果隐式同步被叏消了,共享发量的值丌确定
			丌保证归约计算结果不串行结果完全一致,因为计算顺序丌同
		
		
	11.num_threads子语：#pragma omp parallel num_threads(4)
	12.run-time library
		start = omp_get_wtime(); //omp_get_wtime返回墙钟时间,以秒为单位

	13.Practical Issue
		OpenMP creates separate data stack for every worker thread to store copies of private variables (master thread uses regular stack)

		Size of these stacks is not defined by OpenMP standards 
			Intel compiler: default stack is 4MB
			gcc/gfortran: default stack is 2MB
		Behavior of program undefined when stack space exceeded 
			Although most compilers/RT will throw seg fault
		To increase stack size use environment var OMP_STACKSIZE, e.g.
			 export OMP_STACKSIZE=512M
			 export OMP_STACKSIZE=1GB
		To make sure master thread has large enough stack space use
			ulimit -s command (unix/linux).


	14.So far only discussed parallel regions that all did same work. Not very useful. What we want is to share work among all threads so we can solve our problems faster.

	 
	15.With static scheduling the number of iterations is evenly distributed among all openmp threads (i.e. Every thread will be assigned similar number of iterations)
	16.With a dynamic schedule new chunks are assigned to threads when they 
	come available
	17.Another work sharing directive (although it doesn't really share work) OpenMP provides is !$OMP SINGLE. When encountering a single directive only one member of the team will execute the code in the block

		Other threads will wait
		Useful for thread-unsafe code
		Useful for I/O operations
		
	18.注意，循环迭代变量在循环构造区域里是私有的，声明在循环构造区域内的自动变量都是私有的。这一点其实也是比较容易理解的，很难想象，如果循环迭代变量也是共有的，OpenMP该如何去执行，所以也只能是私有的了。即使使用shared来修饰循环迭代变量，也不会改变循环迭代变量在循环构造区域中是私有的这一特点

		当然，在循环并行区域内，循环迭代变量是不可修改的。如i++会报错
	19.copyin子句用于将主线程中threadprivate变量的值拷贝到执行并行区域的各个线程的threadprivate变量中，从而使得team内的子线程都拥有和主线程同样的初始值。
		#pragma omp parallel for copyin(A)
		copyin中的参数必须被声明成threadprivate的。
	20.copyprivate子句用于将线程私有副本变量的值从一个线程广播到执行同一并行区域的其他线程的同一变量。
		说明：copyprivate只能用于single指令的子句中，在一个single块的结尾处完成广播操作。copyprivate只能用于private/firstprivate或threadprivate修饰的变量。
	21.reduction的作用：A private copy for each list variable is created for each thread. At the end of the reduction, the reduction variable is applied to all private copies of the shared variable, and the final result is written to the global shared variable.


	22.进入并行区域后，team内的每个新的线程都会对reduction变量构造一个副本，比如上面的例子，假设有四个线程，那么，进入并行区域的初始化值分别为：sum0=100,sum1 = sum2 = sum3 = 0.为何sum0为100呢？因为主线程不是一个新的线程，所以不需要再为主线程构造一个副本
		sum' = sum0'+sum1'+sum2'+sum3'
	经过测试，其实不符合这一规则的时候，编译运行都不会有问题，有些甚至也是可以解释清楚为什么结果是这样的，但是无论如何，一般使用reduction的时候，都是一些迭代的情况，语义应该是很清楚的情况

		reduction可能会很慢，除非有优化
		
	23.schedule子句是专门为循环并行构造的时候使用的子句，只能用于循环并行构造（parallel for）中。
		schedule(kind[, chunk_size])

		• static: 
			Iterations are divided into chunks of size chunk_size. Chunks are assigned to threads in the team in round-robin fashion in order of thread number.
		• dynamic: 
			Each thread executes a chunk of iterations then requests another chunk until no chunks remain to be distributed.
		• guided: 
			Each thread executes a chunk of iterations then requests another chunk until no chunks remain to be assigned. The chunk sizes start large and shrink to the indicated chunk_size as chunks are scheduled.
		• auto: The decision regarding scheduling is delegated to the compiler and/or runtime system.
		• runtime: The schedule and chunk size are taken from the run-sched-var ICV

		guided灵活度最高
		
		大部分的编译器实现，在没有使用schedule子句的时候，系统就是采用static方式调度的。
		对于schedule(static,size)的含义，OpenMP会给每个线程分配size次迭代计算。这个分配是静态的，“静态”体现在这个分配过程跟实际的运行是无关的，可以从逻辑上推断出哪几次迭代会在哪几个线程上运行。
		
		对于dynamic，没有size参数的情况下，每个线程按先执行完先分配的方式执行1次循环	dynamic也可以有一个size参数，size表示，每次线程执行完（空闲）的时候给其一次分配的迭代的数量，如果没有知道size（上面的分析），那么每次就分配一个迭代。
		类似于动态调度，但每次分配的循环次数不同，开始比较大，以后逐渐减小。size表示每次分配的迭代次数的最小值，由于每次分配的迭代次数会逐渐减少，较少到size时，将不再减少。如果不知道size的大小，那么默认size为1，即一直减少到1

reduction可能会很慢，除非有优化


阅读示例代码笔记（http://people.sc.fsu.edu/~jburkardt/cpp_src/mxv_openmp/mxv_openmp.html）
	1.hello程序：
		1.所谓private，想一下如果把内存分开，是否有需要共享的信息？
		2.cout << "  This is process " << id << "\n";//printf之类的操作延迟大且不稳定，并且当多个线程的管道汇集到一个管道时会有错位
			比如本程序的一个可能输出是：
				This is process   This is process 03

				This is process 1
				This is process 2


	2.MXN：
		# pragma omp parallel shared ( m, n, a, x, y ) private ( i, j )
		# pragma omp for
		  for ( i = 0; i < m; i++ )
		  {
			y[i] = 0.0;
			for ( j = 0; j < n; j++ )
			{
			  y[i] = y[i] + a[i+j*m] * x[j];
			}
		  }
		 像这种代码，看着很复杂，实际上看看变量在每个循环单位中是否独立就能判断是否可以数据共享。这里y[i]只利用了i水平的信息而没有用到i-1或i+1
	3.prime

		# pragma omp parallel \
		  shared ( n ) \
		  private ( i, j, prime )

		# pragma omp for reduction ( + : total )
		  for ( i = 2; i <= n; i++ )
		  {
			prime = 1;

			for ( j = 2; j < i; j++ )
			{
			  if ( i % j == 0 )
			  {
				prime = 0;
				break;
			  }
			}
			total = total + prime;
		  }
	4.pi
		//  Discussion:
		//
		//    The calculation is based on the formula for the indefinite integral:
		//
		//      Integral 1 / ( 1 + X**2 ) dx = Arctan ( X ) 
		//
		//    Hence, the definite integral
		//
		//      Integral ( 0 <= X <= 1 ) 1 / ( 1 + X**2 ) dx 
		//      = Arctan ( 1 ) - Arctan ( 0 )
		//      = PI / 4.
		//
		//    A standard way to approximate an integral uses the midpoint rule.
		//    If we create N equally spaced intervals of width 1/N, then the
		//    midpoint of the I-th interval is 
		//
		//      X(I) = (2*I-1)/(2*N).  
		//
		//    The approximation for the integral is then:
		//
		//      Sum ( 1 <= I <= N ) (1/N) * 1 / ( 1 + X(I)**2 )
		//
		//    In order to compute PI, we multiply this by 4; we also can pull out
		//    the factor of 1/N, so that the formula you see in the program looks like:
		//
		//      ( 4 / N ) * Sum ( 1 <= I <= N ) 1 / ( 1 + X(I)**2 )
		//
		//    Until roundoff becomes an issue, greater accuracy can be achieved by 
		//    increasing the value of N.


//0329,会的多
1.在eclipse中配置openmp：http://www.ipd.uni-karlsruhe.de/multicore/research/download/HowToGuide-OpenMP.pdf
2.怎么在eclipse编译时忽略（exclude）一些文件夹？通过设置过滤器。这个过滤器是eclipse范围的：File > Properties > Resource > Resources Filters

=====================vulcan=====================
1.logging标准模块
	从Python2.3起,Python的标准库加入了logging模块.logging模块给运行中的应用提供了一个标准的信息输出接口.典型的logging机制实现是把要输出的数据简单地写到一个txt文件中去.写log文件的方式是一种常见的打log的方式,而logging模块提供的更多,它可以把输出信息输出到所有类文件的对象中去,甚至TCP和UDP的sockets,email服务器,Unix的syslog系统,NT系列的事件log系统,内存的buffer和HTTP服务器,当然还有”真正的”文件中去.
	Logging库被设计成模块的方式,它提供了以下几个子模块:loggers,handlers,filters和formatters.Loggers把应用需要直接调用的接口暴露出来.Handlers把log记录发到相应的目的地.Filters决定哪些记录需要发给handler.Formatters定义了log记录的输出格式.
//0330,barrier
1.密码学 2014-03-31 
	没有要求写实验报告，不过每题都要有分析
2.OpenMP编程 2014-03-31 
	请将代码和实验报告打包提交。
3.第一次实验：存储层次分析及程序优化 2014-04-02 

4.实验四：进程管理

//0331,the Last Day
1.Optimize pi with openmp
	优化策略：
		1.多种并行方式实验
		2.静态和动态试验 schedule
		3.#pragma omp section
		4.nowait
		
1 定义并行区
2 设置并行度
3 并行结构
4 并行区数据管理
5 同步机制



维度：
	 1.线程数
	 2.N
	 3.schedule
	 4.（串）并行方式

使用OpenMP对串行程序pi_serial.c进行并行
及优化,并对并行之后的程序进行性能分
析
•完成多种OpenMP实现(>=5),并提交代码
•分析性能结果,并提交分析报告
• 不同实现的性能差别原因何在?
• 能否用更多的核获得线性加速效果?为什么?

	1.随着num——steps基本成线性
	2.线程数影响较大
	3.critical随着线程数增加反而性能降低


//0401,OS lab4,lab5

贫困与饥荒，阿玛迪亚
an inconvenient truth

//0402,R
1.2.10
	A data frame is similar to a matrix but with named columns. However, contraryto matrices data frames may include data of different type on each column. In this sense they are more similar to lists, and in effect, for R data frames are a pecial class of lists.


//0403
周四晚：
	1.vulcan，
	2.Python for Data Analysis
	3.网络渗透
	4.读书
	
	//Python for Data Analysis
1.为什么有必要了解python的数据处理？
	因为python与R不同，他同时是一种脚本，他的灵活性是无可替代的。

	//网络渗透技术
	//lab5
1.在icode中添加tf设置
2.更新ticks处理
3.注意！user_main的初始化（程序加载）是他自己（处于new态）完成的（处于ready态）！而不是父进程(init)帮他完成;所以一切数据都是他自己的。这个初始化是他通过系统调用实现的

4.do_fork(proc.c)->copy_mm(proc.c)->dup_mmap(vmm.c)->copy_range(pmm.c)

cprintf("HERE!!\n");

//0406
	//微计算机
分析8251的VHDL设计，画出其接收过程的有限状态自动机
两个星期时间，上交DOC或PDF
无相关文件

关于作业一的截止日期
正文	 各位同学：
    很抱歉，忘记了将串口实现的VHDL源码上载，耽误了各位同学做作业，故将作业一的截止日期向后延一个星期。 

	//evening
1.ted
2.lab2
3.lab3
4.～lecture4（5）

The page directory entry corresponding to the virtual address range
 * [VPT, VPT + PTSIZE) points to the page directory itself. Thus, the page
 * directory is treated as a page table as well as a page directory.

boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;

如何保证此时内核依然能够正常工作呢?其实只需让低地址目录
表项的内容等于以 KERNBASE 开始的高地址目录表项的内容即可。目前内核大小不超过 4M (实际
上 是 3M, 因 为内 核 从 0x100000 开 始编 址 ),这 样 就只 需 要 让页 表 在 0~4MB 的线 性 地 址与
KERNBASE ~ KERNBASE+4MB 的线性地址获得相同的映射即可,都映射到 0~4MB 的物理地址空
间,具体实现在 pmm.c 中 pmm_init 函数的语句

vector128(vectors.S)--> __alltraps(trapentry.S)-->trap(trap.c)-->trap_dispatch(trap.c)......
static inline void print_pgfault(struct trapframe *tf) {
	/* error_code:
	 * bit 0 == 0 means no page found, 1 means protection fault
	 * bit 1 == 0 means read, 1 means write
	 * bit 2 == 0 means kernel, 1 means user
	 */
}
swap_entry_t 右移8位，再左移3位得到扇区号


tf:中断帧的指针,总是指向内核栈的某个位置:当进程从用户空间跳到内核空间时,中断
帧记录了进程在被中断前的状态。当内核需要跳回用户空间时,需要调整中断帧以恢复让进
程继续执行的各寄存器值
（问：内核线程呢？）

mm 数据结构是用来实现用户空间的虚存管理的,
但是内核线程没有用户空间,它执行的只是内核中的一小段代码(通常是一小段函数),所
以它没有 mm 结构,也就是 NULL。


	//http://stackoverflow.com/questions/2711044/why-doesnt-linux-use-the-hardware-context-switch-via-the-tss
The x86 architecture includes a specific segment type called the Task State Segment (TSS), to store hardware contexts. Although Linux doesn't use hardware context switches, it is nonetheless forced to set up a TSS for each distinct CPU in the system.

I am wondering:
	Why doesn't Linux use the hardware support for context switch?
	Isn't the hardware approach much faster than the software approach?
	Is there any OS which does take advantage of the hardware context switch? Does windows use it?

详见page.269，“铁打的营盘流水的兵”，TSS成了公共资源，只更改ss0和esp0

补：
中断处理中硬件负责完成的工作...
4) CPU 会根据 CPL 和中断服务例程的段描述符的 DPL 信息确认是否发生了特权级的转
换。比如当前程序正运行在用户态,而中断程序是运行在内核态的,则意味着发生了特
权级的转换,这时 CPU 会从当前程序的 TSS 信息(该信息在内存中的起始地址存在 TR
寄存器中)里取得该程序的内核栈地址,即包括内核态的 ss 和 esp 的值,并立即将系统
当前使用的栈切换成新的内核栈。这个栈就是即将运行的中断服务程序要使用的栈。紧
接着就将当前程序使用的用户态的 ss 和 esp 压到新的内核栈中保存起来
5) CPU 需要开始保存当前被打断的程序的现场(即一些寄存器的值),以便于将来恢复被
打断的程序继续执行。这需要利用内核栈来保存相关现场信息,即依次压入当前被打断
程序使用的 eflags,cs,eip,errorCode(如果是有错误码的异常)信息;



process state changing:
                                            
  alloc_proc                                 RUNNING
      +                                   +--<----<--+
      +                                   + proc_run +
      V                                   +-->---->--+ 
PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
                                           A      +                                                           +
                                           |      +--- do_exit --> PROC_ZOMBIE                                +
                                           +                                                                  + 
                                           -----------------------wakeup_proc----------------------------------

proc_run：
	load_esp0(next->kstack + KSTACKSIZE);
	lcr3(next->cr3);
	switch_to(&(prev->context), &(next->context));
其中：
	load_esp0(uintptr_t esp0) {
		ts.ts_esp0 = esp0;
	}

伪中断的实现：
	根据 context.eip 的赋值,可以知道 initproc 实际开始执行的地方在
	forkret 函数(主要完成 do_fork 函数返回的处理工作)处。至此,initproc 内核线程已经做好准备执行
	了。
	其实更主要的是tf直接存储到栈中。

	forkrets:
    # set stack to this new process's trapframe
    movl 4(%esp), %esp
    jmp __trapret

在确定了用户进程的执行代码和数据,以及用户进程的虚拟空间布局后,我们可以来创建用户
进程了。在本实验中第一个用户进程是由第三个内核线程 user_main 通过把 hello 应用程序执行码覆
盖到原来的用户虚拟内存空间来创建的


对比内核线程创建与用户线程创建

mm_create
setup_pgdir
mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0)
pgdir_alloc_page
memcpy(page2kva(page) + off, from, size);
mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL))



///////////
Steps in Making a System Call ：
	alltraps(): in kern/trap/trapentry.S
	trap(): tf->trapno == T_SYSCALL , in kern/trap/trap.c
	syscall():  tf->tf_regs.reg_eax ==SYS_read, in /kern/syscall/syscall.c
	sys_read(): get fd, buf, length from tf->sp,  in kern/syscall/syscall.c 
	sysfile_read(): read file content, in kern/fs/sysfile.c 
	trapret(): in kern/trap/trapentry.S

Interrupt handling in x86 architecture – Locating ISRs


Interrupt: hardware device requests OS service
CPU interrupts current execution and jumps to interrupt handler, and returns when done
None of this is visible to user program
Exceptions: user program acts illegally
CPU executes exception handlers
May cause abnormal execution flow (such as terminated)
System calls: user program requests OS service
User program execute a trap instruction
OS identifies the type of service and parameters, and executes the requested service
OS returns to user program when done


Though writes are more efficient than reads (why?)

//0408,OS 考试

	//DIP
	傅里叶频域实际上是人脑处理之前的故事。
	通过fft进行ps或者进行检查ps痕迹
	
一、课堂展示及讨论-30分
分组讨论：选择课程内容，以小组形式开展不少于三次讨论（助教参与），完成一次课堂展示
二、期中小短文-20分
以“中美比较”为题，写作一篇小短文，形式不限，鼓励创新形式及题材，4月29日前提交至网络学堂
三、期末论文-40分
选择课程内容，以“中国道路”为题，结合课程所讲内容，完成一篇学术论文（字数3000字以上），6月24日前提交至网络学堂
四、考勤及签到-10分
无故缺勤一次扣2分，超过五次者最高成绩不超过70分
五、加分：网络学堂讨论-5分
鼓励同学在网络学堂发起问题和讨论，积极参加讨论者酌情加分，最高不超过5分


//0410,R

1.
form of indexing a data frame, by usinga logical expression as a row selector
	algae[algae$NH4 > 19000,]
2.> df
	  id   var1   var2   var3   var4
	1  1    red    red yellow orange
	2  2 yellow yellow orange  green
	3  3  green  green  green yellow

	apply(df,1,function(x) names(which.max(table(x))))
	[1] "red"    "yellow" "green" 

	//http://stackoverflow.com/questions/19982938/how-to-find-the-most-frequent-values-across-several-columns-containing-factors


3.Selecting only numeric columns from a data frame

	//http://stackoverflow.com/questions/5863097/selecting-only-numeric-columns-from-a-data-frame
	nums <- sapply(x, is.numeric)
	x[ , nums]
	
4.Using apply, sapply, lapply in R
	//http://www.r-bloggers.com/using-apply-sapply-lapply-in-r/
	R语言 apply函数家族详解
	//http://blog.sina.com.cn/s/blog_403aa80a010174dj.html
	
5.bank_new[,sapply(bank_new, is.numeric)] == bank_new[sapply(bank_new, is.numeric)]
6.
7.
8.
9.
10.
11.

/////////////////////////////////////////////////////////////////////////	
1.	
2.
数据预处理

数据缺失
> length(bank[is.na(bank)])
[1] 5254

• 剔除缺失值
	bank_nona <- na.omit(bank)
	> nrow(bank_nona)
	[1] 764
	
	note：we may remove some observations because the number of unknown values is so high that they are almost useless, and even complex methods of filling in these values will fail on them.
  
  
  优化版：
     
    > summary(bank$poutcome)
	failure   other success    NA's 
    490     197     129    3705 
    
	
	bank_nopout <- bank[,-16]
	> nrow(bank_nopout)
	[1] 4521
	> ncol(bank_nopout)
	[1] 16
	> length(bank_nopout[is.na(bank_nopout)])
	[1] 1549
	
	
	> summary(bank$contact)
	cellular telephone      NA's 
     2896       301      1324 
     
	bank_nocont <- bank[,-c(9,16)]
	> nrow(bank_nocont)
	[1] 4521
	> ncol(bank_nocont)
	[1] 15
	> length(bank_nocont[is.na(bank_nocont)])
	[1] 225
	
	
	> summary(bank$education)
	primary secondary  tertiary      NA's 
      678      2306      1350       187 
    /*  
	bank_noedu <- bank[,-c(4,9,16)]
	> nrow(bank_noedu)
	[1] 4521
	> ncol(bank_noedu)
	[1] 14
	> length(bank_noedu[is.na(bank_noedu)])
	[1] 38
	*/
	
	> summary(bank$job)
       admin.   blue-collar  entrepreneur     housemaid    management 
          478           946           168           112           969 
      retired self-employed      services       student    technician 
          230           183           417            84           768 
   unemployed          NA's 
          128            38 
     /*
     bank_nojob <- bank[,-c(2,4,9,16)]
    > nrow(bank_nojob)
	[1] 4521
	> ncol(bank_noedu)
	[1] 14
	> length(bank_nojob[is.na(bank_nojob)])
	[1] 0
	*/
	
	note:由于na最多只分布在两列，所以我们不再对observation(行)进行剔除
	
• 用最高频率的值补充

	bank_new[is.na(bank_new$education),'education'] <- mostfac(bank_new$education)
	bank_new[is.na(bank_new$job),'job'] <- mostfac(bank_new$job)
	bank_most <- bank_new
	 
• 通过变量相关性补充
	bank_new <- bank_nocont
	
	note:An alternative to getting less biased estimators of the unknown values is to explore the relationship between variables.

	> symnum(cor(bank_new[,sapply(bank_new, is.numeric)],use="complete.obs"))
				 a b dy dr c pd pr
		age      1                
		balance    1              
		day          1            
		duration        1         
		campaign           1      
		pdays                1    
		previous             .  1 
		attr(,"legend")
		[1] 0 ‘ ’ 0.3 ‘.’ 0.6 ‘,’ 0.8 ‘+’ 0.9 ‘*’ 0.95 ‘B’ 1
	
	
	> symnum(cor(sapply(bank_new, as.numeric),use='complete.obs'))
			  a j mr e df b h l dy mn dr c pd pr y
	age       1                                   
	job         1                                 
	marital   .   1                               
	education        1                            
	default            1                          
	balance               1                       
	housing                 1                     
	loan                      1                   
	day                         1                 
	month                          1              
	duration                          1           
	campaign                             1        
	pdays                                  1      
	previous                               .  1   
	y                                 .          1
	attr(,"legend")
	[1] 0 ‘ ’ 0.3 ‘.’ 0.6 ‘,’ 0.8 ‘+’ 0.9 ‘*’ 0.95 ‘B’ 1


	问题：
		1.至少对于小样本来说，这个方法是不适用的
		2.原因之一：na所在的都是nonnumeric
		3.原因之二：即使是将factor数字化，也并没有发现很强的线性相关性。（当然，这可能与factor的数字化顺序有关）
		
		4.问题在于，是否有可能是其他类型的相关关系呢？比如"spearman","pearson" and "kendall"等，这可能需要我们进行可视化后在回来修正。
		
			symnum(cor(sapply(bank_new, as.numeric),use='complete.obs',method = 'kendall'))
			
			> symnum(cor(sapply(bank_new, as.numeric),use='complete.obs',method = 'kendall'))
		  a j mr e df b h l dy mn dr c pd pr y
age       1                                   
job         1                                 
marital   .   1                               
education        1                            
default            1                          
balance               1                       
housing                 1                     
loan                      1                   
day                         1                 
month                          1              
duration                          1           
campaign                             1        
pdays                                  1      
previous                               *  1   
y                                            1
attr(,"legend")
[1] 0 ‘ ’ 0.3 ‘.’ 0.6 ‘,’ 0.8 ‘+’ 0.9 ‘*’ 0.95 ‘B’ 1


			symnum(cor(sapply(bank_new, as.numeric),use='complete.obs',method = 'spearman'))
			
			> symnum(cor(sapply(bank_new, as.numeric),use='complete.obs',method = 'spearman'))
			
						  a j mr e df b h l dy mn dr c pd pr y
				age       1                                   
				job         1                                 
				marital   .   1                               
				education        1                            
				default            1                          
				balance               1                       
				housing                 1                     
				loan                      1                   
				day                         1                 
				month                          1              
				duration                          1           
				campaign                             1        
				pdays                                  1      
				previous                               B  1   
				y                                 .          1
				attr(,"legend")
				[1] 0 ‘ ’ 0.3 ‘.’ 0.6 ‘,’ 0.8 ‘+’ 0.9 ‘*’ 0.95 ‘B’ 1
			
		note：For cor(), if method is "kendall" or "spearman", Kendall's tau or Spearman's rho statistic is used to estimate a rank-based measure of association. These are more robust and have been recommended if the data do not necessarily come from a bivariate normal distribution.	
			
		
• 通过探索案例之间的相似性

	Instead of exploring the correlation between the columns (variables) of a data set, we can try to use the similarities between the rows (observations) to fill in the unknown values.
	
	The approach described in this section assumes that if two  samples are similar, and one of them has an unknown value in some variable, there is a high probability that this value is similar to the value of the other sample.
	
	we need to define the notion of similarity. This notion is usually defined by using a metric over the multivariate space of the variables used to describe the observations. Many metrics exist in the literature, but a common choice is the euclidean distance.
	
	The method we will describe below will use this metric to
	find the 10 most similar cases of any water sample with some unknown value
	in a variable. With these 10 cases, we will calculate their median value on this
	variable and use this to fill in the unknown.
	
	> library(cluster)
	> dist.mtx <- as.matrix(daisy(bank_new,stand=T))

	我们以第4430条记录为例：
	> sort(dist.mtx[4430,])[2:11]
       2031        2733        2352        4205        4441        3127 
	0.008238515 0.009975275 0.012382685 0.014294005 0.014913711 0.015330650 
		   3898         179        1189        2146 
	0.015676454 0.016345114 0.016687320 0.017705635 
	
	> bank_new[4430,]
		 age  job marital education default balance housing loan day month
	4430  45 <NA> married   primary      no      44      no   no  11   jun
		 duration campaign pdays previous  y
	4430       81        1    -1        0 no
	
	> bank_new[c(4430,2031),]
		 age        job marital education default balance housing loan day
	4430  45       <NA> married   primary      no      44      no   no  11
	2031  47 management married      <NA>      no     150      no   no   9
		 month duration campaign pdays previous  y
	4430   jun       81        1    -1        0 no
	2031   jun       52        1    -1        0 no
	
	> mostfac(bank_new[c(as.integer(names(sort(dist.mtx[4430,])[2:11]))),'job'])
	[1] "blue-collar"
	
	这里有一个问题是（正如一开始提到的），bank client data和related with the last contact of the current campaign这两类信息之间的相关性。不过我们在寻找近似记录的时候并没有考虑。
	
	> apply(as.matrix(bank_new[c(as.integer(names(sort(dist.mtx[4430,])[2:11]))),which(is.na(bank_new[4430,]))]),2,mostfac)
	
		fill.similar <- function(x) {
		  dist.mtx <- as.matrix(daisy(x,stand=T))
		  for(r in which(!complete.cases(x)))
			x[r,which(is.na(x[r,]))] <-apply(as.matrix(x[c(as.integer(names(sort(dist.mtx[r,])[2:11]))),which(is.na(x[r,]))]),2,central.value)
		  return(x)
		}
		
	> bank_new <- fill.similar(bank_new)
	
	
3.特征选择:随机森林



4.预处理评价模型：
	3.1 weka对比
		//http://6728496.blog.51cto.com/6718496/1337462
	3.2 
	
/////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////
数据可视化
 相关函数
• 绘图 plot()
• 柱状图 hist()
• 盒图 boxplot()
• 散点图 pairs()
• 相关矩阵 pimage()
 相关包
• graphics, ggplot, lattice, seriation, colorspace 等
• ?lattice 可以看 lattice 包的具体描述
• 例子: summary(algae)
• hist(algae$mxPH, prob=T)
• 课程 ppt 中的各种图参考 R 语言 visualization.txt


We first assumed that there were several irrelevant input
attributes that difficult the DM algorithm learning process
(e.g. by increase of noise). To test this hypothesis, we went
back to the Data Understanding phase and analyzed which
attributes could influence the target. For this purpose, the
rattle tool was used, in particular its graphical capabilities.
For example, Figure 2 shows that the Sex attribute can be
discarded, since the rate of successes for Male and Female
is almost the same. With a similar analysis, we deleted half
(29) of the considered inputs, leading to 29 input variables
and 1 target output.


 gbank_pair_full <-pairs(bank_new[,-1],main="Bank Data", pch=21,bg = c("red", blue")[unclass(bank_new$y)])

/*************************************
 * 
 * 注：R语言的笔记转至$RHOME/RGraphNote.txt
 * 
 * ***********************************/



//0411,CA-HW3

第三次作业
1  教材（计算机系统结构教程 张晨曦 王志英 沈立 刘侬 编著  清华大学出版社（2009年第一版））           
 Page91    习题3.8,   习题3.9
 Page92    习题3.10, 习题3.11
2  学习教材3.5节：流水线的实现  （page 83~90），回答以下问题:
（该题目内容见附件，其实也就是Sec10中最后那道题）

考虑到即将迎来小长假，为了能让大家度过一个美好难忘的假期，特别将DDl延迟了一天！怎么样~！有没有一种大赦天下的感觉！

跪谢就免了

1.lab6
2.密码学
3.PCI
4.R语言
5.数值分析

//0412,exp1

evening shced:

1.R语言
2.lab6
3.TED

9,0.093750
12,0.080357
14,0.230769
27,0.105882
32,0.900000
17,0.010417
22,0.012048
13,0.008333
23,0.008264

res/input0.txt

res/dblp-200K-per50.txt  res/dblp-80K-per50.txt


tfac增大，现象是mem减小，time增加
由于此时heapmerge规模增加，verification规模减小，所以断定time主要由heapmerge决定，而mem主要由verification决定。
从而找到mem的病因(mat)。


//0413
task
1.lab6
2.pci
3.cript
4.R

	int(1):
	T/2: 4.317867040634
	T/5: 2.506953001022
	T/6: 2.328919887543
	T/7: 2.269217014313
	T/8: 2.281599044800
	T/9: 2.356130838394
	T/10:2.557667016983
	T/15:4.194758176804
	T/20:8.195286035538
	T/25:14.972291946411


	PCI配置读取实验
	实现一个C程序，扫描PCI总线并将PCI总线上所有设备的配置信息输出出来。
	使用给出的DOS VM做此实验。
	
	用于PCI配置读取实验的MS-DOS虚拟机，使用VMWare Workstation 6.5.2建立。
	在VMWare中运行起来之后，在DOS提示符下键入BC即可进入Borland C++集成环境（字符界面）。
	如果需要在Host OS（就是你机器上的操作系统）中使用虚拟机的虚拟硬盘来拷贝文件，可以通过菜单的VM -> Settings进入设置页面，然后点击Hardware里面的Hard Disk（IDE），在右侧的“Utility”按钮的下拉菜单中选择“Map...”来将虚拟硬盘映射到一个本地盘符然后再和本地硬盘一样操作。
	BTW：DOS需要“关机”操作就可以直接关闭系统。 
	

net use drive_letter: "\\vmware-host\Shared Folders
dos:
/*
 * sizeof(short) = 2
 * sizeof(int) = 2
 * sizeof(long) = 4
 * sizeof(char) = 1
 */



//0414
小实验二 近似连接
	请参考框架代码,实现SimJoiner类的方法:
		– joinJaccard()函数
		– joinED()函数
	• 请不要修改这两个方法的声明,可以根据需要自行添加其他方法。
	
	返回的结果,需按照id1、id2从小到大排序,且无重复结果

//0415,lab5 & 6

//0416,R
	
evening : similar join

从头开始，你会有怎样的思路？
首先就是O(n**2)算法，并且一开始我们会以为这就是是下限。
这种想法错误的原因在于我们忽视了一个问题，就是这不是随机的对象，固定的对象的特征是可以利用的。其结果就是哈希。
完全的哈希算法其实是性能的上限，也就是O(n)。不过由于存储限制难以实现。
不过通过哈希剪枝我们的性能已经有了很大的提升。下一步我们要做的，就是继续细致化这个剪枝。
这里利用的另一种思想就是分步，即逐渐优化。我们将剪枝同验正分开。这样可以对剪枝部分深化改革。

Positional Filter一般人想不到。有了prefix position filter自然就有了suffix position filter。

？？：count filter 实际上是一步验正

mismatching q-grams provide useful information 这让我们联想到字符串匹配的经典算法——KMP

Given a prefix set of q-grams, find the minimum prefix length that needs at least  + 1 edit operations to destroy them——————紧


	//《Efficient Similarity Joins for Near Duplicate Detection》

We propose a positional filtering principle, which exploits the ordering
of tokens in a record and leads to upper bound estimates of similarity scores. We show that
it is complementary to the existing prefix filtering method and can work on tokens both
in the prefixes and the suffixes.


//0418,ubuntu14.04,

	关于virtualbox的auto-resize不工作问题：
	//http://superuser.com/questions/579819/virtualbox-4-2-10-auto-resize-not-working-will-auto-resize-down-but-not-up-unle

	//http://www.ryukent.com/2013/01/fixed-ubuntu-12-10-64-bit-screen-not-resizing-in-a-virtualbox/

	最终，解决方案是安装vbox additions！

有更新的应该是Get(获取), 无更新是Hit(命中),次要目标获取失败是Ign(忽略)

	//http://www.mintos.org/config/close-amd-display.html
	关闭独显的比较靠谱的方法。



sunlight.thu@gmail.com


Analysis
• Describe and analyze each figure gen
erated from visualization
• Analyze the importance of the featur
es for classification


1.pair_full

gbank_pair_full <-pairs(bank_new[,-1],main="Bank Data", pch=21,bg = c("red", blue")[unclass(bank_new$y)])
names(bank_new)

panel.cor <- function(x, y, ...) {
  par(usr = c(0, 1, 0, 1))
  txt <- as.character(format(cor(x, y), digits=2))
  text(0.5, 0.5, txt, cex = 3* abs(cor(x, y)))
}
# pairs(iris[1:4], upper.panel=panel.cor)
pairs(bank_new[,-1],cex = 0.5,main="Bank Data", pch=21,bg = c("red", "blue")[unclass(bank_new$y)],upper.panel=panel.cor)

2.scatter

library(ggplot2)
par(mfrow = c(1,1),cex = 0.8)

qplot(jitter(as.numeric(job)),jitter(as.numeric(education)),data=bank_new,col= as.factor(y),jitter=T,main = "Bank: education vs job ",xlab = 'job',ylab = 'education')

qplot(jitter(as.numeric(job)),balance,data=bank_new,col= as.factor(y),jitter=T,main = "Bank: balance vs job ",xlab = 'job',ylab = 'balance',ylim = c(-1000,10000))

library(scatterplot3d)
scatterplot3d(x=jitter(as.numeric(job)),
              y=jitter(as.numeric(education)),
              z=jitter(as.numeric(marital)),
              xlab = 'job',ylab = 'education',zlab='marital',
              main ="Bank3D",
              pch=21,bg = c("red", "blue")[unclass(bank_new$y)],
              # cex.axis = 0.1
              # highlight.3d=TRUE, angle=20,type="h",
              )

3.
par(yaxs="i",las=1,mfrow = c(2,3))
hist(bank_new$age,
     prob=TRUE,col="black",border="white",
     xlab="age",
     main="Bank:age")
box(bty="l")
lines(density(bank_new$age,na.rm=T),col="red",lwd=4)
grid(nx=NA,ny=NULL,lty=1,lwd=1,col="gray")

hist(bank_new$balance,
     prob=TRUE,col="black",border="white",
     xlab="balance",
     main="Bank:balance")
box(bty="l")
lines(density(bank_new$balance,na.rm=T),col="red",lwd=4)
grid(nx=NA,ny=NULL,lty=1,lwd=1,col="gray")

hist(bank_new$duration,
     prob=TRUE,col="black",border="white",
     xlab="duration",
     main="Bank:duration")
box(bty="l")
lines(density(bank_new$duration,na.rm=T),col="red",lwd=4)
grid(nx=NA,ny=NULL,lty=1,lwd=1,col="gray")

hist(bank_new$campaign,
     prob=TRUE,col="black",border="white",
     xlab="campaign",
     main="Bank:campaign")
box(bty="l")
lines(density(bank_new$campaign,na.rm=T),col="red",lwd=4)
grid(nx=NA,ny=NULL,lty=1,lwd=1,col="gray")

hist(bank_new$pdays,
     prob=TRUE,col="black",border="white",
     xlab="pdays",
     main="Bank:pdays")
box(bty="l")
lines(density(bank_new$pdays,na.rm=T),col="red",lwd=4)
grid(nx=NA,ny=NULL,lty=1,lwd=1,col="gray")

hist(bank_new$previous,
     prob=TRUE,col="black",border="white",
     xlab="previous",
     main="Bank:previous")
box(bty="l")
lines(density(bank_new$previous,na.rm=T),col="red",lwd=4)
grid(nx=NA,ny=NULL,lty=1,lwd=1,col="gray")


4.box
boxplot(bank_new$balance ~ bank_new$job, data = bank_new,
        varwidth=TRUE,notch=TRUE,  
        ylim=c(-1000,20000),
        main="Summary of balance by job")
        
5.parallel 

parallelplot(bank_new[], 
             main="Parallel of Bank",  
             ylab="Measurement", 
             horizontal.axis = F,
             scales = list(x = list(rot = 90)),
             #groups = y,
             )

6.heat


challenges of frequent 
第5章-第4章，3道题

Selecting only numeric columns from a data frame  in r
	new_df <- df[sapply(df,is.numeric)]

验证是否有问题？没有问题.输入法有没有问题？没有问题。

这是怎么回事？为什么会有？？。，，。



//0419,cript
第二次大作业(分组密码与 Hash 函数)
《密码学原理与实践(第三版)》3.3,3.4,3.5(需要提交程序和代码)3.6(需要提交程序
和代码),3.7
《密码学原理与实践(第二版)》3.3,3.4,3.5(需要提交程序和代码)3.6(需要提交程序
和代码),3.7

补充
1、 生成 AES 的差分分布表(结果+程序代码)
2、 用时间-存储折中攻击破译 6 位(数字+字母,共(26 + 10)**6 ≈ 2 31.02 种可能结果)SHA-1
口令,要求:
a) 建立彩虹表(规模自拟);
b) 取 100 个数字+字母组合口令进行查找。


所谓分组密码，就是把代换密码中的字母等价成分组

分组是64bit，key是64bit，但是记得代换表并不真是2**64，因为这个算法是一个伪代换，即不完全代换表，所以是可突破的。

page40 is cript of a bmp,which gives a excellent way of visualziation the performancee of an cript algrithm



3.3 DES 证明：y' = c(y)
3.4 DES x DES
3.5 key generation of AES
3.6 encript with AES(128,10)
3.7 ECB,OFB,CBC,CFB

+1 AES 的差分分布表
+2 时间-存储折中攻击破译 SHA-1


哈希碰撞，从128bit缩减到60bit，大约就可以计算了

//0420 DIP review
1.


//0423,cuda install
Bumblebee:

sudo apt-get install git  
git clone git://github.com/Bumblebee-Project/bbswitch.git -b hack-lenovo  
cd bbswitch  
sudo mkdir /usr/src/acpi-handle-hack-0.0.1  
sudo cp Makefile acpi-handle-hack.c /usr/src/acpi-handle-hack-0.0.1  
sudo cp dkms/acpi-handle-hack.conf /usr/src/acpi-handle-hack-0.0.1/dkms.conf  
sudo dkms add acpi-handle-hack/0.0.1  
sudo dkms build acpi-handle-hack/0.0.1  
sudo dkms install acpi-handle-hack/0.0.1  
sudo echo acpi-handle-hack | sudo tee -a /etc/modules  
sudo update-initramfs -u




>和>>都是重定向输出
1> 指标准信息输出路径（也就是默认的输出方式）
2> 指错误信息输出路径
2>&1 指将标准信息输出路径指定为错误信息输出路径（也就是都输出在一起）

补充问题4<&0：
<和<<都是重定向输入
<0指标准输入路径
4<&0 指的是将文件描述符4指定为标准输入（实际可选4到9之间任意一个数字）

不知下面两句是否写得有点问题，或者是断章取义，总觉得前面可能有“|”符号
grep "standard"* > grep.out 2>&1
指的是将包含"standard" 的行全部写入grep.out文件中，包括grep时发生错误的报错信息
cat >>filetest 2>&1 <<MAYDAY
如果前面没有“|” 没感觉和 cat MAYDAY >>filetest 2>&1 有什么差别
如果有的话，应该就是将前面得到的信息和MAYDAY 中信息一起写入filetest，包括执行命令时的报错信息，但我好像执行不通过。。。

习惯上
标准输入（standard input）的文件描述符是 0
标准输出（standard output）是 1
标准错误（standard error）是 2

	//lab6&lab7
proc.c/do_exit:

local_intr_save(intr_flag);
{
	proc = current->parent;
	if (proc->wait_state == WT_CHILD) {
		wakeup_proc(proc);
	}
	while (current->cptr != NULL) {
		proc = current->cptr;
		current->cptr = proc->optr;

		proc->yptr = NULL;
		if ((proc->optr = initproc->cptr) != NULL) {
			initproc->cptr->yptr = proc;
		}
		proc->parent = initproc;
		initproc->cptr = proc;
		if (proc->state == PROC_ZOMBIE) {
			if (initproc->wait_state == WT_CHILD) {
				wakeup_proc(initproc);
			}
		}
	}
}
local_intr_restore(intr_flag);



lab6：
值 得 注 意 的 是 , 在 具 体 实 现 中 , ucore 定 义 的 进 程 控 制 块 struct
proc_struct包含了域state,用于描述进程的运行状态,而running和runnable共享同一个状态(state)
值(PROC_RUNNABLE)。不同之处在于处于running态的进程不会放在运行队列中。

对于用户进程而言,由于有中断的产生,可以随时打断用
户进程的执行,转到操作系统内部,从而给了操作系统以调度控制权,让操作系统可以根据具体情况
(比如用户进程时间片已经用完了)选择其他用户进程执行。这体现了用户进程的可抢占性
(preemptive)。


调用shedule 函数是内核进程主动打断，而不是争抢导致。

真正是如何工作的，需要看：init_main->user_main->KERNEL_EXECVE-..>kernel_execve->SYS_exec->do_execve->load_icode-->lcr3(PADDR(mm->pgdir))

不，实际上：
if (!in_kernel) {
	if(current->need_resched) {
			schedule();
	}
}

难道说每个时钟中断后都要先经过idle才能继续执行？但是trap里面没有这么写阿？

找到了！问题在于trap_dispatch的返回:见trap()

trap_dispatch(tf);

current->tf = otf;
if (!in_kernel) {
	if (current->flags & PF_EXITING) {
		do_exit(-E_KILLED);
	}
	if (current->need_resched) {
		schedule();
	}
}

也就是说这与idle没关系。

区分“用户进程”和“用户空间”，“内核进程”和“内核空间”

进程切换过程：既然每次切换都是在终端发生之后，那么是否意味着进程切换都是在内核空间进行的？在这里思考一下context和trapframe的区别和联系。（即使是中断，也是通过当前进程的cr3和mm调用内核的。）

MAX_TIME_SLICE = 10


	//复习DM
	chapt.3
		回归、决策树、贝叶斯方法是预测缺失值的流行方法
		多元线性回归解决噪声
		清理的第一步，是偏差检测，利用元数据
	
		数据集成实际上是实体识别问题，利用元数据
		通过相关分析来检测蕴涵（冗余）
		
		标称值：卡方分析！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
		数值：相关系数活协方差
		
		利用离散小波变换（DWT）进行数据压缩，也可用于消除噪声。DWT优于DFT，且局部性好
		注意：PCA不是维子集
		PCA能更好的处理稀疏数据，而小波更适合高维数据

		
		特征子集选择：1.假定各个属性是独立的，我们可以统计显著性检验；一般可以采取启发式算法，每次添加剩下的集合中最先竹的属性
		直方图：分箱
		
		数据仓库子相对于关系数据库的一个重要特征就是维护历史信息，是时间上的。
		

//0424		
		
10:30:42 chunk@chunk-trusty lab7 $ make grade
badsegment:              (2.3s)
  -check result:                             OK
  -check output:                             OK
divzero:                 (1.6s)
  -check result:                             OK
  -check output:                             OK
softint:                 (1.6s)
  -check result:                             OK
  -check output:                             OK
faultread:               (1.7s)
  -check result:                             OK
  -check output:                             OK
faultreadkernel:         (1.7s)
  -check result:                             OK
  -check output:                             OK
hello:                   (1.7s)
  -check result:                             OK
  -check output:                             OK
testbss:                 (1.7s)
  -check result:                             OK
  -check output:                             OK
pgdir:                   (1.6s)
  -check result:                             OK
  -check output:                             OK
yield:                   (1.6s)
  -check result:                             OK
  -check output:                             OK
badarg:                  (1.6s)
  -check result:                             OK
  -check output:                             OK
exit:                    (1.6s)
  -check result:                             OK
  -check output:                             OK
spin:                    (2.4s)
  -check result:                             OK
  -check output:                             OK
waitkill:                (4.0s)
  -check result:                             OK
  -check output:                             OK
forktest:                (1.7s)
  -check result:                             OK
  -check output:                             OK
forktree:                (1.7s)
  -check result:                             OK
  -check output:                             OK
priority:                (21.9s)
  -check result:                             OK
  -check output:                             OK
sleep:                   (11.6s)
  -check result:                             OK
  -check output:                             OK
sleepkill:               (2.7s)
  -check result:                             OK
  -check output:                             OK
matrix:                  (19.8s)
  -check result:                             WRONG
   !! error: missing 'phi_test_condvar: state_condvar[0] will eating'
   !! error: missing 'phi_test_condvar: state_condvar[1] will eating'
   !! error: missing 'phi_test_condvar: state_condvar[2] will eating'
   !! error: missing 'phi_test_condvar: state_condvar[3] will eating'
   !! error: missing 'phi_test_condvar: state_condvar[4] will eating'

  -check output:                             OK
Total Score: 183/190
make: *** [grade] Error 1
		
		
////////////////////////////////

数据预处理，数据仓库，关联规则挖掘


Generalization [Descriptive]
Classification [Predictive]
Clustering [Descriptive]
Association Rule Discovery [Descriptive]
Sequential Pattern Discovery [Descriptive]
Regression [Predictive]
Deviation Detection [Predictive]




//0426，cuda 安装

今天按照 http://blog.csdn.net/lucktroy/article/details/8445854 和 http://blog.163.com/thinki_cao/blog/static/83944875201303125444265/ 的方法安装cuda-6.0，结果差点酿成大灬。官网已经明确指出该版本提供给ubuntu13.04安装！安装到最后提示gcc版本太高！
然后虽然提示driver已经安装成功，但是死活回不到桌面。最后，在 http://ubuntuforums.org/showthread.php?t=2081649 的帮助下重新安装nvidia driver，搞定。貌似current版本是304.


//0427，校庆结束后
evening：conan，FPGA，net

update-alternatives工具帮助管理多版本符号链接：用在gcc4.8和gcc4.7共存：
	sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 80

关于cuda的安装2:
	1. 添加--override选项则可以在gcc4.8上安装
	2. 如果选择安装driver（331），那么之后很可能会进不了桌面。因为这个driver可能与当前系统不兼容。解决办法是重新安装304（nvidia-current-updates）
	3. cat /proc/driver/nvidia/version 可以查看当前版本。安装完之后需要重启后才能更新
	4. cuda可以编译（nvcc）,但是在运行deviceQuery时出现错误。按照https://devtalk.nvidia.com/default/topic/734737/ubuntu-14-04-optimus-cuda/ 的提示，修改modprobe之后仍然不行。
	5. 按照 http://docs.nvidia.com/cuda/cuda-getting-started-guide-for-linux/index.html#runfile-installation 的指示，运行nvidia-smi,提示 command not found .这时候发现/dev下竟然没有nvidia*
	6. 多种修改无果。然后又安装回nvidia-331，这时候进行sudo modprobe nvidia-331，有了一点效果，那就是在/dev下出现了nvidia0，但是仍然没有nvidia-smi。
	7. 运行deviceQuery，已经有了关于modrobe的错误提示：
		modprobe: FATAL: Module nvidia-uvm not found.
		cudaGetDeviceCount returned 3
		-> initialization error
		Result = FAIL
	
//0428,crypt

第二次大作业(分组密码与 Hash 函数)
《密码学原理与实践(第三版)》3.3,3.4,3.5(需要提交程序和代码)3.6(需要提交程序
和代码),3.7
《密码学原理与实践(第二版)》3.3,3.4,3.5(需要提交程序和代码)3.6(需要提交程序
和代码),3.7

补充
1、 生成 AES 的差分分布表(结果+程序代码)
2、 用时间-存储折中攻击破译 6 位(数字+字母,共(26 + 10)**6 ≈ 2 31.02 种可能结果)SHA-1
口令,要求:
a) 建立彩虹表(规模自拟);
b) 取 100 个数字+字母组合口令进行查找。


所谓分组密码，就是把代换密码中的字母等价成分组

分组是64bit，key是64bit，但是记得代换表并不真是2**64，因为这个算法是一个伪代换，即不完全代换表，所以是可突破的。

page40 is cript of a bmp,which gives a excellent way of visualziation the performancee of an cript algrithm



3.3 DES 证明：y' = c(y)
3.4 DES x DES
3.5 key generation of AES
3.6 encript with AES(128,10)
3.7 ECB,OFB,CBC,CFB

+1 AES 的差分分布表
+2 时间-存储折中攻击破译 SHA-1


哈希碰撞，从128bit缩减到60bit，大约就可以计算了

	//回顾：几个idea
	1. 把机器学习做成网络服务(MLaas: Machine Learning as a service)的，据我所知全球还没几个。一个是谷歌的prediction api; 一个是2011年成立的bigml.com; 一个是伯克利毕业生搞的wise.io。分别采用（某种）线性模型、决策树、随机森林。API等文档做得最好的是bigml
	2.水军、僵尸粉过滤器
	3.人肉器
	
	
	//问题：能不能用图像处理的原理来进行密码破解？尤其是半自动方法，借助人眼的识别能力


//0428
1.国情课作业:中美对比小论文
2.密码学:线性分析与差分分析
3.DM9000A
4.数据库3
	vector<JaccardExtractResult> &result,返回的结果,
	需按照实体id, 文档出现位置,字符串长度从小到大排序,
	且无重复结果。

	由Bucket Pruning引出的：
	对于单堆的情形，我们的问题归结为：能否通过对给定的entity ，及其grams在D中的位置列表，快速判断出candidate？



http://www.worldvaluessurvey.org/
"country";"WV1(1981)";"WV2(1990)";"WV3(1995)";"WV4(2001)";"WV5(2007)";"WV6(2012)"
"China";72;71.9;60.7;73.2;69.6;52.7
"China";91;90.0;81.3;81.5;65.6;49.4
"USA";30;30;29.5;23.3;24.9;20.4
"USA";62.4;50;41.9;31.0;30.2;24.0


student
chunk
Dept of Computer Science,Tsinghua University,China
homosexuality in China
it is a research project of one of my classes. 

point：

奥巴马表态支持同性婚姻在全世界引起强烈反响

同性恋的产生从宏观上有历史原因和审美、风俗的变迁，与人类社会的发展密切相关；微观上则与家庭和社会教育有关。

我们有理由认为，同性恋的产生和扩散与国家现代化有着密切关系。

一定程度上，一个国家的性取向分布可以反映文化、社会心理的差异，而对同性恋者的民众认同度和法律认可度则反映了民主和法治程度。

关于生活大爆炸所代表的近期外来影视作品的严查引出的思考。

我们的命题是“中美对比”，实际上我们可以展开，是中西方对比，也是工业化社会和后工业化社会的对比。

	//http://www.21ccom.net/uploads/soft/130731/69563-130I11F547.pdf
The World Values Survey has monitored changing human values and motivations, in successive waves of representative national surveys carried out from 1981 to the present-- in over 100 countries containing 90% of the world’s population.
	SURVIVAL VALUES -> emancipative values
	Survival values -> Self-expression values
	Traditional values -> Secular-rational values.
	
	//Non-Discrimination towards Homosexuality
there are substantial differences at the national and individual level in the degree to which citizens think of homosexuality as acceptable

	//COHORT DIFFERENCES IN TOLERANCE OF HOMOSEXUALITY



http://www.infinitethinkings.com/survey/ResultHistory/2_21Results.asp



//0429
pycharm

用户名：yueting3527

注册码：
===== LICENSE BEGIN =====
93347-12042010
00001FMHemWIs"6wozMZnat3IgXKXJ
2!nV2I6kSO48hgGLa9JNgjQ5oKz1Us
FFR8k"nGzJHzjQT6IBG!1fbQZn9!Vi
===== LICENSE END =====


//0503
anti-aliasing
今天为了帮pycharm消锯齿，首先是打开了JDK的render选项（见bashrc），然后装了infinality和openjdk-fontfix，视觉上感觉很差劲（其实也没有明显感觉），不过pycharm的锯齿的确没有了！
	7323  sudo apt-get install fontconfig-infinality
	7324  sudo bash /etc/fonts/infinality/infctl.sh setstyle
	7325  sudo -H gedit /etc/profile.d/infinality-settings.sh
	7326  sudo apt-get purge fontconfig-infinality
	7327  sudo -H gedit /etc/profile.d/infinality-settings.sh
	7328  sudo apt-get install fontconfig-infinality
	7329  sudo bash /etc/fonts/infinality/infctl.sh setstyle
	7330  sudo -H gedit /etc/profile.d/infinality-settings.sh

恢复：
	//http://ubuntuforums.org/showthread.php?t=1956319
	sudo apt-get --reinstall install fontconfig-config
	sudo apt-get --reinstall install libfreetype*
	sudo apt-get --reinstall install libpango*

恢复之后，感觉清晰了很多，同时桌面也回到了nemo(原来应该是infinality导致compiz失效)。经过这次试验，给ubuntu14.04的美观性点赞，同时找到了关键所在。


//0503
dip_exp1:
1. 基础部分（40%）：利用课堂学到的知识对集体照进行处理，提升其视觉效果。--Meitu
2. 挑战部分（30%）：将未上课的同学提供的图像融合到集体照中。--Image Fusion
3. 挑战部分（30%）：将两段集体照（图像1，图像2）合成成为1张图片。--Image stitching
4. 更多（20%）：可以发挥你的想象力对图像进行各种操作，另外合成效率越高分数越高，若完成了界面也可加分。
Deadline: 第12周周末5.18日
除提交到网络学堂，你还需要到助教实验室FIT1-304进行展示（去前给助教发封电子邮件：scalerhyme@scalerhyme.com）

	//parallel
	Linux虚拟机
	– root密码:parallel
	– 用户thuhpc密码:123456

共享存储编程(OpenMP)
	• 定义并行区 (omp parallel)
	• 设置并行度
	• 并行结构 (omp for; omp (parallel) sections)
	• 任务分配(schedule)
	• 数据管理/变量分类 (omp private/shared)
	• 同步控制 (omp critical...)
消息传递编程
	• 定义并行区
	• 设置并行度(静态、动态)
	• 程序员完成任务分配
	• 通信管理(消息管理、通信模式)
	• 同步控制(BARRIER)
	
01:07:07 thuhpc@tu069022 intel64 $ ll /opt/intel/impi/4.1.0.027/intel64/bin/mpi*
-rwxr-xr-x 1 root root 2.9K Nov  1  2012 /opt/intel/impi/4.1.0.027/intel64/bin/mpicc*
-rwxr-xr-x 1 root root  12K Nov  1  2012 /opt/intel/impi/4.1.0.027/intel64/bin/mpicleanup*
-rwxr-xr-x 1 root root 3.0K Nov  1  2012 /opt/intel/impi/4.1.0.027/intel64/bin/mpicxx*
lrwxrwxrwx 1 root root   10 Nov 14 22:16 /opt/intel/impi/4.1.0.027/intel64/bin/mpiexec -> mpiexec.py*
-rwxr-xr-x 1 root root 1.1M Nov  1  2012 /opt/intel/impi/4.1.0.027/intel64/bin/mpiexec.hydra*
-rwxr-xr-x 1 root root 123K Nov  1  2012 /opt/intel/impi/4.1.0.027/intel64/bin/mpiexec.py*
-rwxr-xr-x 1 root root  22K Nov 14 22:17 /opt/intel/impi/4.1.0.027/intel64/bin/mpif77*
-rwxr-xr-x 1 root root  24K Nov 14 22:17 /opt/intel/impi/4.1.0.027/intel64/bin/mpif90*
-rwxr-xr-x 1 root root 3.0K Nov  1  2012 /opt/intel/impi/4.1.0.027/intel64/bin/mpifc*
-rwxr-xr-x 1 root root  20K Nov 14 22:17 /opt/intel/impi/4.1.0.027/intel64/bin/mpigcc*
-rwxr-xr-x 1 root root  20K Nov 14 22:17 /opt/intel/impi/4.1.0.027/intel64/bin/mpigxx*
-rwxr-xr-x 1 root root  19K Nov 14 22:17 /opt/intel/impi/4.1.0.027/intel64/bin/mpiicc*
-rwxr-xr-x 1 root root  20K Nov 14 22:17 /opt/intel/impi/4.1.0.027/intel64/bin/mpiicpc*
-rwxr-xr-x 1 root root  24K Nov 14 22:17 /opt/intel/impi/4.1.0.027/intel64/bin/mpiifort*
-rwxr-xr-x 1 root root  32K Nov  1  2012 /opt/intel/impi/4.1.0.027/intel64/bin/mpirun*
-rwxr-xr-x 1 root root 1.1K Nov  1  2012 /opt/intel/impi/4.1.0.027/intel64/bin/mpitune*
-rwxr-xr-x 1 root root 1.6K Nov 14 22:16 /opt/intel/impi/4.1.0.027/intel64/bin/mpivars.csh*
-rwxr-xr-x 1 root root 1.7K Nov 14 22:16 /opt/intel/impi/4.1.0.027/intel64/bin/mpivars.sh*

试一试：
mpirun –n 100 hostname

	MPI_Send (buffer, count, datatype, destination, tag, communicator)
	(buffer, count, datatype) 消息缓冲
	(destination, tag, communicator) 消息信封
	
	消息数据类型 (message data types)
	通信子 (communicators)
	通信操作 (communication operations)
	虚拟拓扑 (virtual topology)


导出数据类型: （自动装包）

	MPI_Type_contiguous(count,oldtype,&newtype)
	MPI_Type_vector(count, blocklength, stride, oldtype, &newtype)
	MPI_Type_indexed(count,blocklens[],offsets[],old_type,&newtype)
	MPI_Type_struct(count,blocklens[],offsets[],old_types[],&newtype)
	
	Step1:定义新数据类型变量(MPI_Data_type)
	Step2:建立导出数据类型(选取a–d及其组合 )
	Step3:提交新数据类型(MPI_Type_commit)

	e.g.
	double A[100];
	MPI_Data_type EvenElements;
	... ...
	MPI_Type_vector(50,1,2,MPI_DOUBLE,&EvenElements);
	MPI_Type_commit(&EvenElements);
	MPI_Send(A,1,EvenElements,destination, ...);

	说明：MPI_Type_vector(count, blocklength, stride, oldtype, &newtype)
		(stride-blocklength)即是两个块之间的间隔.

打包：（人工装包）

	e.g.
	double A[100];
	MPI_Pack_size (50,MPI_DOUBLE,comm,&BufferSize);
	TempBuffer = malloc(BufferSize);
	j = sizeof(MPI_DOUBLE);
	Position = 0;
	for (i=0;i<50;i++)
		MPI_Pack(A+i*2,1,MPI_DOUBLE,TempBuffer,BufferSize,&Position,comm);
	MPI_Send(TempBuffer,Position,MPI_PACKED,destination,tag,comm);


tag：
	发收双方的协议
communicator：
	一个进程组(process group)+上下文(context).
	
	MPI-1被设计成使不同通信子中的通信是相互分开的, 以及任何群集通信是与任何点对点通信分开的, 即使它们是在相同的通信子内。通信子概念尤其方便了并行库的开发.
	MPI-1只支持组内通信 (intra-communication)
	MPI-2支持组间通信 (inter-communication)
	MPI_COMM_WORLD所有进程所在组
	
	
MPI中的通信子管理：
	分布的观念！并行的观念！而不是事事for循环！

	MPI_Comm_split(comm, color, key, &newcomm)
		• 对于comm中的进程都要执行
		• 每个进程指定一个color,此调用首先将具有相同color的值形成一个新的进程组,新产生的通信域与这些进程组一一对应。
		• 新通信域中各个进程的顺序编号根据key的大小决定,即key越小,则相应进程在原来通信域中的顺序编号也越小,若两个进程中的key相同,则根据这两个进程在原来通信域中顺序号决定新的编号。
		• 一个进程可能提供color值MPI_Undefined,此种情况下,newcomm返回MPI_Comm_null

		e.g.
		MPI_Comm MyWorld, SplitWorld;
		int my_rank, group_size, Color, Key;
		MPI_Init(&argc, &argv);
		MPI_Comm_dup(MPI_COMM_WORLD,&MyWorld);
		MPI_Comm_rank(MyWorld,&my_rank);
		MPI_Comm_size(MyWorld,&group_size);
		
		Color=my_rank%3;
		Key=my_rank/3;
		MPI_Comm_split(MyWorld,Color,Key,&SplitWorld);
		
		自注：这里的变量都是局部的。程序本身就是局部的。他的视界就只有自己的程序而已，了解外部的统一接口是 MPI_Comm_*

广播(Broadcast)：
	MPI_Bcast(Address, Count, Datatype, Root, Comm)

	消息的内容如同点对点通信一样由三元组(Address,Count, Datatype) 标 识 . 对Root进程来说, 这个三元组既定义了发送缓冲也定义了接收缓冲. 对其它进程来说,这个三元组只定义了接收缓冲.

	实验
	 目的:启动mpi,获取运行信息
	 任务
	 了解并行区概念
	 打印进程号和进程总数
	 控制进程数量
	实验
	 目的:mpi send/recv
	 任务
	 实现进程间标准消息通信
	 进一步认识死锁
	实验
	 目的:了解mpi通信性能
	 任务
	 任务
	 用IMB-MPI1
	位置:/opt/intel/impi/4.1.0.027/bin64/IMB-MPI1


//0504

课程作业2 – Jacobi迭代 [2014.4.14日晚12点前提交]
for( t=0; t < t_steps; t++) {
	for( x=0; x < x_dim; x++) {
		for( y=0; y < y_dim; y++) {
			for ( z=0; z < z_dim; z++) {
				grid[x][y][z]=/*avg of neighbors in other_grid*/
			}
		}
	}
	Exchange grid and other_grid;
}

实现两维剖分MPI并行,要求完成至少3种或以上MPI实现
自行设定t_steps和问题规模,提供源代码(串行和并行),以及测试和分析报告
测试和分析应该包括不同问题规模、不同并行度(X/Y进程划分数)的测试结果



第


	//0504
	手贱删了libpango*，结果导致几乎所有带图形界面软件的软件被删，看着启动栏的图标一个个消失。。。
	重装系统后试验了一下，发现原先导致渲染出错的罪魁祸首竟然是ppa:no1wantdthisname/openjdk-fontfix
	这次重装之后的主要问题除了字体以外，还有个就是为了保护渲染，配置文件拷贝时格外小心。这次决定，那些用不着的就让他们躺在备份盘里吧！
	字体的问题，主要是官方用的楷体，而自己安装的wenquanyi不起作用。http://forum.ubuntu.org.cn/viewtopic.php?f=48&t=422887 和 http://www.cnblogs.com/daizhe11/p/3384391.html的方案有用。意识到，这个文件是用来改优先级的。
	cd /usr/share/fonts/apple/
	sudo mkfontscale
	sudo mkfontdir
	sudo fc-cache -fv

	关于python的matplotlib安装：http://blog.sina.com.cn/s/blog_d7ab0f540101e719.html
	ibus默认的拼音一开始会有bug，但是使用sunpinyin一段时间再改回来之后就可以了。googlepinyin的bug在于翻页异常，sunpinyin的bug是que字的e没法打。
	将来

顺利！

//0505

由生日攻击（第二原像攻击）原理得到：故Hash函数摘要长度应至少为128比特。

Collision attacks

Cryptography and Randomness:

	When the function f is a permutation, its associated graph G is quite boring。
	Random Graphs Have Much More Interesting Structure。
我们的任务是：
	Find some simple collision
	Find some multicollision

But FB107E70 is not in the chain starting at "aaaaaa". This is called a false alarm. 
This creates a new way of producing a false alarm: if we "guess" the position of the hash value wrong, we may needlessly evaluate a chain.
（就是交点）



A Cryptanalytic Time-Memory Trade-Off


《Making a Faster Cryptanalytic Time-Memory》Philippe Oechslin：

	1. The chains are created using a reduction function R which creates a key from a cipher text.明确理解R函数的作用和特征。
	2. The cipher text is longer that the key, hence the reduction.
	3. In [2] Rivest suggests to use distinguished points as endpoints for the chains.Distinguished points are points for which a simple criteria holds true (e.g. thefirst ten bits of a key are zero).This greatly reduces the number of memory lookups.
	4. Borst notes in [1] that distinguished points also have the following two advantages:
		– They allow for loop detection.
		– Merges can easily be detected since two merging chains will have the same endpoint (the next distinguished point after the merge).
	5. We propose a new type of chains which can collide within the same table without merging.
		We call our chains rainbow chains.
	6.Indeed the success probability of t classical tables of size m×t is approximately equal to that of a single rainbow table of size mt × t . In both cases the tables cover mt 2 keys with t different reduction functions. For each point a collision within a set of mt keys ( a single classical table or a column in the rainbow table) results in a merge, whereas collisions with the remaining keys are not merges.
	7.
	8.
	9.
	

	
关于RainbowCrack Project的几点说明：

	1..rt file:
		rtgen md5 loweralpha-numeric 1 7 0 3800 3 0 
		
		00000000: 00 00 00 00 00 00 00 00 30 02 3C 61 01 00 00 00 
		00000010: 01 00 00 00 00 00 00 00 77 09 F0 98 06 00 00 00 
		00000020: 02 00 00 00 00 00 00 00 14 49 40 CB 0A 00 00 00

		Both the start point and the end point are 64-bit unsigned integer in little endian, representing a plaintext. 
		0 stands for plaintext "a", 1 stands for plaintext "b", 35 stands for plaintext "9", 36 stands for plaintext "aa", and 80603140211 stands for plaintext "9999999".
		
		.rtc file :
		
		The .rtc rainbow table introduced in RainbowCrack 1.4 uses configurable number of bits for the start point and end point. As an example, if the start point uses 25 bits and the end point uses 31 bits, one rainbow chain requires 7 bytes. To support this level of flexibility, a simple 32 bytes file header is used in .rtc rainbow table.
		
		start point generation algorithm:
			rtgen 	md5 		loweralpha-numeric 		1 					7 				0 			3800 		3 		0 
			rtgen hash_algorithm 	charset			 plaintext_len_min plaintext_len_max table_index chain_len chain_num part_index 

		The start points used in a rainbow table are: 
			(chain_num * part_index + 0) % key_space 
			(chain_num * part_index + 1) % key_space 
			(chain_num * part_index + 2) % key_space 
			...... 
			(chain_num * part_index + chain_num-1) % key_space

	2.charset.txt可以自定义字符集
	3.alglib0.so是加密与哈希函数库
	4.	
		usage: rcrack rt_files [rt_files ...] -h hash
			   rcrack rt_files [rt_files ...] -l hash_list_file
			   rcrack rt_files [rt_files ...] -f pwdump_file
			   rcrack rt_files [rt_files ...] -n pwdump_file
		rt_files:               path to the rainbow table(s), wildchar(*, ?) supported
		-h hash:                load single hash
		-l hash_list_file:      load hashes from a file, each hash in a line
		-f pwdump_file:         load lanmanager hashes from pwdump file
		-n pwdump_file:         load ntlm hashes from pwdump file

		hash algorithms implemented in alglib0.so:
			lm, plaintext_len limit: 0 - 7
			ntlm, plaintext_len limit: 0 - 15
			md5, plaintext_len limit: 0 - 15
			sha1, plaintext_len limit: 0 - 20
			sha256, plaintext_len limit: 0 - 20

		example: rcrack *.rt -h 5d41402abc4b2a76b9719d911017c592
				 rcrack *.rt -l hash.txt

	5.64-bit operating system is recommended so more than 2 GB memory can be used by  application. 

下一步：分析rainbowcrack源码
	//http://stackoverflow.com/questions/3368683/how-to-compile-c-file-with-openssl-includes
	Your include paths indicate that you should be compiling against the system's OpenSSL installation. You shouldn't have the .h files in your package directory - it should be picking them up from /usr/include/openssl.
	The plain OpenSSL package (libssl) doesn't include the .h files - you need to install the development package as well (libssl-dev).

	注：libssl-dev-1.0相较于0.9.8做了很多改动，包括删除了md2等过时的函数，但是没有很好的做到兼容，导致编译出错。
		从https://packages.debian.org/squeeze/libssl-dev下载旧版的deb包，替换之，但是失败了，因为libssl必须同时改回到0.9.8

	具体步骤：（eclipse CDT还是不熟悉阿！）
	1.下载libssl,libssl-dev，解压到工程目录的usr/下
	2.配置include：
		properties	->	c/c++ build	->	settings	->	c++/c includes
					->	c/c++ general->	paths and symbols -> includes
	3.配置libs:
		properties	->	c/c++ build	->	settings	->	c++/c Linker libs and Lib paths
					->	c/c++ general->	paths and symbols -> libs and Lib paths
	4.最后，运行时库可能没有配成功，于是，。。。。。。直接copy-/usr之



//0506
	OpenSSL is a cryptography toolkit implementing the Secure Sockets Layer (SSL v2/v3) and Transport Layer Security (TLS v1) network protocols and related cryptography standards required by them.

	OpenSSH(OpenBSD Secure Shell) is a program depending on OpenSSL the library, specifically OpenSSH uses the libcrypto part of OpenSSL.


二次大作业(分组密码与 Hash 函数)
《密码学原理与实践(第三版)》3.3,3.4,3.5(需要提交程序和代码)3.6(需要提交程序和代码),3.7

补充
1、 生成 AES 的差分分布表(结果+程序代码)
2、 用时间-存储折中攻击破译 6 位(数字+字母,共(26 + 10)**6 ≈ 2 31.02 种可能结果)SHA-1
口令,要求:
a) 建立彩虹表(规模自拟);
b) 取 100 个数字+字母组合口令进行查找。


所谓分组密码，就是把代换密码中的字母等价成分组

分组是64bit，key是64bit，但是记得代换表并不真是2**64，因为这个算法是一个伪代换，即不完全代换表，所以是可突破的。

page40 is cript of a bmp,which gives a excellent way of visualziation the performancee of an cript algrithm



3.3 DES 证明：y' = c(y)					OK
3.4 DES x DES							
3.5 AES128 密钥构造程序				OK？
3.6 AES(128,10) 加密程序				OK？
3.7 ECB,OFB,CBC,CFB						OK
+1 AES 的差分分布表					
+2 时间-存储折中攻击破译 SHA-1			OK？


1585.365853659
813.008130081
1.949569496

哈希碰撞，从128bit缩减到60bit，大约就可以计算了



	openssl enc -ciphername [-in filename] [-out filename] [-pass arg] [-e]

	[-d] [-a] [-A] [-k password] [-kfile filename] [-K key] [-iv IV] [-p]

	[-P] [-bufsize number] [-nopad] [-debug]

	说明：

	-chipername选项：加密算法，Openssl支持的算法在上面已经列出了，你只需选择其中一种算法即可实现文件加密功能。

	-in选项：输入文件，对于加密来说，输入的应该是明文文件；对于解密来说，输入的应该是加密的文件。该选项后面直接跟文件名。

	-out选项：输出文件，对于加密来说，输出的应该是加密后的文件名；对于解密来说，输出的应该是明文文件名。

	-pass选项：选择输入口令的方式，输入源可以是标准输入设备，命令行输入，文件、变量等。

	-e选项：实现加密功能（不使用-d选项的话默认是加密选项）。

	-d选项：实现解密功能。

	-a和-A选项：对文件进行BASE64编解码操作。

	-K选项：手动输入加密密钥（不使用该选项，Openssl会使用口令自动提取加密密钥）。

	-IV选项：输入初始变量（不使用该选项，Openssl会使用口令自动提取初始变量）。

	-salt选项：是否使用盐值，默认是使用的。

	-p选项：打印出加密算法使用的加密密钥。


	e.g.
		openssl enc -aes-128-cbc -in install.log -out enc.log
		openssl enc -d -aes-128-cbc -in enc.log -out install.log
		openssl enc -des-ede3-cbc -in install.log -out enc.log -pass pass:111111
			(这种方式的好处是你可以把它写入到脚本中，自动完成加密功能，不使用pass选项默认系统会提示输入口令，并且确认，是需要人工操作的)
		口令错误提示：
			enter aes-128-cbc decryption password:
			bad decrypt
			140390572467872:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:evp_enc.c:539:

//0506

DIP 第二次大作业：ACM Multimedia 2014 Grand Challenge

	MSR-Bing Challenge on Image Retrieval
	image search or video search
	pagerank? log!		
			
	从2012年开始，MSR开始公布Bing log

	task:
		1.只care rank，range自由
		2.scoring：
			online testing(40%),参考班里的group rank，不会参考其他的。。。(大部分参加者都是研究生，但是门槛并不高)
			Tech Report (Weekly+Final) (50%) (为的是share)
			Presentation(10%) (results and problems)
			
		3.鼓励idea，normal smart，不仅仅是training
			
		
	advice：
		data-preproccing	
		训练数据（sammple）至少要是feature的十倍。所以用多featrue加权时，feature的数量要使用
		n-gram方式
		协同过滤
		...
		
	组队？经验上，4个人差不多。最起码工程+paper search+ Presentation


	//crypt
	熵只是刻画系统或者变量不确定性的一个量，并不是刻画系统信息量的一个量 ，但是它与信息量是有关系的，什么关系呢？当我们谈论信息量的时候应该是指的一个具体的事物，即随机变量的一个具体取值时的状态，这个时候才能谈论信息量！ 那这个信息量是多少呢？即随机变量从原来不知道该取什么值的时候到现在已经知道具体取值所需要做的“功”，亦即消除这个不确定性所需要做的事情，应该是所求。显然，这个值就等于变量的熵。所以熵不代表随机变量的信息量，但是随机变量取某个具体值时具有信息量的值是等于熵的；故而，熵和信息量是两个范畴的东西，只是因为相等，所以现实中经常混用而已，但却经常引起概念上的混淆；
	
	所以，“熵越大，代表该随机变量取特定值的时候具有的信息量越大”。

//0507

-funsigned-char



c722606136c8ea90ed5571964c665ee9

/*
 int Chain::hash_len;
 unsigned char Chain::charset[256];
 int Chain::charset_len;
 int Chain::plain_len_min;
 int Chain::plain_len_max;
 //uint64 Chain::plaintext_total;
 */

//0507
1.集群搭建
	166.111.68.254
	id:2011011324
	ptc_2011011324
	
	单点：centos 6.5，命令行安装
	多台： NFS网络安装->问题：没有操作系统->硬盘拷贝
		硬盘需要同构
		得到6个单点
		2-core AMD		
	网络链接：
		硬盘拷贝造成的问题：网卡排斥
		内网，外网		
		无密钥访问：将home目录挂载、共享
		/mnt/share/test/auto.sh	
	NTP：时钟漂移 ntpd 与 ntpdate区别
	软件源：
		主节点安装服务、挂在镜像、建立仓库
2.作业管理系统搭建
	NFS：ver = 3
	openpbs
3.使用
	编译：
		mpiicc
	提交：
		脚本test1.pbs
		设置路径、参数
		mpirun -n 12 /home/2011011324.../src/...		
		qstat 查询作业状态
		qnote 查询节点状态
校外：
	58.210.43.210
	区别：采用mpicc，使用qsub提交
	qstat
	qdel id
	man qstat
测试：
	性能测试：博大精深
	Benchmark:基准测试程序
		e.g. Tianhe-2: Linpack
	CPU：SPEC CPU
	MPI：
		IMB Sendrecv
		OSU
		SPEC
作业deadline：
	2014-05-14
	hard deadline


东方快车谋杀案.txt

FILE * fopen ( const char * filename, const char * mode );

"r"	Open a file for reading. The file must exist.
"w"	Create an empty file for writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.
"a"	Append to a file. Writing operations append data at the end of the file. The file is created if it does not exist.
"r+"	Open a file for update both reading and writing. The file must exist.
"w+"	Create an empty file for both reading and writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.
"a+"	Open a file for reading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition (fseek, rewind) the internal pointer to anywhere in the file for reading, but writing operations will move it back to the end of file. The file is created if it does not exist.



//0508

0 3800 100
res/sha1_loweralpha-numeric6-6_0_3800x100.rt	res/tmp.rt
res/sha1_loweralpha-numeric6-6_0_3800x100.rt
res/sha1_loweralpha-numeric6-6_0_3800x100.rt	-h	61ee8b5601a84d5154387578466c8998848ba089

一个特殊的哈希序列：aad3b435b51404ee
这实际上是一个填充序列 0000000

帮助计算彩虹表的各项参数：Advanced RT Calculator:
	http://www.tobtu.com/rtcalc.php

0 10000 13285434
Table size202.72 MiB (212,566,944 Bytes)


//0509
schedule:
	1.Fri,	lab8，mpi-1
	2.Sat,	mpi-2，crypto(aes，差分）,FPGA
	3.Sun,	crypto(report)，DIP,OSreview-1



kaggle


先对debian进行一些常规配置：
	安装terminator，设置大小self.vte.set_size(110, 32)
	
	批量文件操作：
		find -exec command {} \;
		e.g.
			find ./*.pir -type f -exec sed -i '/>/d' {} \;
		*/		
	最终决定安装KDE桌面：
		http://linuxg.net/how-to-install-kde-k-desktop-environment-on-debian-wheezy/
		https://scottlinux.com/2013/04/27/how-to-install-kde-desktop-in-debian-linux/

	//mpi
		C-x C-f Open a file. Starts in the current directory
		C-x f Open a recently visited file
		C-x o Open a file in the current project (based on .git ++)
		C-x C-s Save this file
		C-x C-w Save as ...
		C-x C-j Jump to this files' current directory
		C-x b Switch to another open file (buffer)
		C-x C-b List all open files (buffers)
		Cut copy and paste
		
		mpiexmpl-tasks
			1.helloW
			2.bcast
				A common need is for one process to get data from the user, either by reading from the terminal or command line arguments, and then to distribute this information to all other processors.
				int MPI_Bcast( void *buffer, int count, MPI_Datatype datatype, int root, MPI_Comm comm )
				
				感觉：上帝在广播。root参数用户选定buffer。
				int MPI_Pack(const void *inbuf,int incount,MPI_Datatype datatype,void *outbuf,int outsize,int *position,MPI_Comm comm)
				e.g.
				MPI_Pack( &number_of_chars, 1, MPI_INT, packbuf, MAXPACKBUF, &packsize, ...);
				MPI_Pack( string, number_of_characters, MPI_CHAR, .... );
				
				note:
					position:current position in buffer, in bytes (integer)
					
				
			3.ring
				MPI_Cart_create( MPI_COMM_WORLD, 1, &size, &false, 1, &ring_comm );
				MPI_Cart_shift( ring_comm, 0, 1, &left_nbr, &right_nbr );
			4.pi
				MPI_Reduce(&mypi, &pi, 1, MPI_DOUBLE, MPI_SUM, 0,MPI_COMM_WORLD);
				
				
课程作业2 – Jacobi迭代 [2014.4.14日晚12点前提交]
for( t=0; t < t_steps; t++) {
	for( x=0; x < x_dim; x++) {
		for( y=0; y < y_dim; y++) {
			for ( z=0; z < z_dim; z++) {
				grid[x][y][z]=/*avg of neighbors in other_grid*/
			}
		}
	}
	Exchange grid and other_grid;
}

1.实现两维剖分MPI并行,
2.要求完成至少3种或以上MPI实现

3.自行设定t_steps和问题规模,提供源代码(串行和并行),以及测试和分析报告

4.测试和分析应该包括不同问题规模、不同并行度(X/Y进程划分数)的测试结果	


//0511 密码学
	-----------------------------------------
	plain:
	3243f6a8885a308d313198a2e0370734
	key:
	2b7e151628aed2a6abf7158809cf4f3c
	cipher:
	252a2469512d978b9e0f7568531ed218
	-----------------------------------------
	key 0:	2b7e151628aed2a6abf7158809cf4f3c
	key 1:	0e706573ec42903640b7a22a4e81cef2
	key 2:	09791c6f094bdbedc97edcf6c1408e7c
	key 3:	58213d524b00db36d9a77b8d6929a7db
	key 4:	5574491b1616cdfb60c7bc316940e73c
	key 5:	4a3e776cd1c70af18b4cf0c1c686615d
	key 6:	cbf582eea96e6495c78b7bba9610712c
	key 7:	a154d6385d3357c2b63d46fcbeaedff3
	key 8:	045086beedde894bbb86c03cb917c83b
	key 9:	acfc7ac406d8511a59df1f231700c8f3
	key 10:	38c4be7a20f8a9b3548b94b70b0bc330
	cracked:
	1070edbcf7baaa896204556698a39f0a
	-----------------------------------------



	plain:	3243f6a8885a308d313198a2e0370734
	key:	2b7e151628aed2a6abf7158809cf4f3c
	cipher:	a2cc0db4d67dfcbe494b63e006448124
	-----------------------------------------
	key 0:	2b28ab097eaef7cf15d2154f16a6883c
	key 1:	a088232afa54a36cfe2c397617b13905
	key 2:	f27a5973c296355995b980f6f2437a7f
	key 3:	3d471e6d8016237a47fe7e887d3e443b
	key 4:	efa8b6db4452710ba55b25ad417f3b00
	key 5:	d47cca11d183f2f9c69db815f887bcbc
	key 6:	6d11dbca880bf900a33e86937afd41fd
	key 7:	4e5f844e545fa6a6f7c94fdc0ef3b24f
	key 8:	eab5317fd28d2b8d73baf52921d2602f
	key 9:	ac19285777fad15c66dc2900f321416e
	key 10:	d0c9e1b614ee3f63f9250c0ca889c8a6


	今天发现一个很严重的问题：
		继abs(usigned)之后，又一个usinged/singned 隐藏bug浮出水面：
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！
		i << 2 与 i * 4 不等价！


	//设置terminal：
		22:09:51 chunk@chunk-trusty ~ $ sudo update-alternatives --config x-terminal-emulator
			There are 6 choices for the alternative x-terminal-emulator (providing /usr/bin/x-terminal-emulator).

			  Selection    Path                             Priority   Status
			------------------------------------------------------------
			* 0            /usr/bin/terminator               50        auto mode
			  1            /usr/bin/gnome-terminal.wrapper   40        manual mode
			  2            /usr/bin/koi8rxterm               20        manual mode
			  3            /usr/bin/lxterm                   30        manual mode
			  4            /usr/bin/terminator               50        manual mode
			  5            /usr/bin/uxterm                   20        manual mode
			  6            /usr/bin/xterm                    20        manual mode

			Press enter to keep the current choice[*], or type selection number: 1
			update-alternatives: using /usr/bin/gnome-terminal.wrapper to provide /usr/bin/x-terminal-emulator (x-terminal-emulator) in manual mode

	update-alternatives是个好东西！！

//0511 ,mpi
	1.exchng.c第二个版本实现了边界交换，不过并没有真正的交换，而是交换到了缓冲区，从而可以检查。巧妙。

	2. nonblock中的MPI_Waitall( nreq, r, statuses );是什么意思？

	3./* This code (and the declaration of x above) are the only changes to the
       Jacobi code */
		MPI_Gather( xlocal[1], maxn * (maxn/size), MPI_DOUBLE,
					x, maxn * (maxn/size), MPI_DOUBLE, 
					0, MPI_COMM_WORLD );

		collect程序已经有了jaccobi的雏形
		
	5. jaccobi：
		impl1：
		MPI_Gather( xlocal[1], maxn * (maxn/size), MPI_DOUBLE,
					x, maxn * (maxn/size), MPI_DOUBLE, 
					0, MPI_COMM_WORLD );
		comments：This exercise completes the first example of building a simple parallel program. The steps we took were
			Define and implement the parallel data structure (distributed mesh)
			Implement the parallel algorithm (Jacobi iteration)
			Add input/output code
			
	4. jaccobi：
		impl2：
			MPI_Allreduce( &diffnorm, &gdiffnorm, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD );
		       
		comments：It should be clear from this example that the Jacobi iteration is a very slow method. Because this iteration converges so slowly, it is necessary to test for convergence less frequently.
		It is possible to avoid the step that copies xnew back into xlocal either by using pointer operations (basically swapping xnew and xlocal) or by doing two iterations at a time. This latter approach requires another exchange of ghost points and another relaxation sweep.
	
	

//0512

1. 一维剖分： http://blog.csdn.net/zhuliting/article/details/7387360

	上述代码中，使用了虚拟进程。虚拟进程(MPI_PROC_NULL)是不存在的假想进程，在MPI中的主要作用是充当真实进程通信的目的或源，引入虚拟进程的目的是在某些情况下，编写通信语句的方便。当一个真实进程向一个虚拟进程发送数据或从一个虚拟进程接收数据时，该真实进程会立即正确返回，如同执行了一个空操作。引入虚拟进程不仅可以大大简化处理边界的代码，而且使程序显得简洁易懂。在捆绑发送接收操作中经常这种通信手段。

2. 官方： http://www.mcs.anl.gov/research/projects/mpi/tutorial/mpiexmpl/src/jacobi/C/main.html
		In this example, we solve the Laplace equation in two dimensions with finite differences. This may sound involved, but really amount only to a simple computation, combined with the previous example of a parallel mesh data structure.
	所以我们的问题是求解拉普拉斯方程。这和jacobi迭代有什么关系？http://zh.wikipedia.org/zh/%E9%9B%85%E5%8F%AF%E6%AF%94%E6%B3%95

3. mpi 总结： http://www.docin.com/p-528063208.html

4. 两维剖分例程 ： jacobi mpi 2-dimension  decomposition
	https://www.pdc.kth.se/education/tutorials/mpi/lab-virtual-topologies/mpi-lab-exercises-virtual-topologies
		Again, your task is to produce the code for a general two-dimensional decomposition using MPI and then time the execution time on at least a 12 node configuration organized as a 1 x 12, 2 x 6, 3 x 4, processor grid.
		There are several ways to complete this exercise. If you wish to used a derived data type, take a look at this page (an old lab).
		Remember to check that your new code version converges in the same number of steps as the original code.
		
		esubmit -n2 -t5 ./runjob.sh
		
		the script file runjob.sh can be downloaded here . Make sure to read it and edit as necessary.
		
		When you have a working code you need to compile with optimization (e.g. -O3) before doing timing for the performance measurements. 
		
		See Section 4.1 in Using MPI 2nd edition by Gropp, Lusk and Ewing for a more detailed description of the numerical method. 
		
		Three different solutions are available twod.f90, twod_v2.f90 and twod_v3.f90. On Lenngren, it was twod_v2.f that was the most efficient solution. The corresponding C-versions can be found at twod.c and twod_v3.c. Since C lacks the construct of matrix slices, the version twod.c is comparable to twod_v2.f90. More comments on the solutions are available on this webpage. A performance model is given here.
		
	 2D partition ：
	 http://www.netlib.org/utk/papers/mpi-book/node44.html


5。mpi可能遇到的问题：
	通信子中的所有进程必须调用群集通信例程. 如果代码中只有通信子
	中的一部分成员调用了一个群集例程而其它没有调用, 则是错误的. 一个
	错误代码的行为是不确定的, 意味着它可能发生任何事情, 包括死锁或产
	生错误的结果.

	一个进程一旦结束了它所参与的群集操作就从群集例程中返回.
	除了MPI_Barrier以外, 每个群集例程使用类似于点对点通信中的标准
	(standard)、阻塞的通信模式.
	例如, 当Root进程从MPI_Bcast中返回时, 它就意味着发送缓冲的Address
	可以被安全地再次使用. 其它进程可能还没有启动它们相应的MPI_Bcast!



//0513.
DIP-2

好效果源自fusion

tag refinement -> tag recomnedation -> modeling

content-based image search:
	datasets 
	size： Douze 2009 CIVR 110million-180ms   Global/local
	classification datasets ：
		object ：95%（小数据集上容易overfitting）
		object？scene？
		刚体？非刚体？
		scale？
	
	image-net


（在进行比赛时，可以利用超出数据本身的数据：image-net（opensource））


retiaval vs classification?


我们的任务： data-driven classification,200ms


借鉴text-search：

image-word-bag模型：visaul word

倒排列表：performence，tf-idf


按照去年的经验，恩多提交没有满足200ms的限制，会被强制提供random值。


//0513

1.注意：服务器ln1的用户2011011324密码修改，e*****

2.how to send a slice of a 2d matrix in mpi:

	http://stackoverflow.com/questions/9269399/sending-blocks-of-2d-array-in-c-using-mpi

	int MPI_Type_create_subarray(int ndims,
                           const int array_of_sizes[],
                           const int array_of_subsizes[],
                           const int array_of_starts[],
                           int order,
                           MPI_Datatype oldtype,
                           MPI_Datatype *newtype)

3. MPI_Gatherv
	http://stackoverflow.com/questions/5371733/how-to-mpi-gatherv-columns-from-processor-where-each-process-may-send-different

	http://www.mpich.org/static/docs/v3.1/www3/MPI_Gatherv.html
	
	int MPI_Gatherv(const void *sendbuf, int sendcount, MPI_Datatype sendtype,
                void *recvbuf, const int *recvcounts, const int *displs,
                MPI_Datatype recvtype, int root, MPI_Comm comm)
                
				Input Parameters

				sendbuf
				starting address of send buffer (choice)
				sendcount
				number of elements in send buffer (integer)
				sendtype
				data type of send buffer elements (handle)
				recvcounts
				integer array (of length group size) containing the number of elements that are received from each process (significant only at root)
				displs
				integer array (of length group size). Entry i specifies the displacement relative to recvbuf at which to place the incoming data from process i (significant only at root)
				recvtype
				data type of recv buffer elements (significant only at root) (handle)
				root
				rank of receiving process (integer)
				comm
				communicator (handle)
				Output Parameters

				recvbuf
				address of receive buffer (choice, significant only at root)
				
			
//0514				
		第二次大作业分组		
	根据同学们给我发的邮件，我分成了以下6组（数字为大家的分组编号）：
	1.  魏铭 栾福军 周昕宇 谭志鹏 吴晓阳
	2. 王庆	孙梦嫽	钱桥	叶紫	林雯
	3. 秦同  胡思行  石佳欣	李其乐	梁梓标
	4. 戴文轩	刘弘辉	刘心宇	谢婷欣
	5. 黄科举	张天旭	曾建强	邓佳迪
	6. 季宇	蒋楠	江云涛	赵相越

	我们将给大家提供一个服务器，你们可以使用ssh连接它。服务器的地址是 thumedia.org ，端口是2223。各组的用户名为groupX，X为你们的分组编号。初始密码同用户名，请尽快更改。
	服务器的系统为ubuntu12.04.4。上面预装了tmux、sqlite3、python-virutalenv、python-dev、opencv以及PIL相关的依赖。
	如果还需要装python的各种库请自己研究怎么用virtualenv。
	如果要用node请自己搞nvm在本地装。

	实验的相关文档以上传到课程文件当中，实验数据也已放到了服务器上，另外我们已经帮大家做了一些dirtywork，如将base64的string直接转换成了图片，并给大家提供了一个python搭建web服务器的模板。大家可以访问 http://dip-data.thumedia.org/ 查看使用方式。
	端口转发配置：假设组号是X 本组对外应该暴露的端口是800X 对外可以访问到的地址是X.dip.thumedia.org

	如果有任何服务器问题，欢迎发送邮件 xxr3376@gmail.com 联系许欣然同学。
	如果有任何跟实验相关的问题以及需求，欢迎发送邮件骚扰我。

	祝好！				

echo -e "\033[字背景颜色；文字颜色m字符串\033[0m"
　　例如：
　　echo -e "\033[41;36m something here \033[0m"
　　其中41的位置代表底色， 36的位置是代表字的颜色
PS1='\[\e]0;\w\007\]\[\033[31m\]\D{%H:%M:%S}\[\033[01;31m\] \u@\h \[\033[01;34m\]\W\[\033[00m\] \$ '
				
///操统复习
1.lab
2.ppt
3.textbook
4.test				
				
解决虚拟机mount出错：
sudo apt-get install linux-generic
sudo apt-get install nfs-common
sudo ln -sf /usr/lib/x86_64-linux-gnu/VBoxGuestAdditions/mount.vboxsf /sbin/mount.vboxsf			
sudo mount -t vboxsf chunkshare ./ishare/				
				


How to see the command attached to a bash alias?				
	The type builtin is useful for this. It will not only tell you about aliases, but also functions, builtins, keywords and external commands.	
		
	Just type alias while at the Shell prompt. It should output a list of all currently-active aliases.				
				

//0517

	//exp3
3155	exp3: AEE	Sat, 17 May 2014 00:20:38 +0800	Wrong result: some results are missing.	 N/A	 N/A				
3156	exp3: AEE	Sat, 17 May 2014 00:21:27 +0800	Illegal syscall detected.	 N/A	 N/A				
				
	从测试8、9可知，问题在于ED读文件失败。			
				
今天右侧试了一下，他的具体流程应该是iIndex、ED、ED check、JD、JD check
而我在ED的读文件出错，也就是第一次读文件救出错。但是在此之前Index读文件没有出错。				
				
				
				
				
//0518
操作系统复习笔记导出到os.txt

	
//0520				
	Baidu-IDL 报告


	//系统结构
	分支预测
	（1）假设有一个长流水线，仅仅对条件转移指令使用分之目标缓冲。假设分支预测错误的开销为4个时 钟周期，缓冲不命中的开销为3个时钟周期。假设：命中率为90%，预测精度为90%，分支频率为15%，没有分支的基本CPI为1。？　　（1） 求程序执行的CPI。？　　（2） 相对于采用固定的2个时钟周期延迟的分支处理，哪种方法程序执行速度更快？
	（2）假设分支目标缓冲的命中率为90%，程序中无条件转移指令的比例为5%，没有无条件转移指令的 程序CPI值为1。假设分支目标缓冲中包含分支目标指令，允许无条件转移指令进入分支目标缓冲，则程序的CPI值为多少？
	
	//密码学第3次作业
	公钥密码算法RSA的实现，包括加密和解密算法。 素数的选取（选用强素数）每个同学不能相同。要提交实现方法和C-代码，以及实现结果。
				
				
	//数据库专题训练大作业---空间数据的即时搜索
{ "_id" : 1000010, "addr" : "Gillman Heights Condominium\n1A Gillman Heights, Singapore 100001", "fetdt" : { "$date" : 1345018964614 }, "latlng" : [ 1.281933, 103.80321 ], "name" : "Gillman Heights Condominium", "pcode" : 100001, "url" : "http://gothere.sg/maps#q:100001" }
	
{ "_id" : 1000440, "addr" : "44 Telok Blangah Drive\nSingapore 100044", "fetdt" : { "$date" : 1345018961499 }, "latlng" : [ 1.271687, 103.810585 ], "name" : "44 Telok Blangah Drive", "pcode" : 100044, "url" : "http://gothere.sg/maps#q:100044" }

{ "_id" : 1000450, "addr" : "45 Telok Blangah Drive\nSingapore 100045", "fetdt" : { "$date" : 1345018961534 }, "latlng" : [ 1.272116, 103.80951 ], "name" : "45 Telok Blangah Drive", "pcode" : 100045, "url" : "http://gothere.sg/maps#q:100045" }

{ "_id" : 1000460, "addr" : "46 Telok Blangah Drive\nSingapore 100046", "fetdt" : { "$date" : 1345018961538 }, "latlng" : [ 1.271791, 103.80994 ], "name" : "46 Telok Blangah Drive", "pcode" : 100046, "url" : "http://gothere.sg/maps#q:100046" }

{ "_id" : 1000470, "addr" : "47 Telok Blangah Drive\nSingapore 100047", "fetdt" : { "$date" : 1345018961540 }, "latlng" : [ 1.2721345, 103.81018 ], "name" : "47 Telok Blangah Drive", "pcode" : 100047, "url" : "http://gothere.sg/maps#q:100047" }
	
	基本功能
		基于位置的检索
		即敲即得式检索
	加分项
		容错
		手机上实现客户端
		
		
						
				
				
//0522
cannot calm 'cause comes a strom.
but all storms get calms.

静不下心来，学学deep learning。
			
	http://deeplearning.net/
	
	This website is intended to host a variety of resources and pointers to information about Deep Learning. In these pages you will find

		a reading list,
		links to software,
		datasets,
		a list of deep learning research groups and labs,
		a list of announcements for deep learning related jobs (job listings),
		as well as tutorials and cool demos.
	
	
《Learning Deep Architectures for AI》

	
	
				
				
				
				
				
				
//0528,predictor				
				
	xxd -c 10 *.cbp4 | more			
				
	|	 f7c7 1510 	 |	 fdc7 1510	 | 		06 		| 	01			
			PC		  	branchTarget		opType		branchTaken
			
	0000000: f7c7 1510 fdc7 1510 0601  ..........
	000000a: fdc7 1510 0000 0000 0200  ..........
	0000014: fec7 1510 0000 0000 0200  ..........
	000001e: 01c8 1510 0000 0000 0200  ..........
				
	typedef enum {
		OPTYPE_LOAD = 0,
		OPTYPE_STORE = 1,
		OPTYPE_OP = 2,
		OPTYPE_CALL_DIRECT = 3,
		OPTYPE_RET = 4,
		OPTYPE_BRANCH_UNCOND = 5,
		OPTYPE_BRANCH_COND = 6,
		OPTYPE_INDIRECT_BR_CALL = 7,
		OPTYPE_MAX = 8
	} OpType;			
				
				
	PREDICTOR类private部分:
		 分支预测算法所需使用的数据结构。
		 可以自己定义。				
				
	GetPrediction(
		UINT32 PC
		//预测条件转移指令是否发生跳转
		//待预测指令的指令地址
	);
	注:本函数用于完成条件转移指令的分支预测。关于当前指令可
	用的信息只有指令地址,其它信息不可用于预测。			
				
	UpdatePredictor(
		UINT32 PC,
		//每当执行条件转移指令时调用
		//当前指令的地址
		bool resolveDir,
		bool predDir,
		//当前指令实际是否跳转,true表示跳转
		//当前指令是否被预测为跳转,true表示跳转
		UINT32 branchTarget
		//跳转的目标地址
	);			
				
	TrackOtherInst(
		UINT32 PC,
		//每当执行非条件转移指令时调用
		//当前指令的地址
		OpType opType,
		//当前指令的操作码
		UINT32 branchTarget
		//跳转的目标地址
	);
	注:若opType显示当前指令不是转移指令,则branchTarget
	的取值没有意义。本函数用于跟踪非条件转移指令的执行情况。			
				
				
NUM_INSTRUCTIONS     	 :   29499993
NUM_CONDITIONAL_BR   	 :    4874888
NUM_MISPREDICTIONS   	 :      53426
MISPRED_PER_1K_INST  	 :      1.811				
				
				
Bit Fields

	Bit Fields allow the packing of data in a structure. This is especially useful when memory or data storage is at a premium. Typical examples:

	Packing several objects into a machine word. e.g. 1 bit flags can be compacted -- Symbol tables in compilers.
	Reading external file formats -- non-standard file formats could be read in. E.g. 9 bit integers.
	C lets us do this in a structure definition by putting :bit length after the variable. i.e. 


	struct packed_struct {
			 unsigned int f1:1;
			 unsigned int f2:1;
			 unsigned int f3:1;
			 unsigned int f4:1;
			 unsigned int type:4;
			 unsigned int funny_int:9;
	} pack;				
					
	Here the packed_struct contains 6 members: Four 1 bit flags f1..f3, a 4 bit type and a 9 bit funny_int. 

	C automatically packs the above bit fields as compactly as possible, provided that the maximum length of the field is less than or equal to the integer word length of the computer. If this is not the case then some compilers may allow memory overlap for the fields whilst other would store the next field in the next word (see comments on bit fiels portability below). 

	Access members as usual via: 

   pack.type = 7; 				
				
				
				
				
//0529
	PREDICTOR类的private部分定义了分支预测算法所需维护
	的数据。
	 注意分支预测算法所维护数据的总大小不得超过32KB。
	 存储需求计算:
	 计算的是用硬件实现相关数据结构所需的开销
	 不一定等于C++实现中数据结构的大小
	 例:
	 数据结构:unsigned data[10],每个元素存储4种状态,用0-
	3表示。
	 存储需求为:2 * 10 = 20 bits
	 而不是:32 * 10 = 320 bits
================================================== ====================================================				
================================================= =====================================================				
==================================================== ==================================================				
	./getdata.pl -d ../results/GSHARE.32KB.back/
	ResultDirs ==>      	ARE.32KB.back/	

	LONG-SPEC2K6-00     	       3.974 	
	LONG-SPEC2K6-01     	       8.406 	
	LONG-SPEC2K6-02     	       5.176 	
	LONG-SPEC2K6-03     	       5.658 	
	LONG-SPEC2K6-04     	      10.739 	
	LONG-SPEC2K6-05     	       5.780 	
	LONG-SPEC2K6-06     	       4.160 	
	LONG-SPEC2K6-07     	      14.062 	
	LONG-SPEC2K6-08     	       1.911 	
	LONG-SPEC2K6-09     	       5.502 	
	LONG-SPEC2K6-10     	       3.710 	
	LONG-SPEC2K6-11     	       3.929 	
	LONG-SPEC2K6-12     	      12.844 	
	LONG-SPEC2K6-13     	       9.880 	
	LONG-SPEC2K6-14     	       4.687 	
	LONG-SPEC2K6-15     	       2.648 	
	LONG-SPEC2K6-16     	       4.435 	
	LONG-SPEC2K6-17     	       5.464 	
	LONG-SPEC2K6-18     	       1.525 	
	LONG-SPEC2K6-19     	       2.599 	
	SHORT-FP-1          	       3.479 	
	SHORT-FP-2          	       1.061 	
	SHORT-FP-3          	       0.443 	
	SHORT-FP-4          	       0.258 	
	SHORT-FP-5          	       0.788 	
	SHORT-INT-1         	       7.347 	
	SHORT-INT-2         	       7.669 	
	SHORT-INT-3         	      11.784 	
	SHORT-INT-4         	       2.250 	
	SHORT-INT-5         	       0.438 	
	SHORT-MM-1          	       9.172 	
	SHORT-MM-2          	      10.601 	
	SHORT-MM-3          	       4.267 	
	SHORT-MM-4          	       1.811 	
	SHORT-MM-5          	       5.651 	
	SHORT-SERV-1        	       3.646 	
	SHORT-SERV-2        	       3.665 	
	SHORT-SERV-3        	       5.870 	
	SHORT-SERV-4        	       5.324 	
	SHORT-SERV-5        	       5.208 	

	AMEAN               	       5.196	
	//predictor
	《Piecewise Linear Branch Prediction》
	《Idealized Piecewise Linear Branch Prediction》
				
		The Perceptron Predictor  ->  	Piecewise Linear Branch Prediction	
				
				
				
				
				
	《SVMs for Improved Branch Prediction》			
		Modern computer architecture design increasingly puts pressure on the performance of accurate branch predictors to exploit instruction-level parallelism		
				
		Calder
		et al [5] train neural networks on static data (evidence-based static prediction) with the expectation that the
		pre-trained net performs well when deployed as a predictor. Such techniques often suﬀer from over-training and
		do not generalize well to unseen data.
		
				
				
//0530
		

1.simple peceptron				

				
	neural branch predictors:
				
	ResultDirs ==>      	s/GSHARE.32KB/	

	LONG-SPEC2K6-00     	       7.329 	
	LONG-SPEC2K6-01     	       9.778 	
	LONG-SPEC2K6-02     	      10.455 	
	LONG-SPEC2K6-03     	      11.797 	
	LONG-SPEC2K6-04     	      14.870 	
	LONG-SPEC2K6-05     	       7.472 	
	LONG-SPEC2K6-06     	       7.097 	
	LONG-SPEC2K6-07     	      18.779 	
	LONG-SPEC2K6-08     	       8.036 	
	LONG-SPEC2K6-09     	       8.382 	
	LONG-SPEC2K6-10     	       6.829 	
	LONG-SPEC2K6-11     	      19.261 	
	LONG-SPEC2K6-12     	      16.159 	
	LONG-SPEC2K6-13     	      20.872 	
	LONG-SPEC2K6-14     	      24.076 	
	LONG-SPEC2K6-15     	      10.757 	
	LONG-SPEC2K6-16     	       6.942 	
	LONG-SPEC2K6-17     	      14.649 	
	LONG-SPEC2K6-18     	       3.675 	
	LONG-SPEC2K6-19     	       7.101 	
	SHORT-FP-1          	       4.787 	
	SHORT-FP-2          	       1.784 	
	SHORT-FP-3          	       1.024 	
	SHORT-FP-4          	       0.852 	
	SHORT-FP-5          	       8.269 	
	SHORT-INT-1         	      10.385 	
	SHORT-INT-2         	      10.912 	
	SHORT-INT-3         	      18.466 	
	SHORT-INT-4         	       7.393 	
	SHORT-INT-5         	       0.771 	
	SHORT-MM-1          	      11.980 	
	SHORT-MM-2          	      12.676 	
	SHORT-MM-3          	       5.879 	
	SHORT-MM-4          	       3.812 	
	SHORT-MM-5          	       8.097 	
	SHORT-SERV-1        	       4.962 	
	SHORT-SERV-2        	       4.800 	
	SHORT-SERV-3        	       8.902 	
	SHORT-SERV-4        	       6.267 	
	SHORT-SERV-5        	       5.714 	

	AMEAN               	       9.301 			
					
				
				
				
				
				
				
	online SVM:
	
	http://stats.stackexchange.com/questions/26041/can-svm-do-stream-learning-one-example-at-a-time			
	http://stackoverflow.com/questions/3967460/can-an-svm-learn-incrementally			
				
============================================piecewize=================================================				
	<<<res/traces/LONG-SPEC2K6-09.cbp4.gz>>>
		(1)
		#define GHL 128
		#define THD 2
		#define SIGN_GHR(i) ((GHR[i])?1:-1)
		#define EXT(i) (((i) & 0xff))
		W[EXT(PC)][GA[i]][(pos - i) % GHL] += 1
		NUM_INSTRUCTIONS     	 :  149999993
		NUM_CONDITIONAL_BR   	 :   20449090
		NUM_MISPREDICTIONS   	 :     942571
		MISPRED_PER_1K_INST  	 :      6.284
		
		#define GHL 32
		MISPRED_PER_1K_INST  	 :      6.383
		
		#define GHL 16
		MISPRED_PER_1K_INST  	 :      6.111
	
		(2)
		W[EXT(PC)][GA[i]][0] += 1;
		
		(3)
		W[EXT(PC)][GA[i]][(pos - i) % GHL] += 3;
		
		(4)
		#define EXT(i) (((i) & 0x1ff) >> 1)
		
		
	<<<res/traces/SHORT-MM-4.cbp4.gz>>>			
============================================non-piecewize=================================================	
	<<<res/traces/LONG-SPEC2K6-09.cbp4.gz>>>
	
		(1) 
		#define GHL 32
		#define THD 2
		NUM_INSTRUCTIONS     	 :  149999993
		NUM_CONDITIONAL_BR   	 :   20449090
		NUM_MISPREDICTIONS   	 :     968928
		MISPRED_PER_1K_INST  	 :      6.460	
		
		#define GHL 16
		#define THD 2
		MISPRED_PER_1K_INST  	 :      6.184
		
		(2) XOR(g-share)
		#define GHL 16
		#define THD 0
		#define EXT(i) (((i) ^ ghr) & 0xff )
		#define GSHARE(i) (((i) ^ ghr) & 0xff )
		output += W[EXT(PC)][(pos - i) % GHL];
		MISPRED_PER_1K_INST  	 :      6.001
		
		#define GHL 8
		#define THD 0
		#define SIGN_GHR(i) ((GHR[i])?1:-1)
		#define EXT(i) (((i) ^ ghr) & 0xfff )
		int W[4096][GHL];	// 12 bit * 32 = 17 bit
		int H[4096];	// 12 bit * 2 = 13 bit
		int W0[4096];	// 12 bit
		bool GHR[GHL];	// GHL bits
		MISPRED_PER_1K_INST  	 :      6.075
		
		output += (8 * (H[GSHARE(PC)] - 1));
		MISPRED_PER_1K_INST  	 :      6.104
		
		MISPRED_PER_1K_INST  	 :      6.075
		
		
		#define GHL 8
		#define ADP_M (GHL/2)
		#define ADP_U 3
		MISPRED_PER_1K_INST  	 :      6.076
	<<<res/traces/SHORT-MM-4.cbp4.gz>>>
		#define GHL 16
		#define THD 2
		NUM_INSTRUCTIONS     	 :   29499993
		NUM_CONDITIONAL_BR   	 :    4874888
		NUM_MISPREDICTIONS   	 :      89374
		MISPRED_PER_1K_INST  	 :      3.030
		
		#define GHL 16
		#define THD 0
		MISPRED_PER_1K_INST  	 :      3.036
		
		
		
==================================================origen=======================================================			
		[local hist table]
		<<<res/traces/LONG-SPEC2K6-09.cbp4.gz>>>
		UINT32 phtIndex = ((PC << 17) | (ghr & 0x1ffff)) % (numPhtEntries);
		
		NUM_INSTRUCTIONS     	 :  149999993
		NUM_CONDITIONAL_BR   	 :   20449090
		NUM_MISPREDICTIONS   	 :     821431
		MISPRED_PER_1K_INST  	 :      5.476
		
		
		
		
		
ResultDirs ==>      	s/GSHARE.32KB/	

LONG-SPEC2K6-00     	       5.367 	
LONG-SPEC2K6-01     	       8.506 	
LONG-SPEC2K6-02     	       5.730 	
LONG-SPEC2K6-03     	       5.879 	
LONG-SPEC2K6-04     	      10.917 	
LONG-SPEC2K6-05     	       5.981 	
LONG-SPEC2K6-06     	       4.547 	
LONG-SPEC2K6-07     	      19.382 	
LONG-SPEC2K6-08     	       1.937 	
LONG-SPEC2K6-09     	       5.526 	
LONG-SPEC2K6-10     	       4.864 	
LONG-SPEC2K6-11     	       3.919 	
LONG-SPEC2K6-12     	      13.042 	
LONG-SPEC2K6-13     	      13.087 	
LONG-SPEC2K6-14     	       4.690 	
LONG-SPEC2K6-15     	       2.908 	
LONG-SPEC2K6-16     	xxxxxxxxxxx 	
LONG-SPEC2K6-17     	xxxxxxxxxxx 	
LONG-SPEC2K6-18     	xxxxxxxxxxx 	
LONG-SPEC2K6-19     	xxxxxxxxxxx 	
SHORT-FP-1          	       3.838 	
SHORT-FP-2          	       1.127 	
SHORT-FP-3          	       0.444 	
SHORT-FP-4          	       0.320 	
SHORT-FP-5          	       0.814 	
SHORT-INT-1         	       7.909 	
SHORT-INT-2         	       8.379 	
SHORT-INT-3         	      14.527 	
SHORT-INT-4         	       2.550 	
SHORT-INT-5         	       0.474 	
SHORT-MM-1          	       9.204 	
SHORT-MM-2          	      11.212 	
SHORT-MM-3          	       4.339 	
SHORT-MM-4          	       1.910 	
SHORT-MM-5          	       7.297 	
SHORT-SERV-1        	       5.508 	
SHORT-SERV-2        	       5.591 	
SHORT-SERV-3        	       7.044 	
SHORT-SERV-4        	       6.596 	
SHORT-SERV-5        	       6.540 	

AMEAN               	       5.548		
		
		
==================================================local=======================================================			
		
	ResultDirs ==>      	s/GSHARE.32KB/	

LONG-SPEC2K6-00     	       4.684 	
LONG-SPEC2K6-01     	       8.303 	
LONG-SPEC2K6-02     	       8.456 	
LONG-SPEC2K6-03     	       5.098 	
LONG-SPEC2K6-04     	      11.157 	
LONG-SPEC2K6-05     	       7.192 	
LONG-SPEC2K6-06     	       2.653 	
LONG-SPEC2K6-07     	      19.100 	
LONG-SPEC2K6-08     	       1.535 	
LONG-SPEC2K6-09     	       4.880 	
LONG-SPEC2K6-10     	       4.696 	
LONG-SPEC2K6-11     	       1.014 	
LONG-SPEC2K6-12     	      14.424 	
LONG-SPEC2K6-13     	      15.043 	
LONG-SPEC2K6-14     	       1.202 	
LONG-SPEC2K6-15     	       2.048 	
LONG-SPEC2K6-16     	       4.671 	
LONG-SPEC2K6-17     	       8.659 	
LONG-SPEC2K6-18     	       1.785 	
LONG-SPEC2K6-19     	       2.333 	
SHORT-FP-1          	       2.787 	
SHORT-FP-2          	       1.782 	
SHORT-FP-3          	       0.563 	
SHORT-FP-4          	       0.381 	
SHORT-FP-5          	       0.773 	
SHORT-INT-1         	       6.105 	
SHORT-INT-2         	      11.876 	
SHORT-INT-3         	      16.434 	
SHORT-INT-4         	       2.319 	
SHORT-INT-5         	       0.433 	
SHORT-MM-1          	      10.482 	
SHORT-MM-2          	      13.638 	
SHORT-MM-3          	       0.746 	
SHORT-MM-4          	       2.511 	
SHORT-MM-5          	       5.747 	
SHORT-SERV-1        	       6.838 	
SHORT-SERV-2        	       7.139 	
SHORT-SERV-3        	       6.801 	
SHORT-SERV-4        	       7.462 	
SHORT-SERV-5        	       7.440 	

AMEAN               	       6.030	
			
			
==================================================hybrid=======================================================			

	(1) hybrid of gshare-local		
	pred = (C[HYBRID(PC)] > 1) ? pred_loc : pred_gsh;
		ResultDirs ==>      	s/GSHARE.32KB/	

		LONG-SPEC2K6-00     	       4.830 	
		LONG-SPEC2K6-01     	       8.398 	
		LONG-SPEC2K6-02     	       8.469 	
		LONG-SPEC2K6-03     	       5.099 	
		LONG-SPEC2K6-04     	      11.150 	
		LONG-SPEC2K6-05     	       7.211 	
		LONG-SPEC2K6-06     	       2.655 	
		LONG-SPEC2K6-07     	      19.190 	
		LONG-SPEC2K6-08     	       1.562 	
		LONG-SPEC2K6-09     	       4.975 	
		LONG-SPEC2K6-10     	       4.736 	
		LONG-SPEC2K6-11     	       1.019 	
		LONG-SPEC2K6-12     	      14.424 	
		LONG-SPEC2K6-13     	      15.139 	
		LONG-SPEC2K6-14     	       1.201 	
		LONG-SPEC2K6-15     	       2.075 	
		LONG-SPEC2K6-16     	       4.706 	
		LONG-SPEC2K6-17     	       8.683 	
		LONG-SPEC2K6-18     	       1.787 	
		LONG-SPEC2K6-19     	       2.359 	
		SHORT-FP-1          	       2.826 	
		SHORT-FP-2          	       1.791 	
		SHORT-FP-3          	       0.580 	
		SHORT-FP-4          	       0.386 	
		SHORT-FP-5          	       0.773 	
		SHORT-INT-1         	       6.139 	
		SHORT-INT-2         	      12.478 	
		SHORT-INT-3         	      16.518 	
		SHORT-INT-4         	       2.380 	
		SHORT-INT-5         	       0.459 	
		SHORT-MM-1          	      10.928 	
		SHORT-MM-2          	      13.832 	
		SHORT-MM-3          	       0.804 	
		SHORT-MM-4          	       2.570 	
		SHORT-MM-5          	       6.077 	
		SHORT-SERV-1        	       7.302 	
		SHORT-SERV-2        	       7.613 	
		SHORT-SERV-3        	       7.387 	
		SHORT-SERV-4        	       8.192 	
		SHORT-SERV-5        	       8.164 	

		AMEAN               	       6.172		
	
pred = (phtCounter + L2[LOCAL2(L1[LOCAL1(PC)])]) > 3;
// pred = (0.5 * (float)phtCounter + 0.5 * (float)L2[LOCAL2(L1[LOCAL1(PC)])]) * 2 > 3;		
	ResultDirs ==>      	s/GSHARE.32KB/	

	LONG-SPEC2K6-00     	       3.370 	
	LONG-SPEC2K6-01     	       7.644 	
	LONG-SPEC2K6-02     	       5.307 	
	LONG-SPEC2K6-03     	       4.786 	
	LONG-SPEC2K6-04     	       9.741 	
	LONG-SPEC2K6-05     	       5.505 	
	LONG-SPEC2K6-06     	       2.724 	
	LONG-SPEC2K6-07     	      13.736 	
	LONG-SPEC2K6-08     	       1.596 	
	LONG-SPEC2K6-09     	       4.912 	
	LONG-SPEC2K6-10     	       3.464 	
	LONG-SPEC2K6-11     	       0.893 	
	LONG-SPEC2K6-12     	      12.552 	
	LONG-SPEC2K6-13     	      10.583 	
	LONG-SPEC2K6-14     	       1.852 	
	LONG-SPEC2K6-15     	       2.021 	
	LONG-SPEC2K6-16     	       3.963 	
	LONG-SPEC2K6-17     	       5.858 	
	LONG-SPEC2K6-18     	       1.813 	
	LONG-SPEC2K6-19     	       2.393 	
	SHORT-FP-1          	       2.758 	
	SHORT-FP-2          	       1.198 	
	SHORT-FP-3          	       0.470 	
	SHORT-FP-4          	       0.260 	
	SHORT-FP-5          	       0.468 	
	SHORT-INT-1         	       5.252 	
	SHORT-INT-2         	       8.331 	
	SHORT-INT-3         	      11.925 	
	SHORT-INT-4         	       1.838 	
	SHORT-INT-5         	       0.409 	
	SHORT-MM-1          	       8.870 	
	SHORT-MM-2          	      11.043 	
	SHORT-MM-3          	       1.541 	
	SHORT-MM-4          	       1.901 	
	SHORT-MM-5          	       4.782 	
	SHORT-SERV-1        	       4.532 	
	SHORT-SERV-2        	       4.699 	
	SHORT-SERV-3        	       5.181 	
	SHORT-SERV-4        	       5.200 	
	SHORT-SERV-5        	       5.261 	

	AMEAN               	       4.766		
#define GHL 16
#define ADP_M (GHL/2)
#define ADP_U 3
#define THD 0
#define SIGN_GHR(i) ((GHR[i])?1:-1)
//#define EXT(i) (((i) & 0xff))
#define EXT(i) (((i) ^ ghr) & 0x7ff )
#define BIMODAL(i) (((i) ^ ghr) & 0x7fff )
#define HYBRID(i) (((i) ^ ghr) & 0x7fff )
#define LOCAL1(i) ((i) & 0x1fff )
#define LOCAL2(i) ((i) & 0xffff )
int C[32768];	// 15 bit * 2 = 16 bit
UINT32 L1[8192]; // 13bit * 16 = 17 bit
UINT32 L2[65536]; // 16bit * 2 = 17 bit
				
pred = (0.6 * (float)phtCounter + 0.4 * (float)L2[LOCAL2(L1[LOCAL1(PC)])]) * 2 > 3;			
	ResultDirs ==>      	s/GSHARE.32KB/	

	LONG-SPEC2K6-00     	       3.259 	
	LONG-SPEC2K6-01     	       7.661 	
	LONG-SPEC2K6-02     	       4.237 	
	LONG-SPEC2K6-03     	       5.061 	
	LONG-SPEC2K6-04     	       9.706 	
	LONG-SPEC2K6-05     	       5.302 	
	LONG-SPEC2K6-06     	       3.401 	
	LONG-SPEC2K6-07     	      11.791 	
	LONG-SPEC2K6-08     	       1.748 	
	LONG-SPEC2K6-09     	       5.012 	
	LONG-SPEC2K6-10     	       2.962 	
	LONG-SPEC2K6-11     	       3.788 	
	LONG-SPEC2K6-12     	      12.220 	
	LONG-SPEC2K6-13     	       8.537 	
	LONG-SPEC2K6-14     	       2.725 	
	LONG-SPEC2K6-15     	       2.074 	
	LONG-SPEC2K6-16     	       3.995 	
	LONG-SPEC2K6-17     	       4.667 	
	LONG-SPEC2K6-18     	       1.523 	
	LONG-SPEC2K6-19     	       2.407 	
	SHORT-FP-1          	       2.758 	
	SHORT-FP-2          	       0.933 	
	SHORT-FP-3          	       0.425 	
	SHORT-FP-4          	       0.251 	
	SHORT-FP-5          	       0.786 	
	SHORT-INT-1         	       5.262 	
	SHORT-INT-2         	       6.052 	
	SHORT-INT-3         	       9.891 	
	SHORT-INT-4         	       1.837 	
	SHORT-INT-5         	       0.374 	
	SHORT-MM-1          	       8.073 	
	SHORT-MM-2          	       9.814 	
	SHORT-MM-3          	       2.827 	
	SHORT-MM-4          	       1.704 	
	SHORT-MM-5          	       4.393 	
	SHORT-SERV-1        	       2.599 	
	SHORT-SERV-2        	       2.566 	
	SHORT-SERV-3        	       4.444 	
	SHORT-SERV-4        	       3.673 	
	SHORT-SERV-5        	       3.662 	

	AMEAN               	       4.360			
	
	==================================================权衡1：L1 and L2
	
	
	#define GSHARE(i) (((i) ^ ghr) & 0x7fff )
	#define HYBRID(i) (((i) ^ ghr) & 0x7fff )
	#define LOCAL1(i) ((i) & 0xfff )
	#define LOCAL2(i) ((i) & 0xfff )	
	UINT32 *pht;          // pattern history table	// 15bit * 2 = 16bit		
	int C[16384];	// 14 bit * 2 = 15 bit		
	UINT32 L1[4096]; // 12bit * 12 = 15.6 bit
	UINT32 L2[4096]; // 12bit * 2 = 13 bit
	pred = (0.0 * (float)phtCounter + 1.0 * (float)L2[LOCAL2(L1[LOCAL1(PC)])]) * 2 > 3;
	NUM_INSTRUCTIONS     	 :  149999993
	NUM_CONDITIONAL_BR   	 :   20449090
	NUM_MISPREDICTIONS   	 :     752106
	MISPRED_PER_1K_INST  	 :      5.014
	
	#define LOCAL1(i) ((i) & 0x7ff )
	#define LOCAL2(i) ((i) & 0xffff )
	UINT32 L1[2048]; // 11bit * 16 = 15 bit
	UINT32 L2[65536]; // 16bit * 2 = 17 bit
	pred = (0.0 * (float)phtCounter + 1.0 * (float)L2[LOCAL2(L1[LOCAL1(PC)])]) * 2 > 3;
	NUM_INSTRUCTIONS     	 :  149999993
	NUM_CONDITIONAL_BR   	 :   20449090
	NUM_MISPREDICTIONS   	 :     733146
	MISPRED_PER_1K_INST  	 :      4.888

UINT32 *pht;          // pattern history table	// 15bit * 2 = 16bit
UINT32 L1[2048]; // 12bit * 16 = 15 bit
UINT32 L2[65536]; // 16bit * 2 = 17 bit
pred = (0.0 * (float)phtCounter + 1.0 * (float)L2[LOCAL2(L1[LOCAL1(PC)])]) * 2 > 3;
ResultDirs ==>      	s/GSHARE.32KB/	

LONG-SPEC2K6-00     	       4.503 	
LONG-SPEC2K6-01     	       7.854 	
LONG-SPEC2K6-02     	       4.660 	
LONG-SPEC2K6-03     	       5.282 	
LONG-SPEC2K6-04     	       9.821 	
LONG-SPEC2K6-05     	       5.437 	
LONG-SPEC2K6-06     	       3.835 	
LONG-SPEC2K6-07     	      16.245 	
LONG-SPEC2K6-08     	       1.802 	
LONG-SPEC2K6-09     	       5.056 	
LONG-SPEC2K6-10     	       3.953 	
LONG-SPEC2K6-11     	       3.778 	
LONG-SPEC2K6-12     	      12.364 	
LONG-SPEC2K6-13     	      11.175 	
LONG-SPEC2K6-14     	       3.488 	
LONG-SPEC2K6-15     	       2.443 	
LONG-SPEC2K6-16     	       4.430 	
LONG-SPEC2K6-17     	       5.153 	
LONG-SPEC2K6-18     	       1.523 	
LONG-SPEC2K6-19     	       2.447 	
SHORT-FP-1          	       2.995 	
SHORT-FP-2          	       0.994 	
SHORT-FP-3          	       0.426 	
SHORT-FP-4          	       0.334 	
SHORT-FP-5          	       0.804 	
SHORT-INT-1         	       5.848 	
SHORT-INT-2         	       7.385 	
SHORT-INT-3         	      13.056 	
SHORT-INT-4         	       2.056 	
SHORT-INT-5         	       0.409 	
SHORT-MM-1          	       8.437 	
SHORT-MM-2          	      10.249 	
SHORT-MM-3          	       3.097 	
SHORT-MM-4          	       1.738 	
SHORT-MM-5          	       5.549 	
SHORT-SERV-1        	       4.837 	
SHORT-SERV-2        	       4.928 	
SHORT-SERV-3        	       5.852 	
SHORT-SERV-4        	       5.814 	
SHORT-SERV-5        	       5.785 	

AMEAN               	       5.146

	==================================================权衡2： gshare and local
	
	
	
	#define GSHARE(i) ((((i)) ^ ghr) & 0x1ffff )
	#define HYBRID(i) (((i) ^ ghr) & 0x7fff )
	#define LOCAL1(i) ((i) & 0xfff )
	//#define LOCAL2(i) ((i) & 0xffff )
	#define LOCAL2(i) (((PC<< 12) | ((i) & 0xfff) ) & 0x3fff )
	UINT32 *pht;          // pattern history table	// 16bit * 2 = 17bit
	int C[16384];	// 14 bit * 2 = 15 bit
	UINT32 L1[4096]; // 12bit * 12 = 15.6 bit
	UINT32 L2[16384]; // 14bit * 2 = 15 bit	
	pred = (0.6 * (float)phtCounter + 0.4 * (float)L2[LOCAL2(L1[LOCAL1(PC)])]) * 2 > 3;
	ResultDirs ==>      	s/GSHARE.32KB/	

LONG-SPEC2K6-00     	       3.320 	
LONG-SPEC2K6-01     	       7.692 	
LONG-SPEC2K6-02     	       4.510 	
LONG-SPEC2K6-03     	       5.169 	
LONG-SPEC2K6-04     	       9.802 	
LONG-SPEC2K6-05     	       5.319 	
LONG-SPEC2K6-06     	       3.399 	
LONG-SPEC2K6-07     	      12.067 	
LONG-SPEC2K6-08     	       1.746 	
LONG-SPEC2K6-09     	       5.122 	
LONG-SPEC2K6-10     	       3.024 	
LONG-SPEC2K6-11     	       3.783 	
LONG-SPEC2K6-12     	      12.233 	
LONG-SPEC2K6-13     	       8.675 	
LONG-SPEC2K6-14     	       2.725 	
LONG-SPEC2K6-15     	       2.101 	
LONG-SPEC2K6-16     	       4.045 	
LONG-SPEC2K6-17     	       4.700 	
LONG-SPEC2K6-18     	       1.523 	
LONG-SPEC2K6-19     	       2.410 	
SHORT-FP-1          	       3.006 	
SHORT-FP-2          	       0.947 	
SHORT-FP-3          	       0.426 	
SHORT-FP-4          	       0.252 	
SHORT-FP-5          	       0.787 	
SHORT-INT-1         	       5.450 	
SHORT-INT-2         	       6.164 	
SHORT-INT-3         	       9.951 	
SHORT-INT-4         	       1.886 	
SHORT-INT-5         	       0.377 	
SHORT-MM-1          	       8.093 	
SHORT-MM-2          	       9.852 	
SHORT-MM-3          	       2.788 	
SHORT-MM-4          	       1.695 	
SHORT-MM-5          	       4.531 	
SHORT-SERV-1        	       2.746 	
SHORT-SERV-2        	       2.725 	
SHORT-SERV-3        	       4.613 	
SHORT-SERV-4        	       3.883 	
SHORT-SERV-5        	       3.825 	

AMEAN               	       4.434
		
	Branch predictors exploit the correlation between the history of a branch and its outcome			
				
	《Adaptive Information Processing: An Effective Way to Improve Perceptron Branch Predictors》
				
	In this paper, an important observation is made that the perceptron weights can be used to estimate
	the strength of branch correlation. Based such an estimate, adaptive schemes are proposed to
	preprocess history information so that the input vector to a perceptron predictor contains only
	those history bits with the strongest correlation. In this way, a much larger history-information set
	can be explored effectively without increasing the size of perceptron predictors.			
					
	One main reason is that the cost of a perceptron predictor scales linearly rather than exponentially, thereby enabling it to explore correlation from much longer information vectors.			
		
	In a recent study [8], the accuracy of perceptron predictors is further improved with the following extensions: using pseudo-tag to reduce aliasing impact, skewing perceptron weight tables to improve table utilization, and introducing redundant history to handle linearly inseparable data sets.(总结得很精到)The nonlinear redundant history also leads to a more efficient representation, Multiply-Add Contributions (MAC)
		
	[5] D. Jimenez and C. Lin, “Dynamic branch prediction with perceptrons”, Proc. of the 7th Int.
	Symp. on High Perf. Comp. Arch (HPCA-7), 2001.
	[6] D. Jimenez and C. Lin, “Neural methods for dynamic branch prediction”, ACM Trans. on
	Computer Systems, 2002.			
				
				
				
	http://en.wikipedia.org/wiki/Branch_predictor	介绍了一些典型的perdictor的原理及实现。		 
				
				
				
				
	Why TAGE is the best			
	http://comparch.net/2013/06/30/why-tage-is-the-best/			
				
				
				
				
	Hybrid predictor - gskew predictors			
				
		Combining Branch Predictors
				
				
				
				
//0601
1.两层local
2.multipl-gshare
3.piecewise
4.tage				
				
				
	#define GSHARE(i) ((((i)) ^ ghr) & 0x1ffff )
#define HYBRID(i) (((i) ^ ghr) & 0x7fff )
#define LOCAL1(i) ((i) & 0xfff )
//#define LOCAL2(i) ((i) & 0xffff )
#define LOCAL2(i) (((PC<< 13) | ((i) & 0x1fff) ) & 0x7fff )			
				
				
				
				
				
			Combining Branch Predictors
Scott McFarling	
				
				
	Piecewise Linear Branch Prediction			
			Daniel A. Jimenez	
				
		Idealized Piecewise Linear Branch Prediction		
				
				
				
		Idealized Piecewise Linear Branch Prediction		
				
				
				
	SVMs for Improved Branch Prediction			
		Benjamin J. Culpepper		
				
				
//0602
公钥密码算法RSA的实现，包括加密和解密算法。 素数的选取（选用强素数）每个同学不能相同。要提交实现方法和C-代码，以及实现结果。				
				
	欧拉函数的值: φ(m)指模m的简系个数
	\varphi(1)=1（小于等于1的正整数中唯一和1互质的数就是1本身）。

	若n是质数p的k次幂，\varphi(n)=\varphi(p^k)=p^k-p^{k-1}=(p-1)p^{k-1}，因为除了p的倍数外，其他数都跟n互质。

	欧拉函数是积性函数，即是说若m,n互质，\varphi(mn)=\varphi(m)\varphi(n)。证明：设A, B, C是跟m, n, mn互质的数的集，据中国剩余定理，A \times B和C可建立双射(一一对应)的关系。因此\varphi(n)的值使用算术基本定理便知，

	若n = p_1^{k_1} p_2^{k_2} \cdots p_r^{k_r}
	则\varphi(n) = \prod_{i=1}^r p_i^{k_i-1}(p_i-1) = \prod_{p\mid n} p^{\alpha_p-1}(p-1) = n\prod_{p|n}\left(1-\frac{1}{p}\right)。
	其中\alpha_p是使得p^{\alpha}整除n的最大整数\alpha（这里\alpha_{p_i} = k_i）。

	例如\varphi(72)=\varphi(2^3\times3^2)=2^{3-1}(2-1)\times3^{2-1}(3-1)=2^2\times1\times3\times2=24			
					
				
	欧拉定理 (数论)			
	a^{\varphi(n)} \equiv 1 \pmod n			
				
				
	模n的剩余类环Zn中的任意元素a是可逆的充要条件是a与n互素，即 (a,n)=1。			
				
	Zn中共有Φ(n)个可逆元，这些元素构成集合Zn*。
			
				
				
	openssl genrsa -out ~/Desktop/test.key 1024			
	openssl rsa -in test.key -pubout -out test_pub.key			
	openssl rsautl -encrypt  -pubin -in hello -inkey test_pub.key -out hello.en			
	openssl rsautl -decrypt -in hello.en -inkey test.key -out hello.de			
				
				
	//锟斤拷锟斤拷锟斤拷锟斤拷				
	Unicode和老编码体系的转化过程中，肯定有一些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：U+FFFD REPLACEMENT CHARACTER。
	那么U+FFFD的UTF-8编码出来，恰好是 '\xef\xbf\xbd'。如果这个'\xef\xbf\xbd'，重复多次，例如 '\xef\xbf\xbd\xef\xbf\xbd'，然后放到GBK/CP936/GB2312/GB18030的环境中显示的话，一个汉字2个字节，最终的结果就是：锟斤拷——锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD）[1]。				
				
				
	u'\uFFFD'.encode('utf-8')*2
	printu'\uFFFD'.encode('utf-8')*2			
				
				
				
	%I64d			
				
				
				
				
				
	
total:	1229
			
				
				
// 0604
并行最终节点确定：week 18

助教： jacobi迭代
		针对不同的级别进行优化：L1 -> L2 -> L3
		
		numbers every computer engineer should know 
			by Jeff Dean
				
		refer:
		(for cache blocking)
			stencil
			3d-finite-differences-on-multi-core-processors
			PATUS	：stencil自动调优框架
			stencilProbe
				
				
众核编程：
		MIC
		Many Integrated Core		
		
		//密码学		
		(a.lw[i] << n) + carry;		
		注意：移位的优先级2很低。		
						
公钥密码算法RSA的实现，包括加密和解密算法。 素数的选取（选用强素数）每个同学不能相同。要提交实现方法和C-代码，以及实现结果。				
		
				
//0605
Language:
C++, Matlab or Python
You can use image I/O function.
Other image functions in matlab, python, openCV, openGL and other image processing lib are forbidden


	数字图像实验一：
	<<<BASIC>>>
		1.Point Processing
			1.1 Brightness and contrast adjustment
			1.2 Gamma correction
			1.3 Histogram equalization
			1.4 Color correction
		2. Image Rotation
			2.1 Warping: Map Image to Sphere
	<<<EXT-1>>>	
		Image Fusion
			方法：图像的泊松编辑 http://blog.sina.com.cn/s/blog_9cc4e24d0100x7b1.html
	<<<EXT-2>>>		
		Image stitching			
				
				
	//安装Engin3：http://blog.csdn.net/abcjennifer/article/details/7781936			
	using is used for a specific (single) method whereas using namespace "imports" all methods/variables from a namespace.				
				
	其中，Delta I_A表示融合图像块的梯度，上面的变分方程的意义表明我们的无缝融合是以源图像块内梯度场为指导，将融合边界上目标场景和源图像的差异平滑地扩散到融合图像块I中，这样的话，融合后的图像块能够无缝地融合到目标场景中，并且其色调和光照可以与目标场景相一致			
	
	demos：
	http://www.howardzzh.com/research/poissonImageEditing/index.htm			
	https://gist.github.com/thorikawa/1192946
				
	opencv_objdetect
	opencv_video
	opencv_imgproc
	opencv_videostab
	opencv_legacy
	opencv_stitching
	opencv_highgui
	opencv_calib3d
	opencv_ml
	opencv_ts
	opencv_features2d
	opencv_contrib
	opencv_flann
	opencv_core
	opencv_photo

	/usr/include/opencv			
			
	png12
	pthread
				
	/home/chunk/Programs/lib/OpenCV-2.4.2/modules/objdetect/src			
				
				
	hog.winSize = Size(256, 256);
	hog.blockSize = Size(32, 32);
	hog.cellSize = Size(16, 16);
	hog.blockStride = Size(16, 16);			
				
	15*15 * 2*2 * 9 = 8100			
				
				
				
				
				
	Personally, I use cp -av for most of my heavy copying. That way, I can preserve everything - even recursively - and see the output. Of course, that is just personal preference.
	
	!!!!!!!!!!!!!!!!cp -av 可以保留所有东西！！！！！			
				
				
	服务器opencv配置过程：			
			
				
	1.尝试将本地的include和lib copy -av 到服务器，不过提示有些lib不能工作，因为需要的库找不到
	2.将opencv2.4.9源码拷贝到home，cmake编译，将编译后的lib连接到local/lib，之后能够正常编译，不过运行时找不到库
	3.指定运行时库：
			export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/group5/local/lib:/home/group5/local/lib/opencvlib	
			
			此时就可以运行了，不过有个fatal：
				libdc1394 error: Failed to initialize libdc1394
				terminate called after throwing an instance of 'std::logic_error'
				  what():  basic_string::_S_construct null not valid
				Aborted
			原因在于opencv会强制扫描所有可能需要的硬件。
			解决：不必管他！http://spottedsun.com/libdc1394-error-failed-to-initialize-libdc1394/	
				
	4.统计：
			find hog -type f -print | wc -l
				
		./dump 2>/dev/null >log		
		
		hog_64x64:		
		cv::resize(img, img, cvSize(64, 64));
		hog.winSize = Size(64, 64);
		hog.blockSize = Size(16, 16);
		hog.cellSize = Size(8, 8);
		hog.blockStride = Size(8, 8);
		hog.compute(img, ders, Size(64, 64), Size(0, 0), locs);		
				
	第二批专题展示的时间表
	第14周课前：第二批专题展示（专题6-10）的小组提交展示PPT（email发给何老师）
	第15周周一：在网络学堂上公布选中参与第二次课堂展示的小组名单
	第16周课上：第二批课程展示

	期末报告的时间表
	时间要求：6月15日（第16周周日）晚上10点前
	提交方式：只交电子版：word版（不要转换成PDF文件），请通过电子邮件发到何老师邮箱 hejianyu@tsinghua.edu.cn
	邮件标题：周*(4/5)班第**小组期末报告，文件名采取相同命名规则，如个人完成：周*班***(姓名)期末报告
	其他要求请参见课程文件中“期末报告要求”PPT			
				
				
	what does the cow say ????
	http://os.51cto.com/art/201304/390059.htm 			
				

http://www.ietf.org/rfc/rfc1186.txt
				
md4:
			The message is "padded" (extended) so that its length (in bits)
         is congruent to 448, modulo 512.  That is, the message is
         extended so that it is just 64 bits shy of being a multiple of
         512 bits long.  Padding is always performed, even if the length
         of the message is already congruent to 448, modulo 512 (in
         which case 512 bits of padding are added).				
		
		In the unlikely event that b is greater than
         2^64, then only the low-order 64 bits of b are used.  (These
         bits are appended as two 32-bit words and appended low-order
         word first in accordance with the previous conventions.		
	e.g.
	01100001 01100010 01100011 01100100 01100101
	
	61 62 63 64 65 80 00 00 00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	00 00 00 00 00 00 00 00 28 00 00 00 00 00 00 00
	
	At this point the resulting message (after padding with bits
	 and with b) has a length that is an exact multiple of 512 bits.
	 Equivalently, this message has a length that is an exact
	 multiple of 16 (32-bit) words.  Let M[0 ... N-1] denote the
	 words of the resulting message, where N is a multiple of 16.
         
    以16个32位字为一个分组(512bits):
         
	For i = 0 to N/16-1 do  /* process each 16-word block */
		 For j = 0 to 15 do: /* copy block i into X */
		   Set X[j] to M[i*16+j].
		 end /* of loop on j */
		 Save A as AA, B as BB, C as CC, and D as DD.
	
md5:

		
	A 64-bit representation of b (the length of the message before the
   padding bits were added) is appended to the result of the previous
   step. In the unlikely event that b is greater than 2^64, then only
   the low-order 64 bits of b are used. (These bits are appended as two
   32-bit words and appended low-order word first in accordance with the
   previous conventions.)
	
	
	
	Differences Between MD4 and MD5

	The following are the differences between MD4 and MD5:

	A fourth round has been added.
	Each step now has a unique additive constant.
	The function g in round 2 was changed from (XY v XZ v YZ) to (XZ v Y not(Z)) to make g less symmetric.
	Each step now adds in the result of the previous step. This promotes a faster "avalanche effect".
	The order in which input words are accessed in rounds 2 and 3 is changed, to make these patterns less like each other.
	The shift amounts in each round have been approximately optimized, to yield a faster "avalanche effect." The shifts in different rounds are distinct.
	
	a 0x61
	A 0x41
sha1：
		– 消息分组512比特
		– 链接变量长度160比特
		– 摘要长度160比特
	
	
完整性认证  vs （来源）真实性认证 （后者不仅要求完整，还要求来源真实）	
	
消息认证码（MAC）可以解决完整性认证，他是哈希函数和加密的融合，只要求单向的，但是同时需要密钥
	MAC提供数据完整性以及消息来源认证,但不具有不可否认性(数字签名具有不可否认性)
	
	
	
	http://book.51cto.com/art/200708/53206.htm
	4. 不可否认
	不可否认具有同意负责任这一属性。更确切地说，是无法反驳应尽的责任。例如，你拿了一支笔在（具有法律效力的）合同上签了自己的名字，那么你的签名就是一种不可否认的“设备”。事后你不能不同意合同上的条款或者拒绝承认曾经同意了合同。
	不可否认和认证的性质十分相似，因为从实现的角度上来讲，它们大都使用了相同的基本原理。例如，当且仅当一个特殊的成员具备签名能力的时候，他的公钥签名才能称为不可否认“设备”。因此，像CMAC和HACM这样的其他MAC算法都不能叫做不可否认设备。
	
	http://www.docin.com/p-512591361.html
	（自注：不可否认性类似一种服务或者协议，解决的是更高层次的问题，利害冲突。网络中的不可否认性是双向的）
	
	另外，MAC仍然是对称的，所以不能解决来源争议。（抵赖）
	
	所以，来源真实性认证是对外的，不可否认性是对内的。
	
	
Diffie–Hellman key exchange	
	http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange
	
	
	
	1、  GF(2^8)中任何数乘0x01都不变
	2、  GF(2^8)中计算乘0x02，可以分两种情况考虑：
	(1)、原数值小于(1000 0000)2，即0x80的时候，乘2后第8个比特不会溢出，那么结果就是原数值左移一位；
	(2)、原数值大于(1000 0000)2，即0x80的时候，乘2后第8个比特会溢出，结果需要减去一个不可约多项式(x8+x4+x2+x+1)，注意到GF(2^8)中的减法就是加法，那么结果就为原数值左移一位后(乘2)再与(0001 1011)2即0x1b进行异或(这里x8已经减掉了，只需要再减去x4+x2+x+1)。
	3、类似第2点，可以得到GF(2^8)中计算乘4、乘8的结果；
	4、GF(2^8)中计算乘其它数时，可以表示为乘1、2、4、8的线性组合。
	 
	根据以上几点再对有限域GF(2^8)上的乘法源代码进行解释：
	代码:
	void AES::MixColumns(unsigned char state[][4])    //列混合
	{
	  unsigned char t[4];
	  int r,c;
	  for(c=0; c< 4; c++)      //按列处理
	  {
		for(r=0; r<4; r++)
		{
		  t[r] = state[r][c];      //每一列中的每一个字节拷贝到t[r]中
		}
		for(r=0; r<4; r++)
		{
		  state[r][c] = FFmul(0x02, t[r])      //矩阵计算，其中加法为异或
				^ FFmul(0x03, t[(r+1)%4])
				^ FFmul(0x01, t[(r+2)%4])
				^ FFmul(0x01, t[(r+3)%4]);
		}
	  }
	}

	unsigned char AES::FFmul(unsigned char a, unsigned char b)    //有限域GF(2^8)上的乘法
	{
	  unsigned char bw[4];
	  unsigned char res=0;
	  int i;
	  bw[0] = b;
	  for(i=1; i<4; i++)      //循环三次，分别得到参数b乘2、4、8后的值，储存到bw[i]里面
	  {
		bw[i] = bw[i-1]<<1;    //原数值乘2
		if(bw[i-1]&0x80)    //判断原数值是否小于0x80
		{
		  bw[i]^=0x1b;    //如果大于0x80的话，减去一个不可约多项式
		}
	  }
	  for(i=0; i<4; i++)
	  {
		if((a>>i)&0x01)      //将参数a的值表示为1、2、4、8的线性组合
		{
		  res ^= bw[i];
		}
	  }
	  return res;
	}
	
	
	
//0609	
	
	服务器opencv配置过程：			
			
				
	1.尝试将本地的include和lib copy -av 到服务器，不过提示有些lib不能工作，因为需要的库找不到
	2.将opencv2.4.9源码拷贝到home，cmake编译，将编译后的lib连接到local/lib，之后能够正常编译，不过运行时找不到库
	3.指定运行时库：
			export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/group5/local/lib:/home/group5/local/lib/opencvlib	
			
			此时就可以运行了，不过有个fatal：
				libdc1394 error: Failed to initialize libdc1394
				terminate called after throwing an instance of 'std::logic_error'
				  what():  basic_string::_S_construct null not valid
				Aborted
			原因在于opencv会强制扫描所有可能需要的硬件。
			解决：不必管他！http://spottedsun.com/libdc1394-error-failed-to-initialize-libdc1394/	
				
	4.统计：
			find hog -type f -print | wc -l
				
		./dump 2>/dev/null >log		
		
		hog_64x64:		
		cv::resize(img, img, cvSize(64, 64));
		hog.winSize = Size(64, 64);
		hog.blockSize = Size(16, 16);
		hog.cellSize = Size(8, 8);
		hog.blockStride = Size(8, 8);
		hog.compute(img, ders, Size(64, 64), Size(0, 0), locs);		
	
	
	
	19889	/home/group5/dip-data/Dev/hog_64x64/85d/c3b90700b754c1bf60b15a24fd848.hog
	19890	/home/group5/dip-data/Dev/hog_64x64/85d/559f3a6abcd1a6f544793b83548b3.hog
	19891	/home/group5/dip-data/Dev/hog_64x64/814/48f022cc7edd797d7aae5833eead5.hog
	OpenCV Error: Assertion failed (func != 0) in transpose, file /home/group5/local/opencv-2.4.9/modules/core/src/matrix.cpp, line 2023
	terminate called after throwing an instance of 'cv::Exception'
	  what():  /home/group5/local/opencv-2.4.9/modules/core/src/matrix.cpp:2023: error: (-215) func != 0 in function transpose

	Aborted

	
	http://docs.opencv.org/trunk/doc/py_tutorials/py_ml/py_knn/py_knn_opencv/py_knn_opencv.html
	
	http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/#liblinear_for_one_versus_one_multi_class_classification
	"one-againse-one" and "one-against-the rest"
	
	
	http://scikit-learn.org/stable/modules/svm.html#multi-class-classification
	
	SVC and NuSVC implement the “one-against-one” approach (Knerr et al., 1990) for multi- class classification. If n_class is the number of classes, then n_class * (n_class - 1) / 2 classifiers are constructed and each one trains data from two classes:
	
	On the other hand, LinearSVC implements “one-vs-the-rest” multi-class strategy, thus training n_class models. If there are only two classes, only one model is trained:
	

1.	[系统结构] 第6次作业—互连与通信 06-12

2.	[数据挖掘] project 2 二分类问题 06-27
4.	[数据库专题训练] 课程大作业 06-20
7.	[并行计算基础]	 实验展示 06-24

6.	[微计算机技术]	 实验报告 06-22
8.  【系统结构】考试
	
3.	[系统结构] 读书与实验报告（延迟提交） 06-30	
5.	[中国国情与发展] 论文	06-24
		期末论文-40分
		选择课程内容，以“中国道路”为题，结合课程所讲内容，完成一篇学术论文（字数3000字以上），6月24日前提交至网络学堂
	
	
	
//0610

抠图算法：
		http://www.cnblogs.com/Imageshop/p/3550185.html
		http://www.inf.ufrgs.br/~eslgastal/SharedMatting/
		http://blog.sciencenet.cn/blog-4099-638485.html
	
		http://blog.csdn.net/tyf122/article/details/7730889
	
	
	
opencv ： pkg-config命令了解和使用	
	
	
	
	
	Google 学术：图像拼接 c++
基于SIFT 特征匹配的图像拼接算法
	
	http://blog.csdn.net/masibuaa/article/details/9246493
	
	
//0611
数据库	
	eclipse的yanse等pref信息在那个文件中？
	http://stackoverflow.com/questions/4818197/eclipse-syntax-coloring-file			
	
	Specifically:

	[workspace]\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.jdt.ui.prefs
	[workspace]\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.cdt.ui.prefs
	[workspace]\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.ui.editors.prefs
	
	Also, for future readers, @jonas-groger added comment below regarding http://eclipsecolorthemes.org/ as another option.		
					
	以后只保留这一个文件夹即可。		
	
	
	
	
{ "_id" : 1000010, "addr" : "Gillman Heights Condominium\n1A Gillman Heights, Singapore 100001", "fetdt" : { "$date" : 1345018964614 }, "latlng" : [ 1.281933, 103.80321 ], "name" : "Gillman Heights Condominium", "pcode" : 100001, "url" : "http://gothere.sg/maps#q:100001" }
{ "_id" : 1000440, "addr" : "44 Telok Blangah Drive\nSingapore 100044", "fetdt" : { "$date" : 1345018961499 }, "latlng" : [ 1.271687, 103.810585 ], "name" : "44 Telok Blangah Drive", "pcode" : 100044, "url" : "http://gothere.sg/maps#q:100044" }
{ "_id" : 1000450, "addr" : "45 Telok Blangah Drive\nSingapore 100045", "fetdt" : { "$date" : 1345018961534 }, "latlng" : [ 1.272116, 103.80951 ], "name" : "45 Telok Blangah Drive", "pcode" : 100045, "url" : "http://gothere.sg/maps#q:100045" }
{ "_id" : 1000460, "addr" : "46 Telok Blangah Drive\nSingapore 100046", "fetdt" : { "$date" : 1345018961538 }, "latlng" : [ 1.271791, 103.80994 ], "name" : "46 Telok Blangah Drive", "pcode" : 100046, "url" : "http://gothere.sg/maps#q:100046" }
{ "_id" : 1000470, "addr" : "47 Telok Blangah Drive\nSingapore 100047", "fetdt" : { "$date" : 1345018961540 }, "latlng" : [ 1.2721345, 103.81018 ], "name" : "47 Telok Blangah Drive", "pcode" : 100047, "url" : "http://gothere.sg/maps#q:100047" }
{ "_id" : 1000480, "addr" : "48 Telok Blangah Drive\nSingapore 100048", "fetdt" : { "$date" : 1345018961542 }, "latlng" : [ 1.272443, 103.81064 ], "name" : "48 Telok Blangah Drive", "pcode" : 100048, "url" : "http://gothere.sg/maps#q:100048" }
{ "_id" : 1000490, "addr" : "49 Telok Blangah Drive\nSingapore 100049", "fetdt" : { "$date" : 1345018961544 }, "latlng" : [ 1.272299, 103.81114 ], "name" : "49 Telok Blangah Drive", "pcode" : 100049, "url" : "http://gothere.sg/maps#q:100049" }
{ "_id" : 1000500, "addr" : "50 Telok Blangah Drive\nSingapore 100050", "fetdt" : { "$date" : 1345018961546 }, "latlng" : [ 1.2731825, 103.81023 ], "name" : "50 Telok Blangah Drive", "pcode" : 100050, "url" : "http://gothere.sg/maps#q:100050" }
{ "_id" : 1000510, "addr" : "51 Telok Blangah Drive\nSingapore 100051", "fetdt" : { "$date" : 1345018961548 }, "latlng" : [ 1.2736145, 103.81023 ], "name" : "51 Telok Blangah Drive", "pcode" : 100051, "url" : "http://gothere.sg/maps#q:100051" }
{ "_id" : 1000520, "addr" : "52 Telok Blangah Drive\nSingapore 100052", "fetdt" : { "$date" : 1345018961550 }, "latlng" : [ 1.2739435, 103.811325 ], "name" : "52 Telok Blangah Drive", "pcode" : 100052, "url" : "http://gothere.sg/maps#q:100052" }
{ "_id" : 1000530, "addr" : "53 Telok Blangah Drive\nSingapore 100053", "fetdt" : { "$date" : 1345018961552 }, "latlng" : [ 1.2744, 103.811516 ], "name" : "53 Telok Blangah Drive", "pcode" : 100053, "url" : "http://gothere.sg/maps#q:100053" }
	
	
	some bugs when using java & eclipse :
	1. SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”. error
		http://stackoverflow.com/questions/11916706/slf4j-failed-to-load-class-org-slf4j-impl-staticloggerbinder-error
	
	
	
	google map Location-aware Instant Search
	
	https://docs.djangoproject.com/en/1.5/ref/contrib/gis/tutorial/
	http://invisibleroads.com/tutorials/geodjango-googlemaps-build.html
	
	//geodjango
	
	1.spactial database:
		http://blog.burhum.com/post/49974918193/ubuntugis-gis-on-linux
		http://jingyan.baidu.com/article/3ea51489ec3cb452e71bba52.html
	
	
		sudo su - postgres
		su -c 'service postgresql start'
	
	//geoflask
	
	http://www.pythondoc.com/flask-mega-tutorial/index.html
	http://flask.pocoo.org/docs/tutorial/
	
	
	
	大家好，欢迎大家选修数字图像处理课程。我是这门课的助教，余林韵。我的联系方式如下： 手机 15120001194 邮箱 linyun.yu.08@gmail.com 地点 FIT 1-304（来之前最好与我取得联系以保证我在实验室） 希望能和大家共同进步，愉快的将本门课程学习好！
	
	
	
//0612

		//计算机系统结构
		
	编译安装opencv（因为debian分支去除了nonfree模块）
	cd ~/opencv
	mkdir release
	cd release
	cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..

	make
	sudo make install
	
	
	
	Makefile:
		http://blog.csdn.net/liangkaiming/article/details/6267357
	
	
	$(notdir $(SRCS))
	
	
	res/test_bg.jpg  res/test_fg.jpg  res/test_mask.jpg  res/test_out.jpg  50 50
	
	
	300 720
	
	
	
	
	1862 986
	
	2800 861 keju
 	2500 962 yezi
	3010 858 fujun
	0 913 lanbin
	1620 910 qile
	
	
	
	
	linyun.yu.08@gmail.com
	linyun.yu.08@gmail.com
	
	http://pan.baidu.com/s/1dDDxY0p
	
	
	
	http://developer.baidu.com/map/jshome.htm
	
//0615

baidu - key
应用ID	应用名称	访问应用(ak)	应用类别	备注信息(双击更改)	应用配置
2941058	miss	G4FqBf568YbPRIy8X5AUQ5QU	服务端		设置删除	
	
	
	http://blog.csdn.net/del1214/article/details/6768605
	
	
	http://www.admin10000.com/document/4567.html
	Mindmanager : 画流程图和思维导图。
	
	
	
2.	[数据挖掘] project 2 二分类问题 06-27
7.	[并行计算基础]	 实验展示 06-28
6.	[微计算机技术]	 实验报告 06-26
	
3.	[系统结构] 读书与实验报告（延迟提交） 06-30	
5.	[中国国情与发展] 论文	06-24
		期末论文-40分
		选择课	
	
	
	
	
ppwwyyxx	
	
geosearch	
	
	
计划：
1.	数据挖掘A
2.	国情论文A
	
 _________________________________________
/ We were young and our happiness dazzled \
| us with its strength. But there was     |
| also a terrible betrayal that lay       |
| within me like a Merle Haggard song at  |
| a French restaurant. [...]              |
|                                         |
| I could not tell the girl about the     |
| woman of the tollway, of her milk white |
| BMW and her Jordache smile. There had   |
| been a fight. I had punched her         |
| boyfriend, who fought the mechanical    |
| bulls. Everyone told him, "You ride the |
| bull, senor. You do not fight it." But  |
| he was lean and tough like a bad        |
| rib-eye and he fought the bull. And     |
| then he fought me. And when we finished |
| there were no winners, just men doing   |
| what men must do. [...]                 |
|                                         |
| "Stop the car," the girl said.          |
|                                         |
| There was a look of terrible sadness in |
| her eyes. She knew about the woman of   |
| the tollway. I knew not how. I started  |
| to speak, but she raised an arm and     |
| spoke with a quiet and peace I will     |
| never forget.                           |
|                                         |
| "I do not ask for whom's the tollway    |
| belle," she said, "the tollway belle's  |
| for thee."                              |
|                                         |
| The next morning our youth was a        |
| memory, and our happiness was a lie.    |
| Life is like a bad margarita with good  |
| tequila, I thought as I poured whiskey  |
| onto my granola and faced a new day.    |
|                                         |
| -- Peter Applebome, International       |
| Imitation Hemingway                     |
|                                         |
\ Competition                             /
 -----------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
	
	pan.baidu.com/s/1hqKJ9Hi
	
	昨日一去不复回
	深情斟满了酒杯
	月如弯钩东逝水
	最难舍蔷薇和玫瑰
	人生几十年
	总会有风雨来陪
	潇潇洒洒赴会
	今不醉不归
	痛痛快快去追
	任他爱谁谁
	不过情话说一场 梦一回
	
	快把酒满上干了这杯大声歌唱
	再借我两百块
	你看怎么样
	理想改变了我们的模样
	也让我懂得了要珍惜
	土豪的肩膀
	阳光总会在风雨之后洒向苍茫
	让我们抬起头
	学会了坚强
	就像故乡的轻声呼唤暖我心上
	看虚名轻歌
	纵酒笑一场
	
	
	
	/*	
	
	三、期末论文-40分
	选择课程内容，以“中国道路”为题，结合课程所讲内容，完成一篇学术论文（字数3000字以上），6月24日前提交至网络学堂
	
	现代化陷阱与中国道路
	
	《世界现代化陷阱与中国理性选择》
	
	1.p3 世界范围内的百年奇迹现象。作者总结1.技术革命 2.制度安排 3.商业组织
	2.p4 将现代化陷阱分为两部分：先行工业化国家的陷阱和后进国家的陷阱
		玛尔斯萨绝境，生态危机，环境污染 
		p86 总结 实际上是工业化道路上的困难。中国正处在工业化的关键阶段。
		
		p101 阿根廷之谜 拉美化 拉丁美洲是现代化的实验室 基尼系数0.552 巴西0.64
	
		p108 拉美化 失败的现代化 1.基尼系数 2.城市化率虚高（城市农村发展失衡）
	
			回顾《甲骨文》《十亿消费者》 费孝通 陈锡文 ：中国的城镇化
	
		p125 中等收入陷阱 高收入之墙
	
		p132 总结 工业化两面性 任重道远
	
	3.p137 中国奇迹之争 林毅夫
	
		中国困境：内卷化威胁
		
		
	4.p171 理性选择
	
		作者从制度和价值观上给出了很多思路
	
	5.三农
	
	
	
	
	《毛概课件》，何建宇
	
	1. 小平三步走战略
	2011年3月6日国家发改委副主任朱之鑫：2010年我国GDP达397,983亿元，人均GDP超过4000美元。
	提前40年实现邓小平提出的目标
	提前10年实现十七大目标
	
	2. 人均收入翻一番所需的时间
		中国：1978-1987（9年）；1978-1995（8年）；1995-2004（9年）； 2004-2011 （7年）
	
	
	3.快速增长能否持续？
	
		直接冲击：
			近两年经济增速回落：2012年为7.8%；2013年7.7%
			十二规划：年均增长目标7%
			世界经济复苏缓慢、欧债危机等

		理论冲击
			2007年世界银行发布《东亚复兴：关于经济增长的观点》，提出“中等收入陷阱”的概念

	3.陷阱论
		经济持续增长的挑战：
			技术创新与产业转型的因素 —— 东盟国家的天花板
		人力资源与就业
			适应技术创新需求的人力资源转型
			对劳动密集型优势的挑战
			老龄化与“人口红利”的失去：福利负担增加

		收入分配问题
			连带着大量社会问题
	
			（“狗肉节”的争议）
			
			
		何清涟《现代化的陷阱》（1998年）	
			
		问题的形成：
			快速发展、巨大成绩背后的巨大问题
	
		比较方法：
			巴西、阿根廷、泰国、印尼、中国在近30年人均国民收入水平
			
		不足之处
			类比简单化
			归因简单化
		意义
			促使我们重视当前经济社会发展中的问题
			借鉴其他国家的发展经验

		
		1995年十四届五中全会：转变经济增长方式
			粗放型  集约型：从纺织业等劳动密集型产业拉动  资本、技术密集型产业拉动
			重工业在工业增加值中的比重从1995年的50%，上升到2006年的70%
			能源、原材料消耗大幅度上升，资源、环境压力日益增大
			依赖投资和出口

		2007年十七大：促进国民经济又好又快发展，实现未来经济发展目标，关键是加快转变经济发展方式、完善社会主义市场经济体制。

		2012年十八大：创新驱动发展战略
		2013年十八届三中全会：全面深化改革；市场的决定性作用
			
		
	4.认真对待国有企业
	
		不应该忘记默默承受改革代价的一代人
			MV：刘欢《从头再来》

		不妖魔化国有企业，尤其是国有企业工人

		2004年郎咸平对TCL、海尔、科龙的质疑引发“国退民进”争论

		2009年开始舆论推动了“国进民退”的争论
			搜狐2009年专题《国进民退势起》
			“行政权力与政策意志导致的这轮国进民退，与技术进步、制度创新无关，令人对未来改革走向不无担忧。”

		在“摸着石头过河”的过程中逐步调整改革方向
			放权让利 -> 承包经营责任制 -> 转换经营机制 -> 建立现代企业制度、抓大放小
		
		
		
			
	
	国家统计局20日发布数据，去年全国城镇居民人均可支配收入26955元，扣除价格因素实际增长7.0%，农村居民人均纯收入8896元，实际增长9.3%。
	
	2013年国民经济和社会发展统计公报
	http://www.stats.gov.cn/tjsj/zxfb/201402/t20140224_514970.html
	
	
	《跨越中等收入陷阱》
		2011.7 世界银行给中国的重新分类：较高的中等收入国家
		
	 1.p3 硬件故障、软件故障、动力供应故障
	 
		定义中等收入和中等收入陷阱
			拉美 亚洲发展中国家
	
		和谐社会的提出
		汽车类比法
		
	2.软着陆
	
	
	《现代化与后现代化》
		政治文化研究
		价值观研究
		
	1.后物质主义
	
	*/
	
	
	
//0714
several important instructions
	 
8030  fc -l 7300 7320
	  a biult-in bash tool,search in history
	
convert miss-01.png -resize 42x42 miss.png
		convert is a useful tool for image processing. 
	
fuser -k 8086/tcp	
	
	
	
//0728
13562642913
	
	
Create Wifi Hotspot in Ubuntu 12.4/12.10 for android phones laptops

		1. First of all you should make sure, that your wifi adapter supports infrastructure hotspots. If you used connectify on your windows system and it worked, skip this step.

		open terminal and type: sudo lshw | less

		find -network section and make sure that driver is ath5k or ath9k, this solution will only work for those drivers, but should fit the needs for the most laptop users.



		2. We now need to install 2 additional tools to make out hotspot, 1st one is hostapd(hotspot server), 2nd one is dnsmasq(dns dhcp server)

		in terminal type: sudo apt-get install hostapd dnsmasq

		3. stop those services if started already, and prevent them from starting on system start up.

		in terminal type: 
		sudo service hostapd stop
		sudo service dnsmasq stop
		sudo update-rc.d hostapd disable
		sudo update-rc.d dnsmasq disable

		4. Now we need to set up config files. 
		in terminal type: sudo gedit /etc/dnsmasq.conf
		or sudo kate /etc/dnsmasq.conf if you use kde

		add those lines to the config file 
		Code:

		# Bind to only one interface
		bind-interfaces
		# Choose interface for binding
		interface=wlan0
		# Specify range of IP addresses for DHCP leasses
		dhcp-range=192.168.150.2,192.168.150.10

		5. hostapd config

		in terminal type: sudo gedit /etc/hostapd.conf

		and add those lines

		Code:

		# Define interface
		interface=wlan0
		# Select driver
		driver=nl80211
		# Set access point name
		ssid=myhotspot
		# Set access point harware mode to 802.11g
		hw_mode=g
		# Set WIFI channel (can be easily changed)
		channel=6
		# Enable WPA2 only (1 for WPA, 2 for WPA2, 3 for WPA + WPA2)
		wpa=2
		wpa_passphrase=mypassword

		You can change ssid name and password for anything you want here. Current config will create hotspot named myhotspot with mypassword password.

		6. Now create anywhere you want a file named start.sh
		edit it with any text editor like this:

		Code:

		#!/bin/bash
		# Start
		# Configure IP address for WLAN
		sudo ifconfig wlan0 192.168.150.1
		# Start DHCP/DNS server
		sudo service dnsmasq restart
		# Enable routing
		sudo sysctl net.ipv4.ip_forward=1
		# Enable NAT
		sudo iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE
		# Run access point daemon
		sudo hostapd /etc/hostapd.conf
		# Stop
		# Disable NAT
		sudo iptables -D POSTROUTING -t nat -o ppp0 -j MASQUERADE
		# Disable routing
		sudo sysctl net.ipv4.ip_forward=0
		# Disable DHCP/DNS server
		sudo service dnsmasq stop
		sudo service hostapd stop

		You will probably need to change ppp0 in this to eth0 (or any other number which refers to your wired connection.

		7. Last step. Now you can start your hotspot by starting our script. just run it using sudo sh
		for me it looks like this sudo sh /home/ogyct/Desktop/start.sh because I have it on my desktop


		I am not sure who is the author of this guide, I only translated it to english. But anyway if this helped, hit the thanks button. Good day

//0820，sdb 安装ubuntu14.04

安装matlab http://blog.csdn.net/lj695242104/article/details/16849397
	
50099-21292-14201-03250-24790-41816-23907-62461-58657-24048-55364-08874-18566-22288	
24301-62136-21555-63628-23951-18882-23524-13990-17158-47212-41804-63025-63883-42443	
	
	
	
	//0527
	//settings
	在启动器上添加一个local软件：				
	http://www.geekyboy.com/archives/384

	Add items to Ubuntu 12.04 Unity Launcher (quicklaunch)				
					
	Method 2
	Another method I found was to install the ‘gnome-panel’ package. (Actually it was already installed on my system for some reason.)
	sudo apt-get install --no-install-recommends gnome-panel
	With the gnome-panel I was now able to create a launcher on the desktop using the command below.
	gnome-desktop-item-edit ~/Desktop/ --create-new
	In the create launcher dialog I filled it out as follows:
	Type: Application
	Name: PhpStorm
	Command: /bin/bash /home/username/PhpStorm/PhpStorm-117.257/bin/phpstorm.sh
	NOTE: You could use /bin/sh or whatever shell you use. I use bash so that is why I put /bin/bash.
	To create a shortcut in the Unity Launcher I double clicked the new desktop launcher I created above. (NOTE: If you start PHPStorm by executing the phpstorm.sh you do not get any options at all when right clicking the icon in the Unity Launcher.) Then when PHPStorm was running I was then able to right click on the icon in the Unity Launcher and selected “Lock to Launcher”. Voila! Now I have phpstorm on the Unity Launcher.				
					
					
	eclipse的yanse等pref信息在那个文件中？
	http://stackoverflow.com/questions/4818197/eclipse-syntax-coloring-file			
	
	Specifically:

	[workspace]\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.jdt.ui.prefs
	[workspace]\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.ui.editors.prefs
	Also, for future readers, @jonas-groger added comment below regarding http://eclipsecolorthemes.org/ as another option.		
					
	以后只保留这一个文件夹即可。			
				
				
	
	
	添加启动器的终极解决方案：
		在/home/chunk/.local/share/applications下添加文件，并写入：
	
	[Desktop Entry]
	Encoding=UTF-8
	Version=1.0
	Type=Application
	Name=MATLAB R2013b
	Icon=com-mathworks-util-postvminit.png
	Path=/home/chunk/workspace/matlab
	Exec=/usr/local/MATLAB/R2013b/bin/matlab -desktop
	StartupWMClass=com-mathworks-util-PostVMInit
	OnlyShowIn=Unity;
	

	
	file:/usr/share/doc/default-jdk-doc/api/
	
	
	
	
	
	
	
	上午：java/android
	下午：web
	晚上：ML
	
	
	
	
	# start the ssh-agent in the background
	eval "$(ssh-agent -s)"
	# Agent pid 59566
	ssh-add ~/.ssh/id_rsa
	
	
	file:/usr/share/doc/default-jdk-doc/api/
	
	
	
	http://www.zhihu.com/question/24949365
	http://www.zhihu.com/question/24920157
	
	
//0826
安装LaTex - https://github.com/chenshuo/typeset
	
	配置TeXstudio。

	启动Texstudio，选择 Options-->Configure Texstudio-->Commands，XeLaTex 设置为 xelatex -synctex=1 -interaction=nonstopmode %.tex；

	选择 Options-->Configure Texstudio-->Build

	Build & View 由默认的 PDF Chain 改为 Compile & View；

	Default Compiler 由默认的PdfLaTex 修改为 XeLaTex ；

	PDF Viewer 改为 “Internal PDF Viewer(windowed)”，这样预览时会弹出一个独立的窗口，这样比较方便。
		
	
	
	
	吕正华 , 硕士
	地址: 北京市清华大学罗姆楼11-107
	联系电话: +8618611697914
	电子邮件: kainwen@gmail.com
	个人主页: http://isl.ee.tsinghua.edu.cn/kainwen
	清华大学电子系硕士
	
	
	
//0829
	
	//
	
	http://tieba.baidu.com/p/3241650033
	
	赵劼，南老赵，北轮子，中温特。 知乎“温赵轮”三大百万软狗之一。
	
	图灵社区 : 阅读 : 赵劼(@老赵):以“玩”之名(图灵访谈)
	http://www.ituring.com.cn/article/14720
	... ...对于新的技术，我一般很少看这方面的书，但是我会把源代码花一点时间（比如说一个周末）看一下，里面有一些沟沟坎坎就全都清楚了，该怎么用，靠想也能想明白。对于我比较熟悉的技术，我可能从头到尾执行一遍就知道（怎么回事）了，然后在网上看一些介绍用法的文章，我就能想到它是怎么做出来的。看一个项目我也知道从哪里看起，因为我知道它的执行过程是怎么样的。书当然也会看，但一般都是看些实现原理，设计思路的书，因为这些内容有时很难从代码里看出来。当然对于大部分我不会深入的技术，我可能就不会读源代码，直接看一些内部实现或是思路分析的书就满足了。
	
	很多人吵架都是意气之争，一语不和，就开始争论，都是想赢，而不是关注问题。
	
	
	//Matlab 之争
	补充：搜索R包时候要加r-project,如：
		computer vision r-project
	争端又见：http://weibo.com/2496638594/BktUytySR#_rnd1409327242070
	
	至于Matlab与R对比，我感觉优势很明显，通过自己的经验也知道前者更加人性化一些。并且后者目前资源十分缺乏。
		（Matlab向R的资源迁移可以作为今后的一项有意义的工作。github上R明显属于第二等公民，远不及matlab）
	下面这个分析感觉还是比较客观的：
		http://stackoverflow.com/questions/1738087/what-can-matlab-do-that-r-cannot-do
	
	
//0830
从今天起，读卢梭


... ...卢梭在《忏悔录》的另一个稿本中，曾经批评了过去写自传的人“总是要把自己乔装打扮一番，名为自述，实为自赞，把自己写成他所希望的那样，而不是他实际上的那样”。十六世纪的大散文家蒙田在《随感集》中不就是这样吗？虽然也讲了自己的缺点，却把它们写得相当可爱。卢俊对蒙田颇不以为然，他针锋相对地提出了一个哲理性的警句：“没有可憎的缺点的人是没有的。”这既是他对人的一种看法，也是他对自己的一种认识。认识这一点并不太困难，但要公开承认自己也是“有可憎的缺点”，特别是敢于把这种“可憎的缺点”披露出来，却需要绝大的勇气。
人贵有自知之明、严于解剖自己，至今不仍是一种令人敬佩的美德吗？显然，在卢梭之前，文学史上还没有出现过这样一个有勇气的作家，于是，卢梭以藐视前人的自豪，在《忏悔录》的第一段就这样宣布：“我现在要做一项既无先例、将来也不会有人仿效的艰巨工作。我要把一个人的真实面目赤裸裸地揭露在世人面前。这个人就是我。”	

... ...在这里，自我批评和忏悔导向了对社会的谴责和控诉，对人性恶的挖掘转化成了严肃的社会批判。正因为这种批判是结合着卢梭自己痛切的经验和体会，所以也就更为深刻有力，它与卢梭在《论人类不平等的起源和基础》中对于财产不平等、社会政治不平等的批判完全一脉相承，这一部论著以其杰出的思想曾被恩格斯誉为“辩证法的杰作”。	
	
	
今天所涉及的一些资料，包括道德经和管锥编，都引向了哲学。
其中一个话题是“同一”问题，见 http://baike.baidu.com/view/1150974.htm?fr=aladdin	
	
阅读计划：
洛克《人类理解论》	
钟嵘《诗品》	（因为这里提到了“指事而造形，穷情而写物”论）
	
	
//0901	
github - homepage
	
	http://chunkplus.github.io/Trash
	
	http://blog.csdn.net/a32132100/article/details/22868683	 github 分支管理
		发布dev分支指的是同步dev分支的代码到远程服务器
		git push origin dev:dev  # 这样远程仓库也有一个dev分支了
		
		创建本地关联origin/dev的分支
		git checkout dev origin/dev 	
		
		git push origin :dev  # 删除远程dev分支，危险命令哦	
	
	http://blog.csdn.net/arkblue/article/details/9790129

设置tracking：
	If you wish to set tracking information for this branch you can do so with:
		git branch --set-upstream-to=origin/<branch> gh-pages
    
    
	
关于批量删除文件后的stage changes问题：
	
	http://stackoverflow.com/questions/492558/removing-multiple-files-from-a-git-repo-that-have-already-been-deleted-from-disk
ans 1	
	git rm $(git ls-files --deleted) 
ans 2	
	git ls-files --deleted -z | xargs -0 git rm
ans 3	
	For Git 1.x

		$ git add -u
		This tells git to automatically stage tracked files -- including deleting the previously tracked files.

	For Git 2.0

		To stage your whole working tree:

		$ git add -u :/
		To stage just the current path:

		$ git add -u .
	
	
	
Using Jekyll with Pages	
	
	https://help.github.com/articles/using-jekyll-with-pages	
	
	http://jekyllbootstrap.com/usage/jekyll-quick-start.html
	
		git clone https://github.com/plusjade/jekyll-bootstrap.git chunkplus.github.com
		cd chunkplus.github.com
		git remote set-url origin git@github.com:chunkplus/chunkplus.github.com.git
		git push origin master
	傻瓜操作：
	http://jingyan.baidu.com/article/6fb756eca39760241858fbca.html
		$ git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.io
		$ cd USERNAME.github.io
		$ git remote set-url origin git@github.com:USERNAME/USERNAME.github.io.git
		$ git push origin master
		
	原理分析：
	http://blog.csdn.net/on_1y/article/details/19259435
	http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html
	
git强行push  （push本土分支 覆盖服务器端分支）
	http://www.myexception.cn/mobile/632422.html	
	git push origin vv:sandbox/woody3525 -f     强制push到某分支
	git push origin :sandbox/woody3525     表示删除此分支
	类似git status 查看改变的文件目录
	git log --name-status
	查看相邻的diff
	git log -p	
	
	
	
	
	
	
	
	
	
	
	
				
